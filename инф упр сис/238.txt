ПРОГРАММНЫЕ И АППАРАТНЫЕ СРЕДСТВА АВТОМАТНЫЙ МЕТОД ОПРЕДЕЛЕНИЯ   ПРОБЛЕМНО-ОРИЕНТИРОВАННЫХ ЯЗЫКОВ (ЧАСТЬ 2) 

Описывается новый метод определения синтаксиса и семантики проблемно-ориентированных языков с помощью диаграмм классов и диаграмм автоматов. Во второй части статьи приводится используемая автоматная модель и рассматривается задание конкретного синтаксиса с помощью системы взаимодействующих автоматов на примерах языка описания шахматных позиций и мини-языка множеств.

В первой части статьи рассмотрена центральная составляющая определения проблемно-ориентированного языка метамодель в том числе абстрактный синтаксис, задающая структуру языка. Определение структуры проблемно-ориентированного языка необходимо, но не достаточно. Для использования языка, кроме абстрактной структуры, нужны ее конкретная реализация конкретный синтаксис языка и способ применения для конкретных целей семантика языка. Конкретный синтаксис предоставляет механизм создания ввода и изменения редактирования программы как абстрактной структуры с помощью ее конкретного представления . Другими словами, конкретный синтаксис определяет однозначное соответствие из представления в экземпляр метамодели. Редактируя представление текст программы, мы изменяем состав и связи экземпляров классов метамодели. Таким образом, с одной стороны, конкретный синтаксис это нотация, используемая для изображения текстового, графического или иного конструкций языка и их комбинаций. С другой стороны, конкретный синтаксис это способ редактировать программу и транслировать изображение ее конструкций в набор экземпляров классов метамодели . В автоматном методе определения языков конкретный синтаксис задается как преобразователь, анализирующий конкретное представление программы с использованием соответствующей нотации и строящий абстрактную программу. Однако построение экземпляра метамодели редко является самоцелью как правило, с построенной абстрактной программой нужно еще что-то сделать сразу выполнить или преобразовать в какой-то другой вид для последующего выполнения. Именно этот результат, т. е. процесс выполнения в конкретной модели вычислимости или исполнимый код в конкретной системе программирования считаются смыслом программы, а соответствие, сопоставляющее программе ее смысл, называется семантикой программы 2. Существуют различные способы определения семантики языка, среди которых в программировании чаще всего используется операционная семантика. Операционный подход к определению семантики языка предполагает описание программы в терминах некоторой абстрактной машины 3. В автоматном методе в качестве такой абстрактной машины предлагается использовать систему автоматов. Таким образом, в автоматном методе конкретный синтаксис описывается в виде алгоритма анализа и синтеза экземпляра метамодели языка, а операционная семантика описывается в виде алгоритма интерпретации этого экземпляра метамодели языка. Причем для описания этих алгоритмов используется одна и та же модель системы взаимодействующих автоматов которую мы определим ниже в этом разделе. Такая унификация, по нашему мнению, является достоинством автоматного метода. С точки зрения парадигмы автоматного программирования 4, описание алгоритма в виде системы автоматов и есть реализация этого алгоритма. Мы следуем парадигме автоматного программирования и используем виртуальную машину автоматного программирования, которая интерпретирует автоматы определения проблемно-ориентированного языка и тем самым автоматически реализует анализ и выполнение программ на этом языке. Основные варианты использования, связанные как с определением, так и с применением проблемно-ориентированных языков, представлены на рис. 9 . Здесь система автоматов определения конкретного синтаксиса интерпретируется виртуальной машиной автоматного программирования, и тем самым выполняется анализ программы. Аналогично система автоматов определения семантики интерпретируется той же машиной автоматного программирования, и тем самым выполняется интерпретация программы. В автоматном методе мы предлагаем использовать следующую модель системы взаимодействующих автоматов рис. 10, 11. Входным алфавитом автомата являются, посылаемые . В зависимости от полученных событий и проверки на переходах автомат меняет свое текущее состояние и выполняет на переходах и в состояниях, адресованные . Мы придерживаемся принципа Бертрана Мейера 5 разделения операций интерфейса на, доставляющие значения и не меняющие состояния объекта, и, меняющие состояние объекта. Кроме того, мы считаем обязательным указание для каждого объекта не только, но и интерфейсов. Таким образом, мы определяем все четыре возможных интерфейса взаимодействия между автоматом, его источником событий и объектом управления события на переходах являются предоставляемыми командами автомата сторожевые условия на переходах используют требуемые запросы к объекту управления эффекты это требуемые команды объекта управления источник событий может использовать предоставляемые запросы о текущем состоянии автомата см. рис. 10 . Источником событий и объектом управления могут быть как внешние по отношению к системе автоматов объекты, так и этот же или другой автомат системы. Заметим, что унифицированная трактовка управляющих автоматов, объектов управления и источников событий является одной из наиболее существенных отличительных особенностей нашего метода по сравнению с существующими моделями автоматного программирования 4, 6. Используемая нами структура модель автомата схожа с метамоделью UML 7 см. рис. 11. Основной особенностью предлагаемой модели системы автоматов являются понятия и автомата. Каждая диаграмма автомата UML задает класс автоматов. Конкретный автомат экземпляр класса создается явным образом и интерпретируется в процессе выполнения . Взаимодействие между автоматами системы осуществляется с помощью экземпляров автоматов, вложенных в составные состояния 9. При первом переходе в составное состояние создается новый экземпляр вложенного автомата. При последующих переходах используется уже созданный экземпляр. При этом допускается рекурсивное вложение автоматов, т. е. в составное состояние может быть вложен экземпляр автомата того же класса автоматов. Исходящие переходы составного состояния наследуются всеми состояниями вложенного автомата, но могут быть в нем переопределены. Допускается задание в автоматах локальных переменных, которые могут использоваться в сторожевых условиях и в действиях на переходах автомата. Типом локальных переменных могут быть типы, определенные в метамодели языка, или встроенные типы UML. Мы предполагаем, что система автоматов содержит единственный головной автомат системы, с которого начинается выполнение этой системы . В автоматном методе определения проблемноориентированных языков не используется традиционное грамматическое описание. Мы описываем анализатор распознаватель языка в виде системы автоматов, общим входным алфавитом которых является множество представлений абстрактных знаков терминалов языка, в терминологии формальных грамматик. С практической точки зрения мы считаем представлением абстрактного знака событие, посылаемое источником событий, используемым для создания и изменения программы. Например, в качестве элементов нотации языка могут выступать символы в тексте, геометрические фигуры на диаграмме, поля и кнопки диалоговых окон, ячейки электронной таблицы, звуки произнесенной команды и т. д. Соответственно источником событий может быть лексический анализатор текста, или графический редактор диаграмм, или редактор формул, или диалоговое окно любой источник событий. Такой подход реализует описанную выше идею использования для представления программы различных нотаций, а также их комбинаций см. ч. 1, разд. Назначение и область применения метода. Наиболее характерным для автоматного метода является задание конкретного синтаксиса исходя из метамодели языка. Система конечных автоматов для распознавания языка строится по метамодели языка с помощью следующих эмпирических правил. Каждому классу с именем в метамодели языка соответствует класс автоматов с именем . Экземпляр автомата в процессе выполнения строит экземпляр класса, т. е. является его конструктором. Начальной структурной единице аксиоме языка соответствует головной автомат системы. Каждой составляющей класса в автомате соответствует составное состояние, в которое вложен автомат . Для наглядности имя этого составного состояния совпадает с именем роли класса в композиции есть часть или с именем атрибута в классе . Альтернативной декомпозиции классов соответствует альтернативная декомпозиция автоматов, а именно в каждое составное состояние вкладывается отдельный экземпляр автомата указанного класса. Дизъюнктивной композиции классов, перечислимым типам и обобщению классов соответствуют сегментированные переходы на диаграмме автомата. Кратности полюса и массивам соответствует петля на диаграмме автомата. По умолчанию, объектом управления каждого автомата является конструируемый им экземпляр класса метамодели языка. Этот объект обозначается ключевым словом, которое можно опускать в контексте данного автомата. При таком задании конкретного синтаксиса метамодель целесообразно представить в виде набора классов с использованием атрибутов, а не в виде безымянных композиций, что облегчает конструирование автоматов. Приведем пример задания текстового синтаксиса для мини-языка множеств. На рис. 12 представлена метамодель мини-языка множеств, пересмотренная с учетом изложенных рекомендаций. Применяя изложенные выше правила к метамодели на рис. 12, получаем полную систему автоматов рис. 1315. На рис. 13 использованы следующие элементы нотации. Обозначение подразумевает, что каждый элемент массива разбирается отдельным экземпляром автомата класса . Напомним, что переход из составного состояния наследуется всеми состояниями вложенного автомата и может быть переопределен в нем. Знаком обозначается любое событие. Таким образом, обрабатываются все неожиданные события, в том числе ошибки. Все события в этих автоматах это терминалы разбираемого языка. Поэтому вместо сложного выражения вида мы пишем просто на дуге перехода. На рис. 14 применяется еще ряд допустимых обозначений. Для ветвления по событиям используется переходное состояние junction state 9 и ключевое слово, которое означает любое событие, кроме альтернативных. Ключевое слово означает, что обрабатываемое на данном переходе событие снова становится текущим и должно быть обработано еще раз. Тем самым моделируется делегирование событий. Мы допускаем расширение обозначений UML, позволяя записывать объединение событий, например а также сохранение текущего события в локальной переменной, например . Для ветвления по сторожевому условию используются состояния выбора decision state 9. При этом предикат имеет обычный смысл дополняющего условия. Кроме того, в автомате экземпляр класса конструируется либо как, либо как, либо как, т. е. происходит конкретизация типа экземпляра класса . Для этого используется обозначение вида, где подкласс класса . Необходимо объяснить, как в этих автоматах учитывается приоритет операций, который относится именно к конкретному синтаксису. Заметим, что перечислимые типы считаются линейно упорядоченными. Тем самым определение перечислимого типа на рис. 12 позволяет удобно передать информацию о приоритетах операций. Для хранения последовательности знаков операций используется внешний объект . Если операция первая или ее приоритет выше предыдущей, то создается новое выражение и построенное выражение запоминается в массиве операндов. Если же операция совпадает с предыдущей, то продолжается разбор в том же экземпляре выражения без выхода из автомата . В противном случае, т. е. если приоритет текущей операции ниже предыдущей, происходит возврат из рекурсии на уровень выше в автомат, где создается новое выражение и построенная операция запоминается в массиве операндов. Заметим, что на рис. 15 в последнем автомате нет заключительного состояния, потому что завершение работы происходит по унаследованному от внешнего автомата переходу по событию . Объектами, внешними по отношению к описанной системе автоматов, являются является источником событий и является объектом управления и используется как рабочая память, представленные на рис. 16. Рассмотрим теперь язык описания шахматных позиций. Пример диаграммы, описывающей шахматную позицию, приведен на рис. 17. Нетрудно представить себе, что имеется интерактивное приложение, в котором есть панель фигур и пешек, изображение доски, и пользователь перетаскивает фигуры и пешки с панели на доску, формируя тем самым позицию. Терминалами этого языка являются события перетаскивания конкретной фигуры на конкретное поле доски. Таким образом, источником событий является графический интерфейс пользователя, спецификация которого показана на рис. 18. Здесь мы разделяем панель фигур и пешек на две панели для черных и для белых, и каждая из них является экземпляром абстрактного класса . События выбора конкретной фигуры например, щелчком кнопки мыши мы обозначаем изображением этой фигуры. Событие опускания фигуры на конкретное поле например, щелчком кнопки мыши обозначается значком . При этом действует правило взялся ходи, т. е. эти действия всегда выполняются парой. Событие завершения ввода позиции обозначено значком . В метамодели языка описания шахматных позиций см. ч. 1, рис. 4 и 6 мы устраняем безымянные композиции и ненужные ассоциации, получая метамодель, представленную на рис. 19. Далее, руководствуясь правилами преобразования классов метамодели в автоматы, изложенными в начале раздела, получаем систему автоматов рис. 20. Важно, что фигуры и пешки можно расставлять в произвольном порядке, что передается с помощью ортогонального составного состояния 9 автоматы и . В предыдущих двух примерах систему автоматов построили исходя из только метамодели языка, без привлечения иных формализмов. Однако мы вовсе не противопоставляем автоматный метод и использование традиционных формализмов при задании конкретного синтаксиса. Если синтаксис языка задан, например с помощью порождающей грамматики или синтаксических диаграмм Вирта 10, то автоматный метод позволяет эффективно использовать эту информацию. Рассмотрим набор синтаксических диаграмм Вирта рис. 21, описывающих тот же мини-язык множеств, что и грамматика в разделе Определение отношений метамодели языка см. ч. 1. Эти диаграммы получены почти автоматически из грамматики сначала для каждого правила грамматики были нарисованы очевидные диаграммы, а потом однократно используемые нетерминалы подставлены в соответствующие диаграммы. Система автоматов, распознающих конкретный синтаксис, получается автоматически из системы синтаксических диаграмм путем выполнения следующих преобразований каждая синтаксическая диаграмма преобразуется в диаграмму автомата вводятся начальное состояние, к которому присоединяется входная стрелка, и заключительное состояние, к которому присоединяется выходная стрелка нетерминалы преобразуются в составные состояния, в которые вложены автоматы соответствующих конструкций в каждой точке разветвления или слияния дуг синтаксической диаграммы вводится служебное состояние терминалы переносятся на дуги перехода в качестве событий немотивированные переходы, альтернативные мотивированным, помечаются ключевым словом else . Пример результата такого преобразования для самого сложного нетерминала приведен на рис. 22. Этот автомат является распознавателем конструкции, т. е. он переходит в заключительное состояние тогда и только тогда, когда на вход ему подается корректное выражение мини-языка множеств. Автомат-конструктор класса показан на рис. 23. Он получен из автомата-распознавателя добавлением действий на переходах, причем некоторые действия являются условными, поэтому применены сегментированные переходы. Кроме того, объединены эквивалентные состояния и, и . Мы видим, что наличие традиционного формального описания синтаксиса резко упрощает построение системы автоматов распознавания. Вместе с тем система автоматов разбора ничуть не становится проще по причине того, что структура системы автоматов никак не связана в данном случае со структурой конструируемого объекта, и ее приходится учитывать вручную при программировании действий на переходах . Это еще одно свидетельство в пользу целесообразности рассматривать абстрактный синтаксис как главное и первичное описание языка. 