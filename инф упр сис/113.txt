КОДИРОВАНИЕ  И  ПЕРЕДАЧА  ИНФОРМАЦИИ ПРОСТОЙ АЛГОРИТМ ДЕКОДИРОВАНИЯ АЛГЕБРАИЧЕСКИХ КОДОВ 

Рассматривается алгоритм декодирования, который представляется самым простым и естественным в классе алгоритмов декодирования алгебраических кодов до их корректирующей способности. Приводятся вывод, описание, анализ и доказательство корректности алгоритма. Асимптотическая сложность алгоритма совпадает со сложностью лучших алгоритмов декодирования, а описание является самым простым из описаний известных алгоритмов.

Корректирующие коды получили широкое применение в задачах передачи, хранения и защиты информации. Для кодов, имеющих алгебраическую структуру, существуют алгебраические алгоритмы декодирования. Под алгебраическим декодированием понимают методы декодирования, основанные на алгебраических свойствах кодов и состоящие в решении уравнений иили систем уравнений с полиномиальной сложностью. Классические алгебраические алгоритмы декодирования обеспечивают исправление ошибок до конструктивной корректирующей способности кода, но имеют довольно сложное и громоздкое описание. В работах 7, 8 предложен алгоритм декодирования, который представляется самым простым и естественным в классе алгоритмов декодирования алгебраических кодов до их корректирующей способности. Асимптотическая сложность алгоритма совпадает со сложностью лучших алгоритмов декодирования, а описание является самым простым из описаний известных алгоритмов. В статье предлагается описание, оригинальный вывод и доказательство корректности алгоритма. Приводится пример алгоритма декодирования. Описание алгоритма декодирования приведем для кодов РидаСоломона, так как для других классов алгебраических кодов принципиальных отличий в описании алгоритма нет. Рассмотрим код РидаСоломона над конечным полем GF с длиной 1, числом информационных символов и конструктивным расстоянием 1, где степень простого числа. Корректирующая способность кода равна где целая часть числа . Порождающий многочлен кода РидаСоломона обозначим через где произвольное натуральное число примитивный элемент GF . Далее для упрощения изложения будем рассматривать только случай 1. Принятый вектор представлен многочленом где кодовое слово вектор ошибок. Пусть содержит ошибок, которые имеют координаты, причем 0 ... 1, и значения Назовем величины локаторами ошибок, а значениями ошибок. Многочлен локаторов ошибок обозначим через где локатор ошибки в векторе ошибок . Положим по определению 1, если ошибок нет. Известно несколько методов кодирования для кодов РидаСоломона. В настоящей работе применяется спектральное кодирование в частотной области для несистематического кодирования. Заметим, что алгоритм декодирования не зависит от метода кодирования. Информационный многочлен кода РидаСоломона обозначим как При спектральном кодировании компонента кодового слова вычисляется как Вывод алгоритма декодирования, основанный на интерпретации работ 14, предложен в работах 5, 6. Если, то Если то 0. Следовательно Пусть . Тогда ключевое уравнение имеет вид Построим такой интерполяционный многочлен, что где Далее, из имеем сравнение Учитывая, что переписываем условие решения сравнения на эквивалентное Решаем сравнение применением расширенного алгоритма Евклида к многочленам 1 и, получая многочлены и . Информационный многочлен получается делением Приведем алгоритм из работы 7. Заметим, что этот алгоритм ранее был введен в работе 8. Для упрощения изложения будем рассматривать только классические коды РидаСоломона с параметрами 1 и 1. 1. Интерполяция. Построим такой интерполяционный многочлен, что где 2. Незаконченное вычисление наибольшего общего делителя. Решаем сравнение применением расширенного алгоритма Евклида к многочленам 1 и, получая единственную пару многочленов и . 3. Деление. Информационный многочлен есть Асимптотическая сложность алгоритма log совпадает со сложностью лучших классических алгоритмов декодирования кодов Рида Соломона 911. Первый шаг алгоритма может быть выполнен любым быстрым алгоритмом вычисления дискретного преобразования Фурье над конечным полем, например 12, 13, со сложностью log операций. В случае, когда необходимо минимизировать число умножений, лучший алгоритм для малых длин предложен в работе 14. Одна из лучших реализаций второго шага есть алгоритм Мнка 15 со сложностью log операций, который также воспроизведен в монографиях 16, 17. Заметим, что при этом второй шаг полностью совпадает с алгоритмом решения ключевого уравнения Сугиямы и других 18. Деление на третьем шаге алгоритма выполняется за операций. При приложении алгоритма декодирования к другим классам алгебраических кодов, таких как коды БоузаЧоудхуриХоквингема, коды Гоппы или альтернантные коды, необходимо добавить дополнительный шаг, восстанавливающий кодовое слово по информационному многочлену. Для завершения вывода алгоритма декодирования необходимо доказать существование и единственность полученного решения. Пусть имеются два решения сравнения Первое решение, полученное применением расширенного алгоритма Евклида к многочленам 1 и с правилом остановки дает пару многочленов и . Если делится на без остатка, то многочлен будет информационным многочленом кода Рида Соломона. Заметим, что расширенный алгоритм Евклида надо проводить с нулевого фиктивного шага, а не с первого, как обычно. Заканчивать расширенный алгоритм Евклида надо дополнительным с нулевым остатком шагом. Другое решение истинное удовлетворяет сравнению при декодировании до корректирующей способности кода РидаСоломона и приводит к другому информационному многочлену кода РидаСоломона Вначале рассмотрим вырожденный случай, когда решение сравнения заканчивается на нулевом шаге расширенного алгоритма Евклида, и докажем, что информационные многочлены, полученные из обоих решений, совпадают. Пусть Тогда так как из нулевого шага расширенного алгоритма Евклида следует, что Далее будем полагать, что Заметим, что по свойству степени линейных коэффициентов в расширенном алгоритме Евклида. Выполним деление с остатком Если остаток от деления равен нулю 0, то многочлен будет информационным многочленом кода РидаСоломона. Очевидно, что Покажем, что информационные многочлены, полученные из обоих решений, совпадают, т. е. После преобразований получаем сравнение Оценим степени произведения многочленов в каждой части сравнения. Из следует т. е. Видно, что степени произведения многочленов в каждой части сравнения не превышают степень модуля 1, т. е. сравнение справедливо как равенство для многочленов Отсюда после деления имеем Из последнего равенства видно, что делится на без остатка, т. е. 0 и После еще одного деления имеем и Показано, что решение сравнения, полученное применением расширенного алгоритма Евклида, всегда существует и совпадает с истинным решением. Ч. т. д. Рассмотрим процедуры кодирования и декодирования для кода РидаСоломона 4, 2, 3. Коэффициенты многочлена будем записывать как вектор-строку и как вектор-столбец без обозначения операции транспонирования. Вначале введем конечное поле GF5 0, 1, 2, 3, 4mod5. Или в другом представлении где примитивный элемент Введем код РидаСоломона 4, 2, 3 над GF5. Его порождающий многочлен имеет вид порождающая матрица и проверочная матрица Кодовое слово вычисляется по формуле, где матрица Вандермонда есть Пусть информационный многочлен есть Тогда процедура кодирования имеет вид Запишем матрицу, обратную к матрице Вандермонда Тогда обратное дискретное преобразование Фурье есть Пусть из канала принят вектор 1. Интерполяция 2. Незаконченное вычисление наибольшего общего делителя 3. Деление Информационный многочлен есть Рассмотренный метод декодирования предложен Гао 7 и Шиозаки 8, однако вывод и анализ алгоритма, доказательство его корректности и генетическая связь с алгоритмами 14, 9, 10, 18 являются оригинальным результатом автора 5, 6. На текущий момент этот метод декодирования и его модификации представляются автору самыми простыми для кодов с ограниченной длиной при любых реализациях. Автор выражает признательность фонду имени Александра фон Гумбольдта Германия за многолетнюю поддержку научных исследований. 