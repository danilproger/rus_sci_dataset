КОДИРОВАНИЕ И ПЕРЕДАЧА ИНФОРМАЦИИ ДЕКОДИРОВАНИЕ ОБОБЩЕННЫХ КАСКАДНЫХ КОДОВ  С ВНУТРЕННИМИ ПОЛЯРНЫМИ КОДАМИ 

1 Приводится алгоритм декодирования для обобщенных каскадных кодов с внутренними полярными кодами. Предлагаемый декодер является списочным и основан на описанных в работе структурах данных — деревьях решений для внутреннего и для всего каскадного кодов. Для этих структур данных в работе рассматривается способ эффективной реализации. Предлагаемый в работе алгоритм декодирования позволяет достичь лучшей корректирующей способности по сравнению с традиционным декодером обобщенных каскадных кодов и декодером по максимуму правдоподобия для полярных кодов.

В работе 1 были предложены полярные коды и доказано, что они достигают пропускной способности симметричных каналов без памяти с двоичным входом. Однако на практике полярные коды при использовании последовательного декодера 1 обеспечивают б льшую вероятность ошибки декодирования, чем классические коды. В статье 2 была предложена конструкция обобщенных каскадных кодов ОКК с внутренними полярными кодами, позволяющая обеспечить меньшую вероятность ошибки декодирования по сравнению с низкоплотностными кодами. При этом использовался многошаговый декодер, имеющий критическую зависимость от оценок информационных символов с предшествующих шагов ошибки на предыдущих шагах не могут быть исправлены на последующих, что приводит к их катастрофическому распространению. В данной работе предлагается алгоритм декодирования для ОКК с внутренними полярными кодами, основанный на списочном декодировании внешних кодов. Главным отличием от стандартного декодера ОКК является введение дерева решений, связывающего списочное декодирование внешних кодов со списочным декодированием внутренних кодов. Таким образом, предлагаемый алгоритм можно рассматривать как обобщение списочного декодера Тала Варди 3 полярных кодов, который позволяет достичь корректирующей способности декодера по максимуму правдоподобия при достаточно небольшой длине списка. С другой стороны, метод деревьев решений может быть использован и для случая других внутренних кодов. Основным требованием является лишь существование для них декодера, последовательно оценивающего значения информационных символов. Для полярных кодов таким декодером выступает метод последовательного иск лючения 1 с некоторыми модификациями 4. Обобщенные каскадные коды 5, 6 основаны на семействе внешних ограничимся случаем линейных внешних кодов, -кодов над и внутреннем, -коде, который рекурсивно разбивается на семейства непересекающихся равномощных подкодов в соответствии с правилами где некоторые его, -подкоды, а индекс обозначает естественную нумерацию слева направо ветвей в -м уровне дерева разбиения см. примеры на рис. 1, . На размерность подкодов на -м уровне разбиения накладывается ограничение таким образом, все коды последнего, -го уровня разбиения имеют нулевую размерность и состоят из единственного фиксированного кодового слова внутреннего кода . Кодирование данных проводится следующим образом. 1. Данные кодируются внешними кодами пусть, полученные при этом кодовые слова. 2. Для всех 0 1 символы преобразуются в кортежи длин с использованием некоторых фиксированных базисов Эти кортежи объединяются в вектор длины, который однозначно задает путь в иерархии разбиения внутреннего кода см. рис. 1. В примере разбиения внутреннего 4, 3, 2кода с одной проверкой на четность для обобщенного каскадного кода с двумя внешними кодами рис. 2 8, 1, 8-код с повторениями над 4 и расширенный 8, 4, 4-код Хэмминга над 2. Если все используемые коды и являются линейными, то множество получаемых таким образом векторов образует линейный блоковый Стоит отметить, что при разбиении внутреннего кода элементы одного семейства являются различными смежными классами одного и того же подкода в силу выбора внутреннего кода линейным. И, кроме того, для разбиения на рис. 2 подкоды имеют бесконечное минимальное расстояние 4, а 2. Многие коды с наилучшими параметрами были получены как обобщенные каскадные 5. Назовем ядром Арикана матрицу а через обозначим ее -ю кронекеровскую степень матрицу размерности 2 2 . Пусть это 2 2 -матрица такой перестановки для вектора длины 2, что номер новой позиции -го элемента получается как обратная запись представленного в виде -битной последовательности числа . Например, 4 1 0 0 0 0 1 1, 3 0 1 1 1 1 0 6. Будем обозначать скалярный канал со входом и выходом как, отождествляя его с функцией плотности условной вероятности выходного символа. В случае передачи последовательности данных размера через канал будем рассматривать эквивалентный векторный канал с выходом рис. 3, . В статье 1 был предложен метод поляризации симметричного канала без памяти с двоичным входом предполагается, что 2 и через канал передается преобразованный блок данных Метод заключается в представлении как совокупности двоичных каналов рис. 3, которая обладает следующими свойствами. 1. Эквивалентность и суммарная пропускная способность равна при условии, что для каждого известны точные значения информационных символов см. рис. 3, . 2. Асимптотическая поляризация каналов из при относительная доля в таких, что стремится к, а пропускная способность остальных 1 каналов стремится к нулю. Поляризационный эффект достигается применением невырожденного преобразования к данным. И, таким образом, поляризующее преобразование канала основано на поляризации векторных каналов меньшей размерности Эта декомпозиция для плотностей вероятностей выражается как 1 1 2 где и обозначают компоненты вектора только с четными и нечетными номерами соответственно. Таким образом, вероятности передаваемых битов в каналах оцениваются через рекуррентные формулы 1, 2 с условием для выхода из рекурсии. При каналы будут либо абсолютно без шума, либо абсолютно ненадежными. Поэтому информационные символы, передаваемые по каналам плохого качества, можно считать всегда фиксированными замороженными. Если сопоставить -ю строку матрицы каналу то наиболее надежным каналам из соответствует линейный код длины 2 и размерности, называемый полярным кодом. В итоге, чтобы задать полярный код порядка, достаточно указать множество индексов неиспользуемых строк матрицы . Был предложен 1 последовательный метод декодирования полярных кодов алгоритм последовательного исключения рис. 4. Этот алгоритм обладает существенным недостатком при неверном оценивании информационного символа все последующие компоненты, 1, 2 1 вектора, вероятно, также будут оценены ошибочно. Несмотря на хорошие асимптотические свойства, на практически значимых длинах 1000 полярные коды проигрывают классическим кодам, так как вероятности ошибок в эквивалентных подканалах остаются достаточно большими. Использование внешних кодов позволяет серьезно улучшить корректирующую способность полярных кодов 2. Рассмотрим ОКК c 2 внешними кодами над 2 длины возможно, 0-кодов с бесконечным минимальным расстоянием и внутренним полярным 2, 2 -кодом со следующим разбиением, где состоит из таких кодовых слов, для которых первые информационных символов совпадают с маркерами пути до вершины для 1 пример приведен на рис. 5. Таким образом, разбиение является идеально сбалансированным бинарным деревом и совпадает со схемой кодирования данных ядром Арикана порядка . Стоит отметить, что после процедуры кодирования таким кодом получается кодовых слов полярного 2, 2 -кода. В работе 2 был предложен метод, позволяющий синтезировать коды из представленного семейства исходя из правила равенства вероятностей ошибки декодирования внешних кодов в им соответствующих каналах из при заданном отношении сигналшум. И хотя рассмотренная каскадная конструкция позволяет уменьшить негативный эффект от слабой поляризации эквивалентных подканалов для коротких полярных кодов, она не лишена главного недостатка алгоритмов последовательного декодирования результат каждого шага декодирования полностью зависит от достоверности оценок информационных битов с предшествующих шагов. Одним из способов преодоления проблемы критической зависимости от оценок информационных символов с предшествующих шагов является списочное декодирование, позволяющее одновременно отслеживать несколько вариантов таких оценок. Дерево всевозможных решений для полярного 4, 3-кода представлено на рис. 6, . Будем называть его деревом решений внутреннего кода ДВК. Для того чтобы ограничить рост числа его листьев, необходимо на каждом шаге ранжировать текущие ветви по степени надежности размещенных в их листьях оценок и отсекать те, что соответствуют наименее надежным вариантам. В качестве меры надежности оценок выступают величины . Таким образом, все вычисления в списочном декодере необходимо проводить напрямую с вероятностями, что приводит к быстрому убыванию вычисляемых характеристик к нулю. Предлагается 3 на каждом шаге нормировать вероятности на их максимум по всем ветвям. Такой подход позволяет их дальнейшее использование при декодировании внешних кодов в метрике Евклида в каскадной конструкции с внутренними полярными кодами. Но его существенными недостатками являются использование вычислений с плавающей запятой и операций деления, невозможность получить истинные вероятности значений битов, что накладывает ограничение на используемые внешние коды. В связи с этим было показано 4, каким образом необходимо модифицировать алгоритм последовательного исключения, чтобы он вычислял величины и для -го информационного символа. Назовем этот алгоритм как . Основная идея алгоритма заключается в решении следующей задачи имея и для 0,1, необходимо вычислить Эта проблема может быть решена приближенно. Так, не ограничивая общности, будем считать, что log log log log . Тогда искомое выражение можно представить как В случае, когда log log log log мало например, меньше 70, В итоге аппроксимация для формулы 1 представляется в следующем виде где log log log log . Пусть теперь параметр длины списка декодера обобщенных каскадных кодов с внутренними полярными кодами на каждом шаге декодирования в ДВК оставляются только наиболее надежных ветвей рис. 6, отсекаемые ветви обозначены пунктирной линией. В данной работе надежность ветвей предлагается оценивать с помощью списочных декодеров внешних кодов . Пусть это кодовое слово кода . Тогда, является кодовым словом внутреннего полярного тривиального 2, 2 -кода . Таким образом, чтобы получить оценку кодового слова внешнего кода, необходимо знать оценки -х информационных символов всех внутренних кодов. Пусть известны логарифмические отношения правдоподобия, 0 оценок -х информационных символов всех внутренних кодов. Тогда с помощью некоторой процедуры, списочного декодирования внешнего кода может быть получен список его кодовых слов. На основе списка определяется как надежность ветвей, так и решения о возможных значениях информационных символов для внутренних полярных кодов. Будем называть структуру данных, сохраняющую списки кодовых слов внешних кодов, деревом решений ОКК ДОКК. Его пример представлен на рис. 7. Дерево решений ОКК однозначно задает и ДВК. Будем называть -й проекцией ДОКК дерево, получаемое при удалении размещенных в узлах кодовых слов всех символов, кроме -го см. рис. 7. Проекции соответствуют возможным значениям при списочном декодировании полярного кода с помощью решений декодера внешних кодов. В целях исключения избыточности каждая ветвь ДВК соответствует какому-то набору ветвей ДОКК. Чтобы установить такое соответствие, требуется проводить идентификацию узлов в ДОКК. Для узлов на -м уровне следует воспользоваться следующими способами 1 каждому узлу может быть поставлена в соответствие пара чисел, где это номер родительской ветви в предшествующем уровне, а это номер ее потомка, соответствующего узлу 2 каждому узлу может быть поставлено в соответствие число, равное номеру узла в м уровне при их нумерации слева направо, что соответствует естественному перечислению листьев в последнем уровне дерева. Совместное использование способов 1 и 2 позволяет при удалении каких-то ветвей в дереве единообразно перенумеровывать оставшиеся как 0 1 без каких-либо пропусков на всех шагах. Возможны и другие способы реализации ДОКК, но перенумерация ветвей при операциях вставки и удаления листьев представляется наиболее удобной. Для примера на рис. 8 для всех ветвей деревьев-проекций приведены наборы им соответствующих номеров ветвей текущего ДОКК. Удаление ветви в ДОКК приводит к изменениям во всех деревьях внутренних кодов. На рис. 8 показан пример таких изменений удаляемая ветвь в ДОКК и соответствующие изменения в ДВК обозначены зеленым цветом. Дерево решений ОКК как структура данных должна поддерживать операции и 1 операция, добавляет элементы списка в качестве потомков узлу под номером в -м уровне дерева 2 операция, пусть перестановка, соответствующая упорядочиванию списка из вещественных чисел по убыванию, причем равно текущему числу ветвей в дереве. Тогда удаляет в нем -ю ветвь, если при условии начала нумерации в с нуля. В целях наглядности общего алгоритма декодирования будем считать, что обновление ДВК при изменениях в дереве решений ОКК происходит в процедурах и . На рис. 9 представлен общий алгоритм списочного декодирования. В нем предполагается, что все ДВК являются проекциями ДОКК. В строке 4 алгоритма величина означает -й информационный символ при условии, что в качестве оценок ему предшествующих символов были выбраны расположенные в ветви -го ДВК. Оценка реализации величины проводится с помощью процедуры, вызываемой с дополнительным параметром, определяющим, какая ветвь -го ДВК была выбрана в качестве оценок предшествующих информационных символов. Алгоритм при 1 вырождается в традиционный декодер ОКК. Кроме того, процедура оценивания надежности ветвей ДОКК строки 7, 8 на рис. 9 может быть параметризована. Стоит отметить, что итоговая корректирующая способность, обеспечиваемая, напрямую зависит от выбора метода списочного декодирования внешних кодов. Например, для коротких линейных кодов в качестве такового могут быть 1 декодер по максимуму правдоподобия, возвращающий список из кодовых слов с наибольшим правдоподобием 2 декодер box-and-match 7 3 декодер порядковых статистик 8. Вычислительная сложность алгоритма равна 2 при фиксированном размере выхода процедуры, где это порядок внутреннего полярного кода, длина внешнего кода, а это функция вычислительной сложности декодирования внешних кодов. Таким образом, сложность всего алгоритма существенным образом зависит от сложности списочного декодера внешних кодов. Для оценки объема используемой памяти уже необходимо знать максимальный размер списка, выдаваемого процедурой списочного декодирования внешних кодов. Тогда число ветвей в ДОКК не превосходит величины . И, следовательно, в целях быстродействия можно использовать массив флагов, указывающих, какие элементы набора из ветвей являются активными в текущий момент. Соответственно, число ветвей ДВК никогда не превосходит 2 . Таким образом, размер требуемой памяти для алгоритма равен . Согласно процедуре 2, был получен обобщенный каскадный 1016, 508-код, состоящий из 8 внешних БЧХ-кодов длины 127 с минимальными расстояниями 0, 30, 43, 8, 47, 9, 12, 3 и внутреннего полярного кода порядка 3. При имитационном моделировании код был продекодирован представленным декодером с размером списка 1, 2, 4 рис. 10. В результате был достигнут существенный выигрыш по сравнению с алгоритмом Тала Варди 3 списочного декодирования полярного 1024, 512-кода, который, как было показано 3, при длине списка 32 приближается к корректирующей способности по максимуму правдоподобия. В работе представлен алгоритм списочного декодирования обобщенных каскадных кодов с внутренними полярными кодами, позволяющий улучшить корректирующую способность по сравнению с традиционным декодером ОКК. Данное исследование было выполнено в рамках работ по госконтракту 07.514.11.4101, исполняемому в рамках ФЦП Исследования и разработки по приоритетным направлениям развития научно-технологического комплекса РФ на 2007 2013 годы при финансовой поддержке Министерства образования и науки Российской Федерации. 