ПРОГРАММНЫЕ И АППАРАТНЫЕ СРЕДСТВА РЕАЛИЗАЦИЯ КОНЕЧНЫХ АВТОМАТОВ  НА ФУНКЦИОНАЛЬНЫХ ЯЗЫКАХ ПРОГРАММИРОВАНИЯ 

Рассматриваются вопросы реализации на функциональных языках программирования событийных структурных конечных автоматов, используемых в автоматном программировании. На примерах показаны решения, имеющие преимущества перед реализациями на императивных языках программирования.

Несмотря на все более широкое использование автоматных моделей при разработке программного обеспечения, в настоящее время не известно методов реализации на функциональных языках программирования 1 событийных структурных конечных автоматов, используемых в автоматном программировании 2. Основное отличие функциональных программ от императивных состоит в том, что функциональная программа представляет собой некоторое выражение в математическом смысле, а выполнение программы означает вычисление значения этого выражения. При этом слово вычисление вовсе не означает, что операции производятся только над числами. При сравнении чистого pure функционального и императивного подходов к программированию можно отметить следующие свойства функциональных программ в чистых функциональных программах отсутствуют побочные эффекты, поэтому в них не существует прямого аналога глобальным переменным и объектам императивных языков программирования в функциональных программах не используется оператор присваивания в функциональных программах нет циклов, а вместо них применяются рекурсивные функции выполнение последовательности команд в функциональной программе бессмысленно, поскольку одна команда не может повлиять на выполнение следующей. Отсюда следует, что при использовании чистых функциональных языков программирования например, языка не удается непосредственно применять методы, используемые при реализации конечных автоматов на императивных языках программирования например, языка . Это объясняется тем, что состояние автомата, по сути, является глобальной переменной, а обработка последовательностей событий в императивных языках производится при помощи циклов. В теории конечных автоматов существуют два класса абстрактные и структурные автоматы. Абстрактные автоматы обычно используются при разработке систем генерации парсеров по контекстно-свободным грамматикам и регулярным выражениям см., например, работы 3, 4. Функции переходов в таких задачах обычно строятся не по диаграммам состояний, а по множеству порождающих правил. В свою очередь, реализации на императивных языках программирования, построенные по диаграммам состояний, обычно валидируются сторонними утилитами, а не компилятором. В событийных системах управления применяются структурные автоматы, ранее использовавшиеся в аппаратных реализациях. В общем случае такие автоматы содержат два типа входных воздействий события и входные переменные. Неизвестны работы, в которых описано, как на функциональных языках программирования реализовать автоматы указанного класса, так как для таких автоматов требуется формирование выходных воздействий, а чистые функции не позволяют реализовать их непосредственно. В настоящей работе рассматриваются автоматы, управляемые только событиями. Реализация таких автоматов в функциональном программировании обычно не рассматривается. Таким образом, авторами решаются следующие задачи реализация на функциональных языках программирования событийных структурных автоматов, в которых входные переменные отсутствуют, и валидация функций переходов таких автоматов в процессе компиляции. В работе используется язык Haskell 58, так как в отличие от иных подобных языков, он близок к в нем отсутствуют побочные эффекты он не нарушает функциональные концепции при вводе-выводе. Кроме того, этот язык достаточно популярен в академической среде, и для него существует несколько качественных компиляторов. Суть предлагаемого подхода к реализации функции переходов на функциональных языках программирования состоит в представлении событий автоматов при помощи алгебраических типов данных, а состояний кортежами или структурами соответствующих переменных. Продемонстрируем различные реализации счетного триггера на примерах. Пусть требуется реализовать счетный триггер рис. 1, реагирующий на события. Другими словами, требуется построить конечный автомат с двумя состояниями, кодируемыми нулем и единицей, который управляется кнопкой. Каждое нажатие кнопки порождает событие . К выходу конечного автомата подключена лампа. Каждое событие переводит автомат в состояние 1, где текущее состояние. При этом переменная состояния одновременно является выходной переменной . Таким образом, каждое нажатие кнопки будет приводить то к включению лампы, то к ее выключению. Исходный код, реализующий данный счетный триггер, приведен в листинге 1. Рассмотренная реализация функции переходов не является единственно возможной. Например, для этой цели можно использовать конструкции Однако в этом случае исходный код обычно получается длиннее, поскольку такая конструкция требует частичного дублирования. Поэтому в дальнейшем будет использоваться оператор . Для того чтобы добавить возможность применения последовательности событий к начальному состоянию автомата, введем функцию . Если бы в реализуемом примере было более одного конечного автомата, то пришлось бы писать несколько функций, аналогичных . Поэтому можно выделить общую их часть в библиотечный код, пригодный для написания других конечных автоматов. В листинге 3 приведен разработанный библиотечный код, а также реализация счетного триггера с его использованием. Отметим, что новая версия функции листинг 3 является левой сверткой одна из стандартных операций функционального программирования списка событий по функции переходов. Поэтому можно заменить все определение функции на . Алгебраические типы данных позволяют производить более строгие проверки по сравнению с конструкциями, сходными с конструкцией императивного языка С. Например, при использовании алгебраических типов данных невозможно случайно проверить на равенство элемент множества состояний с элементом множества событий. Еще одним преимуществом функционального подхода является то, что компилятор способен самостоятельно проверить полноту и непротиворечивость веток оператора, тем самым осуществляя валидацию функции переходов на этапе компиляции. Функции переходов в предыдущих примерах самостоятельно не производили выходных воздействий, а только возвращали результирующее состояние, которое печаталось на консоль функцией . На практике автоматам требуются и другие классы выходных воздействий для того, чтобы выводить сообщения на экран, отправлять пакеты данных в сеть, обмениваться событиями и т. д. В качестве примера реализации автомата с выходными воздействиями рассмотрим счетный триггер с четырьмя состояниями рис. 2. Его отличие от предыдущего триггера заключается в том, что лампа будет включаться или выключаться только после отпускания кнопки, а повторное нажатие или отпускание кнопки не будет производить никакого эффекта. Общую часть реализаций этого примера для экономии места вынесем в отдельный листинг 4. Один из вариантов реализации выходных воздействий изменить функцию переходов так, чтобы она возвращала не только новое состояние автомата, но и список выходных воздействий некоторого типа. Это может быть как арифметический тип данных, представляющий собой множество возможных выходных воздействий, так и тип . В этом случае ответственность за выполнение выходных воздействий лежит на той части кода, которая вызывает функцию переходов автомата. Достоинством данного подхода является его гибкость. Листинг 5 демонстрирует данный подход. Проблема реализации выходных воздействий может быть решена также модификацией функции переходов. При этом в качестве возвращаемого значения она будет иметь тип, где тип состояния автомата, а сами выходные воздействия будут выполняться непосредственно в самой функции переходов листинг 6. Второй подход предоставляет больше свободы, так как в данном случае функция переходов не является чистой. Данный способ реализации является аналогом подхода, используемого в императивных языках программирования, поскольку все вычисления выполняются строго в контексте . В работе предложены методы реализации событийных структурных конечных автоматов на языке Haskell. При этом продемонстрированы преимущества этих подходов по сравнению с реализациями на императивных языках программирования. Такими преимуществами являются строгая типизация составных частей конечного автомата и валидация функции переходов компилятором. 