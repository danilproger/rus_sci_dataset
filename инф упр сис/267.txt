КОДОВЫЕ ШАРАДЫ 

Рассматривается метод противодействия DoS-атаке с использованием шарад, построенных на основе кодов, исправляющих ошибки. Обосновывается практическая состоятельность итеративного метода конструирования шарад. Итеративные кодовые шарады позволяют исключить применение квантового компьютера и массированного распараллеливания в целях снижения трудоемкости отыскания решения.

DoS-атаки широко распространены в сети Интернет 1, 2. Задача атакующего создать искусственную ситуацию, в которой добросовестному потребителю будет отказано в предоставлении соответствующих услуг. Для объяснения воспользуемся следующей бытовой аналогией. Предположим, что в ресторане имеется некоторое количество столиков и каждый можно зарезервировать, позвонив по телефону. Звонки принимаются до часа дня включительно. Злоумышленник, воспользовавшись простейшей стратегией, способен причинить ресторану ощутимый финансовый и репутационный ущерб. Для этого достаточно зарезервировать все доступные столики до установленного часа. Очевидно, что если все столики уже зарезервированы, то большинство потенциальных посетителей откажется от запланированного посещения и предпочтет другой ресторан. Конечно же, в какой-то момент руководство ресторана обнаружит факт злоупотребления и аннулирует резервирование, но с непренебрежимой вероятностью некоторое количество столиков в течение вечера не будет востребовано. Поглощающая ресурсы стратегия относится к наиболее распространенному типу DoS-атаки. Так, злоумышленник способен инициировать аномальное количество сетевых соединений, но предусмотренные протоколом правила взаимодействия при этом умышленно игнорируются. Рассмотрим подробнее, как это происходит на примере TCP-соединения 3. Обычно TCP-соединение устанавливается при помощи полуторараундного протокола . Клиент инициирует соединение, передав серверу специальный SYN-пакет. В ответ сервер передает пакет SYN ACK и тем самым подтверждает соединение. По факту подтверждения соединения сервер выделяет некоторую область памяти. Подчеркнем, что объем выделенной под соединения памяти конечен. В завершение клиент выполняет квитирование и передает серверу ACKпакет. Атакующий инициирует множество соединений, в которых пакеты SYN и SYN ACK передаются в соответствии с протоколом, но умышленно опускает квитирование, т. е. ACK-пакет никогда не передается. В итоге соединение не устанавливается, но при этом сервер не освобождает выделенную область памяти. Если количество таких незавершенных соединений достаточно велико, то происходит переполнение памяти и сервер перестает реагировать на какиелибо запросы. Понятно, что на прикладном уровне описанная сетевая атака приводит к отказу в обслуживании. Воспользуемся вычислительной задачей, для которой трудоемкость отыскания решения варьируется в широком диапазоне значений и задается параметрически. Для этой цели подходят такие задачи, про которые известно, что для них не существует иных, более эффективных, методов решения. Например, никакие выполненные заранее предвычисления не способствуют снижению трудоемкости. Решение может быть найдено исключительно при помощи, т. е. методом проб и ошибок с исчерпывающим перебором вариантов. Для обозначения таких задач воспользуемся термином puzzle. Идеологическая подоплека метода шарад, а также исследование их свойств восходят к пионерской работе Р. Меркля 4. Назовем того, кто создает шараду и по построению располагает ее решением, а того, кто выполняет отыскание решения по заданию экзаменатора. В работе 5 предложен практический метод противодействия сетевой атаке. Сервер предлагает решить шараду каждый раз, когда устанавливается соединение. Память под соединение выделяется только при условии предоставления правильного решения. Атакующий продуцирует запросы на установление соединения. Поскольку число таких запросов аномально велико, и в этом суть атаки, то и число шарад также велико. Искусственно созданная сетевая нагрузка возвращается к атакующему в виде вычислительной нагрузки, и для достижения поставленной цели он вынужден инвестировать. Тогда DoS-атака перестает быть беззатратной и атакующий вынужден платить за ее осуществление. Добросовестный пользователь, в отличие от атакующего, продуцирует умеренное число запросов, и для него вычислительная нагрузка не обременительна. Следует подчеркнуть, что эффективность механизма противодействия обусловлена исключительно разницей в количестве запросов на установление соединения. В работах 68 метод шарад применяется для противодействия DoS-атаке в ряде других приложений. Сформулируем набор требований к шарадам в контексте DoS-атаки. 1. Собственно шарады не должны быть инструментом атаки. Вычислительная трудоемкость построения шарады и проверки ее решения не должна быть чрезмерной. 2. Трудоемкость решения шарады должна быть регулируемой. Необходимо, чтобы сервер имел возможность гибко настраивать трудоемкость, оперативно реагируя на увеличение или снижение сетевой нагрузки. 3. Решение шарады возможно при наличии определенного вычислительного потенциала. Алгоритм решения должен быть задан строго. Трудоемкость решения должна быть ограничена сверху. Решение может быть получено за конечное время. Не должно существовать известных методов повышения эффективности решения. Известные шарады 5, 9 допускают возможность отыскания решения независимыми вычислителями, причем каждый из таких вычислителей выполняет поиск в пределах некоторого подмножества претендентов, мощность которого меньше мощности исходного множества. Назовем такой подход к поиску решения . На практике это означает, что атакующий может воспользоваться методом распределенных вычислений. Тогда применение независимых вычислителей или вычислителя с -ядерной архитектурой позволяет получить результат в раз быстрее. Очевидно, что для организации таких вычислений атакующему необходимо выполнить предварительную подготовку заданий с последующим их распределением при помощи специализированного протокола. Как только решение найдено одним из вычислителей, все остальные должны по команде прекратить обработку заданий. Напротив, шарады с последовательным алгоритмом решения 10 не допускают распараллеливания, и в этом их бесспорное преимущество. Однако эти шарады уязвимы с точки зрения атаки при помощи квантового компьютера. Известно, что трудоемкость отыскания решения шарады 10 может быть эффективно снижена в результате факторизации. Метод с полиномиальной трудоемкостью, известный как алгоритм факторизации Шора 11, 12, в существенной мере использует принцип квантовых вычислений. Объявлено о создании прототипа программируемого квантового компьютера с ограниченными вычислительными возможностями 13. Известен также пример факторизации при помощи алгоритма Шора на реальном квантовом вычислителе 14. Для эффективной факторизации числа из двоичных разрядов понадобится квантовый вычислитель с регистром на 2 квантовых состояний кубит 15. Логично ожидать появления полноценного квантового компьютера в ближайшие десятилетия. Шарады 9 не только эффективно решаются при помощи квантового вычислителя 11, но также допускают распараллеливание. Выделим следующие типы шарад с регулируемой трудоемкостью решения. 1. Шарады, допускающие распараллеливание с применением квантовыхнеквантовых вычислителей, для которых неизвестен эффективный квантовый алгоритм решения 5. 2. Шарады, допускающие распараллеливание с применением квантовыхнеквантовых вычислителей, для которых известен эффективный квантовый алгоритм решения 9. 3. Шарады, не допускающие распараллеливания с применением квантовыхнеквантовых вычислителей, для которых известен эффективный квантовый алгоритм решения 10. Таким образом, к недостаткам шарад перечисленных типов следует отнести . Следует также упомянуть отсутствие строгого доказательства того факта, что фундаментальные задачи, лежащие в основе известных шарад, относятся к классу -трудных. По мнению ряда специалистов, наличие подобного доказательства предоставляет достаточные гарантии относительной неуязвимости в долгосрочной перспективе. Задача заключается в конструировании шарады с регулируемой трудоемкостью отыскания решения, максимально широким диапазоном трудоемкости с возможностью плавной регулировки, минимальными объемом памяти и накладными расходами при передаче, которая не поддается эффективному распараллеливанию и для которой не известен эффективный квантовый алгоритм. Для решения задачи воспользуемся методами теории помехоустойчивого кодирования и линейной алгебры. Мотивация подхода в том, что вопрос об эффективном решении на квантовом компьютере фундаментальных задач теории помехоустойчивого кодирования в настоящее время остается открытым. Более того, в работе 16 показано, что эти задачи относятся к классу -трудных. Известно также 17, что трудоемкость зашифрования для кодовой асимметричной криптосистемы ниже, чем трудоемкость зашифрования для криптосистемы RSA. Логично предположить, что шарады на основе кодов не превосходят по трудоемкости построения шарады из работы 10 и сравнимы с шарадами из работы 9. Пусть имеется -мерный линейный код с минимальным расстоянием 18. Код задан порождающей матрицей . Тогда существует кодовое слово, ker, где проверочная матрица кода и информационная последовательность. Множество рассматривается как линейное пространство размерности над . Через обозначим криптографическую хэшфункцию 0, 1 0, 1 для некоторого . Свойства подробно описаны 19. Отметим, что доступна как экзаменатору, так и экзаменуемому. Назовем шарады, построенные на основе кода . Отметим, что код известен как экзаменатору, так и экзаменуемому. Для заданного, -кода экзаменатор выполняет следующие действия. 1. Выбирает информационную последовательность 2. Сохраняет для проверки решения. 3. Выбирает ошибку такую, что вес Хэмминга и 12 2 . 4. Вычисляет значение хэш-функции . 5. Вычисляет сумму . 6. Передает, экзаменуемому. Для поиска решения экзаменуемый выполняет следующие действия. 1. Выбирает ошибку такую, что . 2. Вычисляет сумму . 3. Выполняет декодирование и получает . 4. Проверяет 5. Если то переходит к 6, иначе к 1. 6. Предъявляет в качестве решения. Заметим, что в кодовой шараде секретный ключ состоит из двух компонент информационной последовательности и ошибки . Если известно, то легко вычислить, так как, и наоборот. Вес всегда должен превышать половину кодового расстояния на величину, которая обеспечивает маскировку кода с алгоритмом декодирования полиномиальной трудоемкости под код, для которого возможно только корреляционное декодирование. Размерность кода следует выбирать так, чтобы трудоемкость поиска решения перебором по превышала трудоемкость поиска решения перебором по . Действительно, если 1 то экзаменуемый найдет решение шарады, в среднем за испытаний, воспользовавшись следующим методом. 1. Выбирает информационную последовательность 2. Вычисляет кодовое слово 3. Вычисляет сумму 4. Проверяет 5. Если, то переходит к 6, иначе к 1. 6. Предъявляет в качестве решения. Использование критерия не позволяет экзаменуемому получить искомое решение за меньшее число испытаний. Предположим, и необходимо найти . Пусть выбрано такое, что 12 Если вес ошибки не превышает половины кодового расстояния, то в результате декодирования последовательность будет восстановлена правильно и решение будет получено при . Очевидно, что только при . Кодовая шарада должна допускать регулировку трудоемкости отыскания решения. Вес Хэмминга ошибки один из параметров, определяющий объем перебора при поиске решения. Обозначим через множество всевозможных претендентов. Известно, что достигает своего максимума при 2 . Например, для 2 существует претендентов на . Для поиска решения при 2 1 экзаменуемому потребуется выполнить в среднем не более 2 испытаний. C другой стороны, следует выбирать параметры кода так, чтобы трудоемкость отыскания решения варьировалась в широком диапазоне. Из указанных ограничений следует, что 12 2 и 2 Например, если предположить равенство в 2, то при фиксированном существует единственная шарада с максимальной трудоемкостью. Назовем шараду, если не существует иного, менее трудоемкого способа ее решения, кроме заданного по построению. Необходимо определить допустимый диапазон скоростей кода такой, чтобы гарантировать устойчивость кодовой шарады и обеспечить максимально широкий диапазон трудоемкости. Чем меньше минимальное кодовое расстояние, тем шире диапазон трудоемкости. Очевидно, что обратно пропорционально размерности кода. Это означает, что для конструирования шарад предпочтительнее высокоскоростные коды, для которых отношение стремится к 1. Пусть задан, 1, -код РидаСоло мона, над, где простое число положительное целое, который имеет максимально возможную размерность при заданных и 18. Тогда 1 и код исправляет 2 ошибок. Существуют, -коды с блоковой длиной 1, расширенные с и дважды расширенные с 1. Это означает, что всегда можно выбрать код с четным . Шараду на основе, -кода будем называть, -шарадой. Не существует обоснованных возражений против использования безызбыточных кодов. Тогда, 1-шарада обладает максимально широким диапазоном трудоемкости, поскольку 0 и вес ошибки варьируется в интервале 2 1. Шарада безусловно устойчива, так как 2. Следовательно, верхняя граница скорости кода совпадает с конструктивным ограничением. Нижняя граница может быть получена при помощи следующих простых рассуждений. Очевидно, что при 2 наблюдается объективное сужение диапазона трудоемкости, поскольку вес ошибки 12 . Если 2, то шарада неустойчива. Это объясняется тем, что справедливо неравенство 1 и трудоемкость отыскания решения будет ниже запланированной. Таким образом, для построения устойчивых, -шарад с широким диапазоном трудоемкости следует использовать коды со скоростями в интервале 0,5 1., 1-шарады представляются наиболее перспективными с практической точки зрения. Отметим, что для, 1-шарад ограничение на блоковую длину не является критичным, поскольку трудоемкость поиска решения в существенной степени определяется весом ., -шарады допускают распараллеливание. Попытаемся устранить этот недостаток. Воспользуемся следующим наблюдением. Как было отмечено, для организации параллельных вычислений необходимо выполнить распределение заданий. Если такое распределение выполняется однократно, то возникающими накладными расходами можно пренебречь. Предположим, что шарада состоит из нескольких подшарад. Процесс распределения заданий усложнится, если скомбинировать подшарады таким образом, что решение каждой последующей будет зависеть от решения предыдущей. Иначе говоря, атакующий будет вынужден распределять задания для каждой подшарады. При этом важно, чтобы подшарады не были известны заранее и раскрывались последовательно по мере получения промежуточных решений. Сконструируем -шараду, состоящую из вложенных подшарад. Для этого зададим вес ошибки для каждой из подшарад. В результате получим набор, . Напомним, что для, 1-шарады 1, 2. Для построения -шарады экзаменатор выполняет следующие действия. 1. Выбирает информационную последовательность 2. Сохраняет для проверки решения. 3. Устанавливает 1 и 4. Выбирает ошибку такую, что 1 . 5. Вычисляет значение хэш-функции 6. Вычисляет 7. Устанавливает 1 и 8. Проверяет 1. 9. Если 1, то переходит к 10, иначе к 4. 10. Передает, экзаменуемому. Для поиска решения экзаменуемый выполняет следующие действия. 1. Устанавливает и 2. Выбирает ошибку такую, что 1 . 3. Вычисляет сумму . 4. В результате декодирования получает 5. Проверяет . 6. Если то переходит к 7, иначе к 2. 7. Устанавливает 1 и 8. Проверяет 0. 9. Если 0, то переходит к 10, иначе к 2. 10. Предъявляет в качестве решения. Конструкция -шарады такова, что объем памяти для хранения результирующей шарады равен объему памяти для хранения отдельной подшарады. Однако потребуется дополнительная память для хранения пар . Заметим, что все имеют одинаковую разрядность и 2. Тогда для хранения -шарады при необходимо зарезервировать двоичных разрядов. Из представленной конструкции следует, что применение безызбыточного кода вполне оправдано объем памяти для хранения подшарад не зависит от . Однако для и объем памяти растет линейно по . С точки зрения резервирования памяти вклад и неравнозначен. Как правило, веса ошибок подчиняются монотонной зависимости. Следовательно, можно хранить не веса ошибок, а описание функции, при помощи которой несложно вычислить произвольное . Объем памяти для хранения такого описания не зависит от . Будем считать, что накладными расходами, связанными с хранением, можно пренебречь. Для хранения, в противоположность, может потребоваться относительно большой объем памяти. Например, если воспользоваться хэш-функцией SHA-256, то при 100 и 2 объем памяти для хранения всех на порядок превысит объем памяти для хранения и, 1 . Рассмотрим такую конструкцию шарады, у которой объем памяти для хранения не зависит от . Назовем преобразование вида где число итераций. Финальное значение получается из стартового . Понадобится также следующее свойство кода . Пусть, . Тогда и . Подойдем к конструированию шарады следующим образом. Вначале зададим вес ошибки для каждой из подшарад. Затем для методом итеративного хэширования вычислим, . Отобразим каждый на линейное пространство размерности над . Предположим, 1 и каждый состоит из -ичных символов. В результате отображения получим где последовательность из нулевых символов поля и 0 1. Заданы наборы, и, . Для построения -шарады экзаменатор выполняет следующие действия. 1. Выбирает информационную последовательность 2. Сохраняет для проверки решения. 3. Устанавливает 1 и 4. Выбирает ошибку такую, что 1 . 5. Вычисляет 6. Устанавливает 1 и . 7. Проверяет 1. 8. Если 1, то переходит к 9, иначе к 4. 9. Передает экзаменуемому. Экзаменуемый выполняет следующие действия. 1. Устанавливает, и . 2. Выбирает ошибку такую, что 1 . 3. Вычисляет сумму 4. В результате декодирования получает 5. Отображает 6. Проверяет 7. Если то переходит к 8, иначе к 2. 8. Устанавливает 1, и . 9. Проверяет 0. 10. Если 0, то переходит к 11, иначе к 2. 11. Предъявляет в качестве решения. Предположим, что для представления числа в памяти достаточно двоичных разрядов. Тогда для хранения -шарады потребуется зарезервировать не более двоичных разрядов. Трудоемкость отыскания решения не превышает 3 испытаний. Проанализируем -шараду на устойчивость. Соответствующее итеративное преобразование можно представить в виде где и для 0 . Необходимо ответить на следующий вопрос способен ли экзаменуемый, располагая набором, а также последовательностью, уменьшить запланированную трудоемкость поиска решения Конструкция -шарады напоминает луковицу. Доступ к некоторому внутреннему слою возможен только после удаления всех объемлющих слоев. Каждый слой ассоциирован с отдельной подшарадой. Слой с номером считается удаленным, если найдено решение для -й подшарады. Поиск решения начинается с первого внешнего слоя, который всегда доступен. Собственно решение шарады располагается в сердцевине луковицы в последнем внутреннем слое. Если воспользоваться геометрической интерпретацией, то каждое кодовое слово, 1кода располагается в центре сферы нулевого радиуса и все такие сферы не пересекаются. Число сфер равно числу кодовых слов, которое для, 1-кода совпадает с мощностью Тогда произвольная ошибка веса 0 переводит кодовое слово, 1-кода в другое кодовое слово того же кода с единичной вероятностью. Это означает, что каждая подшарада -шарады имеет единственное решение. При заданном несложно вычислить, которое используется в качестве критерия. Если, то в результате декодирования будет получена информационная последовательность . Из линейности кода следует, что . По построению кодовое слово маскируется ошибкой, 1, и Решение -й подшарады заключается в нахождении ошибки . Пусть заданы и некоторая ошибка . Для в результате декодирования будет получена информационная последовательность Решение будет отвергнуто, так как Поскольку применяется безызбыточный код, то для -й подшарады существует кодовых слов. При 1 2 справедливо неравенство и для отыскания решения исчерпывающий перебор ошибок ограниченного веса выгоднее, чем исчерпывающий перебор информационных последовательностей. Помимо ширины диапазона значение также имеет функция, при помощи которой задается трудоемкость. Для шарад 5 трудоемкость отыскания решения определяется мощностью множества возможных претендентов и равна 2 для некоторого параметра . В ряде случаев экспоненциальное изменение трудоемкости не адекватно воздействию и поэтому не оправдано. Необходима плавная регулировка. -шарады допускают такую регулировку за счет полиномиальной по функции изменения трудоемкости для каждой подшарады и общей линейной зависимости. Как было показано 3, трудоемкость отыскания решения для -шарады задается аддитивной функцией и допускает гибкую настройку шага изменения трудоемкости. Очевидно, что 1 . Тогда при увеличенииуменьшении на единицу веса ошибки трудоемкость отыскания решения возрастает убывает в 1раз. Поскольку то для -шарады минимальный шаг изменения трудоемкости равен . Например, можно сконструировать шараду со средней трудоемкостью отыскания решения В статье рассматривается метод шарад как способ противодействия DoS-атаке. Предложены конкретные конструкции шарад на основе кодов, исправляющих ошибки, в том числе и итеративная конструкция, которая гарантирует устойчивость, обладает широким диапазоном трудоемкости и допускает гибкую настройку. 