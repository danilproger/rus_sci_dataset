КОДИРОВАНИЕ И ПЕРЕДАЧА ИНФОРМАЦИИ АЛГОРИТМ ДЕКОДИРОВАНИЯ С ВВОДОМ СТИРАНИЙ   ДЛЯ МПП-КОДОВ, ПОСТРОЕННЫХ НАД ПОЛЕМ GF(Q) 

Предложен итеративный алгоритм декодирования для кодов с малой плотностью проверок, способный исправлять как ошибки, так и стирания. Представлена зависимость реализуемых корректирующих свойств данного алгоритма от количества стираний. Проведено сравнение данного алгоритма с мажоритарным алгоритмом для случая, когда присутствуют только ошибки.

В настоящее время в связи со все более высокими требованиями к скорости передачи данных особенно интересны кодовые конструкции, для которых существуют быстрые алгоритмы кодирования и декодирования. Естественно, что алгоритмы декодирования должны при этом справляться с большим количеством ошибок. Двоичные коды с малой плотностью проверок МПП-коды на четность были предложены Галлагером 1. Доказано 2 существование МППкодов, способных исправить линейно растущее с длиной кода число ошибок при сложности декодирования log, где длина кода. В настоящее время эти коды используются в стандартах подвижной беспроводной связи например, LTE, цифровой телефонии рекомендованы для использования в стандартах оптической связи, спутниковой связи, WiMAX, 802.11n. Дальнейшее увеличение скорости передачи возможно лишь только с помощью увеличения плотности передаваемой информации числа бит на герц, так как частотный ресурс ограничен. Одним из способов является увеличение мощности алфавита модуляции. Из-за этого особенно интересными становятся недвоичные корректирующие коды. В работе 3 построены недвоичные МПП-коды и доказан результат, аналогичный результату для двоичных. Описан также мажоритарный алгоритм декодирования для недвоичных МПП-кодов, являющийся обобщением алгоритма инвертирования бита для кодов Галлагера. Этот алгоритм способен исправлять только ошибки, однако в некоторых случаях при передаче данных например, при передаче на многих частотах в принятом векторе содержатся как ошибки, так и стирания. Основной нашей задачей является разработка алгоритма декодирования для МПП-кодов как двоичных, так и недвоичных, способного справляться как с ошибками, так и со стираниями в принятом векторе. Также будут приведены исследования реализуемых корректирующих свойств данного алгоритма, частично представленные в работах 48. Для построения проверочной матрицы -ичного МПП-кода рассмотрим блочную диагональную матрицу, на главной диагонали которой находятся проверочных матриц кода-компонента длины где избыточность кода-компонента . Пусть обозначает матрицу, полученную из матрицы произвольной перестановкой столбцов и умножением их на произвольные ненулевые элементы поля . Тогда матрица размером, составленная из таких матриц, как слоев, является разреженной проверочной матрицей -ичного МПП-кода. Из определения ясно, что длина построенного кода . Отметим, что каждый символ принятого вектора проверяется в точности компонентными кодами ровно одним в каждом слое. Графически код можно представить в виде двудольного графа, называемого графом Таннера, в котором символьные вершины соответствуют символам принятого вектора имеют степень, а кодовые вершины соответствуют компонентным кодам и имеют степень . Пример такого графа приведен на рис. 1. Нижняя оценка скорости кода получена в работе 9 1 Равенство достигается в случае полного ранга матрицы . Из соотношения 1 получим ограничение для скорости кода-компонента т. е. чем больше количество слоев, тем выше должна быть скорость кода-компонента. В данной работе будут исследованы МПП-коды с кодом-компонентом, имеющим один проверочный символ. Его проверочная матрица состоит из ненулевых элементов поля В случае 2 проверочная матрица кода-компонента имеет вид . Главная особенность этого алгоритма состоит во введении стираний на места символов, подозрительных на ошибки. На каждой итерации подозрительные символы заменяются стираниями, и далее в пределах этой итерации выполняется только исправление стираний. Стирания, которые были введены и не были исправлены, после итерации удаляются. Эти операции повторяются до тех пор, пока не случится такого, что в процессе итерации мы не исправили ни одного стирания. В результате выдается либо исправленный вектор, либо отказ от декодирования. Прежде чем привести формальное описание алгоритма, введем понятие . Обобщенный синдром это вектор, состоящий из синдромов компонентных кодов. Вес обобщенного синдрома число ненулевых синдромов кодов-компонентов. Блок-схема разработанного алгоритма представлена на рис. 2. Рассмотрим каждый из блоков более подробно. . Вычисляем обобщенный синдром. Он состоит из синдромов компонентных кодов. Если код-компонент содержит стирания, то его синдром не вычисляется и считается стертым. . Для каждого нестертого символа рассматриваются синдромы кодов-компонентов, в которые входит данный символ. Если синдром кода-компонента ненулевой и нестертый, то вычисляем . Решением назовем значение, которое нужно добавить к рассматриваемому символу, чтобы синдром кода-компонента стал нулевым. Нулевые и стертые синдромы соответствуют нулевым и стертым решениям обозначим число нулевых решений через, число стертых решений через . Выбирается подмножество одинаковых ненулевых и нестертых решений максимальной мощности если таких подмножеств несколько, то выбирается любое из них. Если, то на место рассматриваемого символа вводится стирание синдромы кодовкомпонентов, содержащих данный символ, помечаются как стертые позиция символа добавляется в список стертых символов рис. 3. . Для каждого стертого символа рассматриваются синдромы кодовкомпонентов, в которые входит данный символ. Нас интересуют только коды-компоненты, содержащие ровно одно стирание. Для каждого из таких кодов исправим стирание заметим, что это очень простая операция, после чего сформируем список возможных значений символа. Выбирается наиболее часто встречающееся значение. Это значение присваивается символу. Добавленные стирания, которые не были исправлены, удаляются. Сравниваются синдромы до и после итерации. В случае если синдром изменился, перейти к следующей итерации, иначе вычислить вес синдрома. Если вес нулевой, выдать исправленный вектор, иначе отказ от декодирования. Этот алгоритм без всяких изменений может быть применен к МПП-кодам с более мощными кодами-компонентами. Однако в случае более мощного кода-компонента можно исправить более чем одно стирание а именно 1, где кодовое расстояние компонентного кода. В связи с этим разумно изменить алгоритм декодирования блок исправления стираний. В случае 2 условие трансформируется в 2. Моделирование показало, что в этом случае вводится много стираний, что приводит к большой вероятности отказа от декодирования. В следующем разделе описано, как модифицировать алгоритм при 2, в окончание же этого раздела приведем более подробную блок-схему разработанного алгоритма рис. 4. Отличие алгоритма для двоичного МППкода заключается только в критерии ввода стирания. Как отмечалось выше, условие ввода стирания алгоритма трансформируется в двоичном случае в 2 первый критерий. Однако моделирование показало, что в случае большого количества ошибок использование данного критерия приводит к большой вероятности отказа от декодирования. Поэтому был разработан дополнительный второй критерий ввода стирания и было решено использовать оба крите рия. Критерий ввода стирания изменяется в течение декодирования принятой последовательности. На начальном этапе декодирования принятой последовательности используется первый критерий. Если использование первого критерия ввода стирания привело к отказу от декодирования, то происходит замена его на второй критерий. Если же использование второго критерия ввода стирания привело к отказу от декодирования, то происходит выход из цикла с отказом от декодирования. Таким образом, критерий ввода стирания изменяется только один раз в течение декодирования принятой последовательности, а декодирование каждой принятой последовательности начинается с использованием первого критерия ввода стирания. В этой работе мы рассматривали следующие два критерия ввода стирания для алгоритма декодирования двоичного МПП-кода. Символ заменяется стиранием, если он входит 1 в более чем 2 невыполненных проверок 2 в максимальное число невыполненных проверок если таких символов несколько, то заменяются все. Остальные шаги алгоритма не требуют модификаций для декодирования двоичного МППкода. Результат моделирования зависимость вероятности неправильного декодирования отказ или переход в другое кодовое слово от числа ошибок. Сначала задаются параметры кода и начальное число ошибок. Далее генерируется случайный код с заданными параметрами и происходит непосредственно само моделирование, т. е. генерируются случайные векторы ошибок заданного веса и подаются на декодер. Отметим, что мы не производим кодирования, а генерируем только векторы ошибок, т. е. в результате декодирования мы должны получить вектор из всех нулей. После 10 неправильных декодирований число ошибок уменьшается на величину шага. Вероятность неправильного декодирования при заданном числе ошибок вычисляется как отношение числа неправильных декодирований 10 в нашем случае к общему числу испытаний. Для каждой зависимости было проведено более 10 испытаний. Отметим, что за все время моделирования не произошло ни одного перехода в другое кодовое слово, т. е. вероятность неправильного декодирования в этом случае равна вероятности отказа. Для всех моделирований мы использовали один и тот же код со следующими параметрами 16 2048 1 2 8. В качестве компонентного кода используется код с 16. Сначала посмотрим, как изменяется корректирующая способность исследуемого алгоритма с увеличением начального числа стираний при декодировании с помощью алгоритма . На рис. 5 показано семейство зависимостей, построенных при разном начальном количестве стираний 0, 5, 10, 30, 50, 70, 90. Каждый график представляет собой зависимость вероятности отказа см. замечание 6 от числа ошибок, число стираний фиксировано. Введем следующие обозначения начальное число стираний число ошибок, при котором вероятность отказа меньше, чем 10 выбирается наибольшее число ошибок, удовлетворяющее условию. Мы будем использовать величину 2 1 для того, чтобы охарактеризовать реализуемую корректирующую способность. Полученная зависимость от начального числа стираний и ее отношение к длине МПП-кода приведены в табл. 1. Как мы видим, величина, характеризующая реализуемую корректирующую способность, уменьшается с увеличением начального числа стираний. Теперь посмотрим, как алгоритм справляется с ошибками. Пусть начальное число стираний равно нулю, т. е. в принятом векторе есть только ошибки. Сравним полученные результаты моделирования и результаты моделирования для мажоритарного алгоритма. Подробное описание мажоритарного алгоритма приведено в работе 3. Это итеративный алгоритм, на каждой итерации которого решение о замене каждого из просматриваемых символов принимается согласно мажоритарному правилу. Это правило похоже на наш критерий стирания символа и полностью совпадает с ним при отсутствии стертых синдромов кодов-компонентов. В обоих случаях используется один и тот же МПП-код. Результаты приведены на рис. 6. Как мы видим, полученные результаты для алгоритма с введением стираний оказались лучше. Для всех моделирований мы использовали один и тот же код со следующими параметрами 2 7995 1 2 7. В качестве компонентного кода используется двоичный код с проверкой на четность с 15. На рис. 7 приведено семейство зависимостей, построенных при разном начальном количестве стираний 0, 100, 200, 300. Каждый график представляет собой зависимость вероятности отказа от числа ошибок, число стираний фиксировано. Рассмотрим реализуемую корректирующую способность исследуемого алгоритма, характеризуемую величиной, введенной в предыдущем разделе. Полученные зависимости и приведены в табл. 2. Здесь в отличие от результатов предыдущего раздела растет с увеличением начального числа стираний. Теперь сравним полученные результаты моделирования и результаты моделирования для мажоритарного алгоритма декодирования двоичных МПП-кодов, подробно описанного в работе 10. В обоих случаях используется один и тот же МПП-код. Результаты приведены на рис. 8. Как мы видим, для алгоритма с введением стираний они оказались лучше. Рассмотрим теперь, как изменяется доля исправленных ошибок с заданной вероятностью отказа при увеличении длины МПП-кода. На рис. 9 представлено семейство зависимостей вероятности отказа от количества ошибок для различных длин МПП-кода. Обозначим через количество ошибок, при которых вероятность отказа равна 10, а через ее отношение к длине МПП-кода . Зависимость от МПП-кода следующая 8000 16 000 32 000 0,0345 0,0356 0,0363 Как мы видим, доля исправленных ошибок увеличивается с увеличением длины МПП-кода. Предложен итеративный алгоритм декодирования МПП-кодов, способный исправлять как ошибки, так и стирания. Проведено экспериментальное исследование предложенного алгоритма декодирования. Этот алгоритм дает лучшие по сравнению с мажоритарными алгоритмами результаты для канала, в котором есть только ошибки. 