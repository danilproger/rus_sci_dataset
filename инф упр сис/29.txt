АВТОМАТИЧЕСКАЯ ГЕНЕРАЦИЯ АВТОМАТНОГО КОДА 

Рассматривается подход к автоматической генерации кода автоматных программ на любом априори заданном языке программирования по графам переходов автоматов. The approach to the automatic automata’s program code generation is considered in the paper. The code is generated in any programming language by the automaton’s transition graph.

В последнее время весьма актуален вопрос о визуальном конструировании программ1, в частности, проблема автоматической генерации кода по графическим моделям. Модели можно разделить на два класса статические и динамические. Среди статических моделей объектно-ориентированных программ основной является диаграмма классов. Многие инструментальные средства генерируют скелет кода по диаграммам классов. Динамические свойства рассматриваемого класса программ наиболее эффективно описывают диаграммы состояний графы переходов. Известны различные инструментальные средства, генерирующие код по графам переходов 25. Указанные средства являются специализированными строят код для одного-двух языков программирования. Цель настоящей работы состоит в описании подхода к генерации кода автоматных программ программ с явно выделенными состояниями на любом априори заданном языке программирования. На основе этого подхода было создано инструментальное средство MetaAuto6, которое позволяет преобразовывать изображения графов переходов, представленных с помощью редактора MSVisio, в исходные коды программ на любых языках программирования, для которых предварительно созданы соответствующие шаблоны. В ходе работы над этим инструментальным средством в качестве примера были созданы шаблоны для трех языков программирования C, С и Turbo Assembler. . Как отмечалось выше, описываемый подход предполагает построение исходного кода на различных языках программирования. Для реализации этого требования разумно разделить этап преобразования графической модели в исходный код на два преобразование графической модели в некий общий формат представления графа переходов и преобразование из этого формата в различные языки программирования. Такое разделение приводит к большей платформенной независимости. При этом легко перейти от одного редактора графов переходов на другой, реализовав для нового редактора процедуру преобразования в общий формат. Также общий формат представления графа переходов может быть использован в валидаторах программах проверки корректности графов переходов. Для облегчения работы с данными, содержащимися в графе переходов, имеет смысл использовать программное представление общего формата. Под программным представлением понимается библиотека классов, изоморфная по своей структуре данным общего формата, которая предназначена для упрощения процесса чтения и сохранения данных различными программами валидаторами, генераторами кода, другими программами пользователя. Таким образом, этап генерации кода может быть разбит на три преобразование графа переходов в программное представление, затем изоморфное преобразование программного представления в общий формат и, наконец, преобразование из общего формата в исходный код программы. На рис. 1 изображены этапы генерации исходного кода программы. По этой схеме построено разработанное инструментальное средство MetaAuto 6. В рамках подхода к генерации исходного кода программы необходимо осуществлять преобразование графа переходов автомата, представленного в некотором общем формате, в исходный код программы. В общем случае граф переходов можно рассматривать как набор метаданных определенной структуры из предметной области решаемой задачи. Вопрос об автоматической генерации кода с заданными свойствами при этом является одним из вопросов, решаемых в рамках порождающего программирования Generative Programming7. В настоящее время в рамках порождающего программирования разработан ряд способов генерации кода. Среди них можно выделить подстановки подстановки с исполнением кода обработчики данных регулярной структуры., предполагает, что разработчик создает шаблон кода и набор данных в специальном формате, а затем, с помощью вспомогательной программы, выполняет подстановку этих данных в шаблон. Набор используемых в шаблоне подстановок может определяться как статически, так и динамически. Такой подход нагляден и прост в использовании, однако имеет весьма ограниченную область применения и требует предварительной подготовки передаваемых для подстановки данных. Классический пример подстановок с некоторыми оговорками шаблоны templates языка C . Гораздо шире возможности при . Этот вид генерации отличается от предыдущего возможностью применять в шаблоне не только подстановки, но также и вставки исполняемого кода, оперирующего переданными в шаблон данными. Исполняемый код чаще всего использует язык, который специально создан для конкретного типа шаблонов и включает основные алгоритмические конструкции, такие как, например, простое ветвление IF, выполнение итераций по переданным в качестве параметров спискам WHILE, циклы с заданным количеством итераций FOR. Отметим, что в процессе усложнения конструкций, применяемых в шаблоне, и увеличения возможностей языка уменьшается наглядность самих шаблонов. Пример использования такого способа генерации, где применяется технология ASP, первоначально разработанная для генерации HTML-страниц, приведен в работе 8. В качестве языка исполняемого кода в указанной технологии используется язык Visual Basic. Недостатком подходов к генерации кода, основанных на подстановках и подстановках с исполнением кода, является необходимость специальной подготовки данных для передачи в шаблон. Третий способ генерации кода основан на он предполагает полное разделение данных и их представления. В этом случае шаблон играет роль обработчика данных и пишется на специальном метаязыке. Примером может служить XSLT-обработка данных, представленных в XML-формате. Вопрос генерации кода на основе XSLT-преобразований рассматривается в работах911. Основным достоинством этого способа генерации кода является возможность обработки данных сложной структуры без предварительной подготовки этих данных. Существование перечисленных видов генерации кода обусловлено неоднородностью решаемых в рамках порождающего программирования задач и структуры метаданных. Вопрос об использовании того или иного способа генерации зависит от условий конкретной задачи и данных, используемых для такой генерации. Одним из вопросов, решаемых при преобразовании графов переходов автоматов в исходные коды программ, является вопрос о реализации групповых переходов12. Чаще всего автоматная процедура процедура, реализующая поведение автомата, состоит из одного оператора switch. Групповые переходы в этом случае реализуются с помощью дублирования их для всех состояний, содержащихся в группе, к которой данный групповой переход относится. Также непростой задачей является генерация логических выражений. Например, код программы, реализующей вычисление значения логических выражений для языка Turbo Assembler, сильно отличается от кода программы, реализующей вычисление логических выражений для языков высокого уровня, в которых логические выражения часто записываются одной формулой. Большое количество рекурсивных структур и другие особенности графов переходов определяют выбор способа генерации исходного кода. Инструментальное средство MetaAuto использует XSLT-технологию для генерации исходного кода. В терминах рис. 1 в качестве общего формата в MetaAuto для представления графов переходов выбран XML-формат. Генератор для преобразования общего формата в исходный код программы базируется на XSLT-шаблонах. . XSLT X S L T расширяемый язык стилей для преобразований в последнее время стал популярной XML-технологией. Спецификация определяет XSLT как язык для преобразований одних XML-документов в другие XML-документы. Однако за время своего существования XSLT стал использоваться значительно шире, например для автоматической генерации кода. В работах911 рассматривается вопрос применения языка XSLT в качестве инструмента для генерации кода программ. В работе9 отмечены основные достоинства и недостатки генерации кода с использованием этого языка. Достоинства широкие возможности по изменению шаблонов без изменения любой другой функциональности широкие возможности по манипулированию данными возможность извлекать данные из дополнительных источников возможность изменять язык программирования с помощью небольшого изменения шаблона наглядность и широкое распространение XML-формата нет необходимости каждый раз придумывать новый формат хранения данных. Недостатки трудно контролировать отступы и пробелы при генерации текста небольшое количество функций работы со строками спецификация XSLT 2.0 призвана исправить эти недостатки, однако на данный момент трудности существуют язык XSLT не предоставляет прямого доступа к операционной системе, это несколько ограничивает возможности по генерации платформенноспецифичного кода генерация нескольких исходящих документов в рамках спецификации XSLT1.0 невозможна. В работах, посвященных генерации кода с помощью XSLT-преобразования, код генерируется, как правило, по данным, имеющим линейную структуру, например по структуре таблиц базы данных10 или по списку классов UML-подобных диаграмм11. При применении метаданных линейной структуры сложно оценить все преимущества использования XSLT-преобразования. Разработанное инструментальное средство MetaAuto демонстрирует применение XSLT-преобразований для метаданных с нелинейной структурой. . Инструментальное средство MetaAuto позиционируется как универсальное. Поэтому оно должно уметь понимать различные обозначения, применяемые в графах переходов. Необходимо иметь возможность настройки синтаксиса, используемого для задания списков действий в состояниях и на переходах применяемых в этих списках символов-разделителей формата входных и выходных переменных использующихся в логических выражениях обозначений. Возможность конфигурирования такого рода основана на применении регулярных выражений мощного инструмента для задания синтаксиса. Преимуществами применения регулярных выражений в качестве инструмента конфигурирования графов переходов являются гибкость задания синтаксиса широкое распространение регулярных выражений и наличие большого количества вспомогательных инструментов для их создания большие дополнительные возможности, такие как, например, задание любого количества именованных областей. Разработанное инструментальное средство включает в себя стандартный конфигурационный файл, описывающий обозначения графов переходов из работы13. Однако имеется возможность задания собственного файла конфигурации. Рассмотрим пример создания такого файла. Создадим конфигурационный файл, поддерживающий названия входных переменных в стиле инструментального средства UniMod5. В графах переходов, создаваемых с помощью этого инструментального средства, входные переменные, как и выходные, имеют источник класс, наследуемый от класса объект управления, со следующим синтаксисом Например, если название объекта управления, а название входной переменной, то на графе перехода эта переменная изображается как . Такой способ наименования входных переменных не был предусмотрен в нотации графов переходов из работы13. Зададим формат таких входных переменных в конфигурационном файле. Предположим, что, как и в языке Java использующемся в UniMod, названия объекта управления и входных переменных состоят из букв, цифр, знака подчеркивания и некоторых других дополнительных символов. Тогда синтаксис для каждой такой входной переменной можно описать с помощью регулярных выражений вида Здесь означает допустимый в названии символ. Если применять в регулярном выражении именованные области, то синтаксис можно описать следующим образом При этом первая именованная область имеет имя и соответствует множеству допустимых символов до точки, а вторая с именем множеству допустимых символов после точки. В процессе проверки на соответствие входной строки данному регулярному выражению, при положительном ее исходе, можно извлечь название объекта управления именованная область и название входной переменной именованная область . Фрагмент конфигурационного файла, представленный в листинге 1, задает синтаксис входной переменной в стиле инструментального средства UniMod. Этот фрагмент задает шаблон для разбора входных переменных вида . Шаблон называется . Он использует именованные области для генерации уникального имени, а также создания двух параметров и . При применении данного фрагмента в конфигурационном файле для входной переменной получим объект программного представления модели библиотеки MetaAuto со значениями свойств, приведенными в листинге 2, а также изоморфное ему XML-представление, записанное в том же листинге. Опишем методику генерации исходного кода с применением разработанного инструментального средства. Будем преобразовывать граф переходов из работ 4, 13 в исходный код программы на языке C. Изобразим этот граф переходов с помощью редактора MS Visio рис. 2. Для изображения графа переходов следует использовать специально созданный шаблон, содержащий все используемые на графе переходов типы элементов. Этот шаблон предоставляется вместе с инструментальным средством MetaAuto. Он включает в себя такие элементы, как состояние, переход, описание автомата и т. д. . Изображенный на первом шаге граф переходов преобразуется в XML-формат. Этот шаг включает в себя сразу два этапа см. рис. 1 преобразование графического представления графа переходов в программное представление и изоморфное преобразование программного представления в XML-формат. Для такого преобразования воспользуемся компонентой Visio2Xml.exe, являющейся частью инструментального средства. В качестве параметров передадим компоненте путь до файла, содержащего графическую модель и название итогового XML-файла. Для запуска из командной строки используем следующую командную строку Полученный XML-файл полностью описывает граф переходов. Например, состояния и групповые состояния описываются с помощью узлов XML-файла, вложенных друг в друга. Каждое состояние может включать список запускаемых в нем автоматов и выполняемых действий. На листинге 3 представлен фрагмент XML-файла. Переходы в полученном файле описываются с помощью узлов XML-файла. Вложенные в них узлы описывают условие перехода, а также описывают список действий на переходе. На листинге 4 приведен фрагмент XML-файла. XML-файл содержит также и другие узлы. Эти узлы соответствуют описанию действий и входных переменных автомата, названию автомата и т.д. Весь XML-файл, а также подробное описание его формата приведены в работе 6. Для получения кода на языке C необходимо создать соответствующий шаблон. Как правило, по одному графу переходов требуется построить сразу несколько файлов. Например, в языке C требуется создать файл заголовков и файл реализации . . В таком случае необходимо создать шаблон для каждого такого файла. Рассмотрим шаблон для создания файла реализации, как более информативный. Назовем этот шаблон В листинге5 приведена часть этого шаблона для генерации файла, содержащего автоматную процедуру. Другая часть шаблона, отвечающая за вывод логического выражения и различных типов входных и выходных воздействий, приведена в работе 6. Выполняемые в ней действия весьма стандартны. Примеры создания таких шаблонов можно найти практически в любом пособии по языку XSLT. . Преобразуем полученный на втором шаге XML-файл в исходный код с помощью XSLT-шаблона, созданного на предыдущем шаге. Воспользуемся компонентой инструментального средства MetaAuto. Данной компоненте необходимо передать в качестве параметров путь до XML-файла, путь до шаблона и название итогового файла с исходным кодом . Для запуска компоненты воспользуемся следующей командной строкой automatas.xml common.cpp. xslt common.cpp В результате получим файл, содержащий исходный код на языке C, который реализует граф переходов см. рис. 2 и представлен в листинге 6 в два столбца. . В состав инструментального средства также включена компонента обратного преобразования файла формата XML в документ MS Visio. Для выполнения такого преобразования необходимо воспользоваться компонентой . Компоненте в качестве параметров передаются путь до файла с XML-представлением графа переходов и название итогового файла Данная компонета по XML-файлу строит графическое представление графа переходов. Получаемый в результате файл отличается от исходного только расположением состояний. Инструментальное средство MetaAuto предполагает возможность интеграции со средами разработки. Интеграцию предлагаемого инструментального средства со средой разработки MS Visual Studio рассмотрим на изложенном выше примере. Для обеспечения интеграции можно создать файл, использующийся утилитой . Этот файл предназначен для автоматизации процесса преобразования графа переходов в файл с исходным кодом. В рассматриваемом примере необходимо автоматизировать шаги 2 и 4. Для задания зависимостей между файлами, генерируемыми на этих шагах, используются командные строки, приведенные в описании этих шагов. Вариант для рассматриваемого выше примера приведен в листинге 7. Интеграция инструментального средства предполагает внедрение его в процесс компиляции проекта. Для этого в процесс компиляции требуется добавить в проект необходимые для преобразования файлы задать командную строку, выполняющую преобразование в качестве события, выполняющегося до компиляции, с помощью свойства . Программа использует и создает файлы Для тестирования рассмотренного способа интеграции инструментальное средство было внедрено в процесс компиляции самого себя. С помощью инструментального средства генерируются исходные коды синтаксического и лексического анализаторов, используемых для разбора логических выражений. Исходные коды разработанного инструментального средства, в которых используется интеграция со средой разработки MS Visual Studio, размещены на сайте httpis.ifmo.ru projectsmetaauto. В статье описан подход к автоматической генерации исходного кода автоматных программ. Рассмотрены различные технологии и методики, их преимущества и недостатки. Также описана реализация предложенного подхода в инструментальном средстве MetaAuto. Это инструментальное средство разрабатывалось как генератор кода автоматных программ на любом априори заданном языке программирования. Оно было использовано для генерации кода синтаксического и лексического анализаторов, использующихся самим инструментальным средством. Таким образом, первым успешным внедрением инструментального средства стало оно само. Однако после написания прототипа инструментального средства оказалось, что его можно использовать также и для верификации программ. Такая верификация была выполнена в работе 14. С помощью инструментального средства процесс создания верификатора был достаточно прост, так как граф переходов легко доступен при использовании программного представления модели. Авторы надеются, что настраиваемость инструментального средства и легкость его использования позволят более эффективно внедрять автоматное программирование 15. 