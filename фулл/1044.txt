ПРОГРАММНЫЕ И АППАРАТНЫЕ СРЕДСТВА РАЗРАБОТКА И АВТОМАТИЧЕСКАЯ ВЕРИФИКАЦИЯ  ПАРАЛЛЕЛЬНЫХ АВТОМАТНЫХ ПРОГРАММ  

Рассмотрен комплексный подход к разработке и верификации параллельных автоматных программ,  в которых иерархические автоматы могут реализовываться в разных потоках и взаимодействовать друг с другом.  Предложен интерактивный подход к верификации параллельных автоматных программ при помощи инструментального средства Spin, который включает в себя автоматическое построение модели на языке Promela, приведение LTL-формулы в формат, определяемый инструментальным средством Spin, и построение контрпримера  в терминах автоматов.  Ключевые слова  — автоматы, параллельные автоматные программы, верификация, проверка моделей, линейная темпоральная логика, Spin. 

Предлагаемый подход предназначен для построения параллельных систем взаимодействующих иерархических конечных автоматов 36 38. При этом каждый такой автомат работает в отдельном потоке. Под иерархическим автоматом понимается система вложенных автоматов. В данной работе каждый граф переходов задает не конкретный автомат, а тип автоматов по аналогии с типом данных или классом в объектно-ориентированном программировании . Назовем его . У каждого автоматного типа может быть несколько экземпляров по аналогии с объектом в объект но-ориентированном программировании. Назовем эти объекты . Каждый автоматный объект имеет уникальное имя. В дальнейшем, если не указано иное, автоматные объекты будут называться просто автоматами. Переходы автоматов осуществляются по событиям. Также на переходе могут быть охранные условия 39. А что делать, если встретилось событие, по которому нет перехода Традиционно в теории языков и вычислений детерминированный конечный автомат в таком случае переходит Формальные методы все шире используются для повышения качества программного обеспечения. Эти методы не конкурируют с традиционным тестированием, а дополняют его. В данной работе рассматривается верификация методом проверки моделей model checking 13 при помощи верификатора Spin 4. Метод проверки моделей характеризуется высокой степенью автоматизации 1, особенно для автоматных систем, так как сам метод основан на автоматах. По этой теме проводятся исследования в России и за рубежом 535. В настоящей статье, являющейся продолжением работ 17, 24, 29, предлагается комплексный подход к разработке и верификации параллельных автоматных программ. На основе предложенного подхода было разработано инструментальное средство Stater, которое позволяет создавать параллельную систему взаимодействующих иерархических конечных автоматов, импортировать конечные автоматы из инструментального средства Stateflow, которое входит в состав MatLab, верифицировать созданную систему конечных автоматов при помощи верификатора Spin, генерировать программный код по созданной системе конечных автоматов. в недопускающее состояние. Однако такое поведение не всегда удобно. Альтернативой переходу в недопускающее состояние может быть игнорирование таких событий, которое реализуется как неявное добавление пустых без выходных воздействий петель по всем событиям, переходы по которым не были добавлены пользователем. Таким образом, в предлагаемом методе при появлении события, по которому нет перехода, автомат может работать в одном из двух режимов это событие игнорируется добавляются пустые петли по всем событиям автомат переходит в недопускающее состояние. Вводится специальное событие, которое означает переход по любому событию, кроме тех, которые указаны на других переходах из этого состояния аналог в блоках для C-подобных языков или в условных конструкциях. Автомат может иметь конечное число переменных целочисленных типов включая массивы. Для переменных вводятся следующие модификаторы переменная может применяться в любом месте программы переменная может использоваться другим автоматом переменная является параметром автомата. По умолчанию считается, что переменная не используется нигде, кроме как на диаграмме переходов автомата. Все события общие для всей системы автоматов. Выходные воздействия автомата бывают двух типов 1 на переходах и в состояниях может быть выполнен любой код. Однако верификатор и генератор кода перенесут его без изменений, поэтому код должен быть допустимым в целевом языке 2 запуск на переходах и в состояниях функций, определяемых пользователем на целевом языке программирования после того, как сгенерирован код. Автомат может иметь вложенные автоматы любого типа, кроме собственного, иначе будет бесконечная рекурсия. Циклическая рекурсия также запрещена. Автомат может запускать поток с новым автоматом любого типа. Задается тип автомата и имя . Нельзя запускать несколько автоматов с одним именем. Нельзя запускать автоматы своего типа. Автомат может взаимодействовать с другим автоматом, выступая источником событий для него. События формируются асинхронно. Автомат может использовать переменные другого автомата, отмеченные специальным модификатором. Таким образом, в системе могут быть несколько автоматов с одинаковым графом переходов, более того, часть этих автоматов могут быть вложенными, а часть не обладать этим свойством. Все запреты проверяются при помощи верификации. Для того чтобы провести верификацию программы методом проверки моделей, требуется составить модель программы и формализовать требуемые свойства спецификацию на языке темпоральной логики 1. Поскольку в данной работе используется верификатор Spin, то языком темпоральной логики является LTL 1. Построение модели описано в пункте Генерация кода на языке Promela. Модель строится для автоматной программы, поэтому построение может быть выполнено автоматически. Обозначим автоматный тип через, автоматный объект через . Пусть состояния называются, и т. д., в автомат поступают события, и т. д., а переменные называются, и т. д., внешние воздействия второго типа, и т. д. Пусть автоматный тип имеет вложенный автомат . Пусть запускает автомат . Процесс верификации состоит из следующих этапов. 1. Построение модели генерация кода на языке Promela 4. Для автоматных программ, как отмечено выше, это выполняется автоматически. 2. Преобразование LTL-формул переход от нотации автоматной программы в нотацию Spin. 3. Запуск верификатора Spin. 4. Преобразование контрпримера в термины исходной системы автоматов. Это преобразование автоматных программ также выполняется автоматически. Эти этапы похожи на этапы ручной верификации при помощи Spin. Основным отличием является б льший уровень автоматизации и б льшая приближенность модели к реализации, чем при верификации неавтоматных программ. Ниже описана реализация интерактивности, а затем все четыре этапа верификации. Одна из главных проблем при верификации методом проверки моделей это размер модели Крипке. С целью уменьшить модель отсечь лишние подробности будем строить ее интерактивно. Для обеспечения ин терактивности вводится возможность выбирать, какие уровни абстракции автоматной системы входят в модель, а какие нет. Кроме того, модель структурируется понятным для человека образом для того, чтобы пользователь мог самостоятельно модифицировать построенную модель. Опишем уровни абстракции по разным аспектам верификации по переменным, параллелизму, источникам событий и по самому процессу верификации. Для введем следующие уровни абстракции 1 переменные в модели не учитываются 2 переменные в модель включены, но модель абстрагируется от их значения. Недетерминированно выбирается, какое охранное условие будет верно 3 модель вычисляет значения переменных, при этом переменные могут быть следующих видов a локальные могут быть изменены только самим конечным автоматом все изменения таких переменных находятся только в выходных воздействиях автомата b параметры извне изменяются только один раз при запуске автомата, в остальном они подобны локальным переменным c публичные могут быть изменены в любом месте программы, в которую входит построенная автоматная система. В модели перед каждым переходом автомата таким переменным недетерминированно присваивается произвольное значение d совместно используемые к таким переменным данного автомата имеют доступ другие автоматы, параллельно работающие с этим автоматом. Параметры и публичные переменные могут быть также одновременно и совместно используемыми. Вводятся два уровня либо он есть, либо его нет. Если параллелизм отсутствует, то в модель не вводятся взаимодействия параллельных автоматов. Остаются только взаимодействия по вложенности. В качестве для автоматов в системе могут выступать внешняя среда и другие автоматы. Внешняя среда как источник событий для каждого автомата может работать в одном из трех режимов внешняя среда не взаимодействует с автоматом события от внешней среды не приходят внешняя среда отправляет только те события, которые автомат может в данный момент обработать внешняя среда отправляет любые события. Другие автоматы как источники событий можно отключить, если отключить параллелизм. Интерактивность основывается на возможностях верификатора Spin и описана в пункте Запуск верификатора Spin. Все состояния каждого автоматного типа перенумеровываются, и для них создаются константы. Для каждого автоматного типа состояния нумеруются отдельно. Имя константы состоит из имени автоматного типа и имени состояния, разделенных знаком подчеркивания. Это сделано для того, чтобы состояния разных автоматов с одинаковыми именами не конфликтовали друг с другом. Пример define ATypes0 0 define ATypes1 1 Все события перенумеровываются, и для них создаются константы. Для событий применяется сквозная нумерация. Пример define e0 1 define e1 1 Все внешние воздействия второго типа вызываемые функции перенумеровываются, и для них создаются константы. Процесс аналогичен тому, как это делается с состояниями. Так же аналогично все вызовы вложенных и запуски параллельных автоматов перенумеровываются и для них создаются константы. Каждый тип автоматов записывается в inlineфункцию, которая моделирует один шаг автомата. Переходы записываются при помощи охранных команд Дейкстры 39. Для каждого типа автоматов создается структура со следующими элементами номер текущего состояния номер последнего пришедшего события номер автомата номер последней запущенной функции, если такая существует номер текущего вложенного автомата, если такой существует все переменные автомата. Для каждого экземпляра автомата создается экземпляр структуры и канал, по которому происходит передача событий. Для каждого экземпляра автомата, кроме вложенных, создается процесс, который извлекает из канала событие и запускает встраиваемую inline функцию автомата с этим событием. Для каждого экземпляра автомата, кроме вложенных, создается процесс, который недетерминированно выбирает событие и отправляет его в канал автомата. Для публичных переменных на каждом шаге автомата вызывается специальная функция, которая их недетерминированно изменяет. Для переменных-параметров такая функция вызывается один раз при запуске автомата. Если по данному событию нет перехода и в текущем состоянии есть вложенный автомат, то он запускается запускается встраиваемая функция автомата. Если в текущем состоянии автомат запускает другой автомат, то запускается заранее созданный процесс запускаемого автомата. Если автомат отправляет событие другому автомату, то он записывает номер отправляемого события в канал этого автомата. Расширим нотацию LTL-формул верификатора Spin. В фигурных скобках будем записывать высказывания в терминах рассматриваемой автоматной модели. Добавим следующие высказывания автомат перешел в состояние в автомат пришло событие автомат вызвал функцию внешнее воздействие в автомате управление передано вложенному автомату автомат запустил автомат бинарные логические операции с переменными автоматов, например, . Пример LTL-формулы в расширенной нотации 1 Алгоритм преобразования формулы в нотацию Spin следующий. 1. Все высказывания в фигурных скобках перенумеровываются. 2. Каждое такое высказывание преобразовывается в терминах модели на языке Promela и записывается в макрос. 3. Макросы подставляются в исходную LTLформулу. При использовании этого алгоритма формула 1 преобразуется к виду Верификатор Spin поддерживает несколько LTL-формул в одной модели, поэтому формулы нумеруются, и т. д. Верификация построенной модели при помощи инструментального средства Spin состоит из следующих этапов. 1. Построение верификатора pan. Pan это верификатор для конкретной модели с конкретными темпоральными формулами. По сути, Spin является не верификатором, а генератором верификаторов, каждый из которых работает для конкретного частного случая. При запуске с ключом по модели на языке Promela инструментальное средство Spin генерирует верификатор pan на языке C. 2. Компиляция верификатора pan. При компиляции можно определить константы, которые влияют на то, как в памяти будет храниться модель Крипке 1. Наиболее компактный вариант задается константой, однако в этом случае происходит аппроксимация, и верификация может быть не точна. 3. Запуск верификатора pan. Этот верификатор также может быть запущен с разными ключами, важнейшим из которых является поиск допускающих циклов. 4. Анализ контрпримера и его преобразование описано в пункте Преобразование контрпримера. Интерактивность достигается за счет предоставления пользователю возможности использовать вышеперечисленные варианты работы на этапах верификации. Для того чтобы было удобнее понимать контрпример, опишем метод автоматической трансляции контрпримера, который получается на выходе верификатора Spin, в термины используемой автоматной модели. Для каждого действия автомата создается пометка при помощи функции . На языке Promela функция работает аналогично функции из языка C 40. Во время случайной симуляции 4 она выводит текст на экран, а во время верификации этот текст появляется в контрпримере. Остается его считать и вывести пользователю. Подробнее преобразование контрпримера описано в работе 29. Подход предполагает использование объектно-ориентированных языков, но может быть расширен и для других языков программирования. Однако это выходит за рамки данной работы. В отличие от таких инструментов как Unimod 41 и Stateflow 42, в данном подходе предлагается генерировать не самостоятельную программу, а подпрограмму. Для объектно-ориентированных языков это набор классов, который пользователь может включить в свою программу. Для того чтобы обеспечить удобство использования сгенерированного кода, делаются следующие шаги ограниченный объем статьи не позволяет подробно описать алгоритмы первичной и повторной генерации кода, отметим лишь, что они используют конечные автоматы и были разработаны при помощи самого инструментального средства Stater. 1. Для каждого автоматного типа генерируется отдельный класс в отдельном файле. Такой класс называется автоматизированным классом 38. 2. Сгенерированный класс содержит функцию переходов для автомата перечисление, содержащее события необходимые переменные для переходов и определения функций выходных воздействий второго типа, в которые пользователь может дописать собственный код, и этот код не исчезнет при повторной генерации кода. 3. В коде специальными комментариями помечаются фрагменты программы, которые полностью переписываются и в которые не следует писать пользовательский код. Такой код из остальных мест будет полностью сохранен. 4. Если пользователь добавит новые выходные воздействия второго типа, то их определения будут добавлены к сгенерированному коду. 5. Пользователь может задать пространство имен или пакет в языке Java, в котором будет находиться сгенерированный код. Если между генерациями кода пространство имен было удалено, то оно будет восстановлено. 6. Если пользователь добавит к автоматизированному классу наследование от базового класса или интерфейса, то повторная генерация кода сохранит это наследование. 7. Генерируются вспомогательные классы, включая менеджер потоков, которые обеспечивают взаимодействие автоматов, находящихся в разных потоках. Если многопоточность не требуется, их генерацию можно отключить. 8. Пользователь может ввести произвольное число автоматных объектов, которые будут запущены при запуске менеджера потоков. При совместной разработке программы несколькими разработчиками существует проблема объединения программного кода, когда один файл редактируется несколькими разработчиками одновременно. Для обычных программ эта проблема решается при помощи систем контроля версий SVN 43, Git 44, Mercurial 45 и т. д.. Однако системы контроля версий хорошо объединяют только текстовые файлы. Графы переходов конечных автоматов у популярных инструментов плохо приспособлены для совместной разработки. Для того чтобы облегчить объединение графов переходов, в данной работе предлагаются следующие свойства, которыми должен обладать формат хранения таких графов 1 формат должен быть текстовым 2 каждый граф переходов должен быть в отдельном файле или в отдельном множестве файлов 3 структура графа переходов и информация, которая требуется для отображения, хранятся в разных файлах. Первое свойство связано с тем, что, как отмечалось выше, современные системы контроля версий умеют объединять версии только текстовых файлов. Типичный пример совместной разработки два программиста одновременно модифицируют файл. Первый программист отправил файл в репозиторий, а второй программист обновляет файл из репозитория, и получается конфликт версии, хранящейся в репозитории, и рабочей версии. Существующие системы контроля версий во многих случаях автоматически разрешают подобные конфликты, корректно объединяя две версии файла, а когда не могут их разрешить, предоставляют инструменты, которые помогают пользователю в нашем примере второй программист разрешить такие конфликты. Однако это верно только для текстовых файлов. Разрешать конфликты версий в двоичных файлах разработчики должны самостоятельно. Второе свойство позволяет избежать конфликта версий, когда в автоматной программе модифицируются разные графы переходов. Кроме того, оно позволяет использовать графы переходов повторно. Третье свойство происходит из того, что изменения графов переходов делятся на два типа структурные и геометрические. Геометрические изменения затрагивают только внешний вид графов переходов и не влияют на автоматную программу. Таким образом, третье свойство облегчает разрешение конфликтов в структурной части графов переходов. На основе предложенных свойств и был разработан формат хранения этих графов. Для поддержки предложенного подхода было разработано инструментальное средство Stater. Оно позволяет создавать параллельную систему конечных иерархических автоматов импортировать конечные автоматы из инструментального средства Stateflow верифицировать созданную систему конечных автоматов при помощи верификатора Spin генерировать программный код по созданной системе конечных автоматов. Инструментальное средство Stater использовалось при разработке самого себя, а именно модулей загрузки графов переходов из файлов и преобразования LTL-формул, а также модуля генерации кода. Ни предложенный подход, ни разработанное на его основе инструментальное средство Stater не претендуют на полноту верификации систем, разработанных с помощью Stateflow. Это связано с тем, что спецификация к Stateflow имеет более 1300 страниц 46. Продемонстрируем предложенный подход на примере прототипа программы управления гусеничным шасси для робота. В шасси два двигателя по одному на левую и правую гусеницы. Прототип программы состоит из двух автоматных типов и . Два автомата и типа рис. 1 управляют соответственно левым и правым двигателями. Автомат типа рис. 2 отправляет команды на управление двигателями в зависимости от команд для шасси. При входе в состояния он отправляет следующие события автоматам слева от стрелки написано имя автомата, справа событие Проверим свойство В любой момент если поступила команда стоп, то будет подана команда остановки левого двигателя. Отметим, что нет возможности проверить, что двигатель остановился, так как это утверждение относится к аппаратной части. Формализуем указанное свойство. Высказывание Поступила команда стоп означает, что в автомат пришло событие . В нотации инструментального средства Stater оно записывается следующим образом . Высказывание Подана команда остановки левого двигателя означает, что автомат вызвал функцию . В нотации средства Stater оно записывается следующим образом . Поэтому рассматриваемое свойство переписывается следующим образом в любой момент времени в автомат пришло событие, следовательно, в будущем автомат вызовет функцию 2 Данное свойство не должно выполняться в следующих состояниях, и . В первых двух шасси еще не готово к работе, а в состоянии двигатель и так остановлен. В итоге получаем следующую формулу 3 Выполняем верификацию и получаем ответ, который означает, что верифицируемое свойство выполняется в построенной системе Таким образом, описан комплексный подход к разработке и верификации параллельной системы иерархических конечных автоматов. На основе этого подхода разработано инструментальное средство Stater. Его работа была продемонстрирована на примере прототипа управления гусеничным шасси. 