РОЛЬ СТОХАСТИЧЕСКОГО ТЕСТИРОВАНИЯ В ФУНКЦИОНАЛЬНОЙ ВЕРИФИКАЦИИ МИКРОПРОЦЕССОРОВ 

С ростом требований к характеристикам современных ИС, в том числе микропроцессоров и систем на кристалле, существенно усложняется их проектирование. Оно превратилось в многоступенчатый процесс, на каждой стадии которого от разработчиков требуется решение все более и более сложных задач. Одной из самых трудоемких из них является функциональная верификация проекта. Задача заключается в установлении соответствия между некоторым уровнем реализации проекта и функциональными требованиями его спецификации. Для проектов ИС современного уровня сложности отсутствует универсальный способ функциональной верификации, однако существует несколько взаимодополняющих подходов к проблеме. Одним из методов, применяемых в НИИСИ РАН при разработке микропроцессоров архитектуры MIPS64, является стохастическое тестирование. В его основе лежит симуляция выполнения тестовых программ на модели микропроцессора. Тесты (тестовые программы) генерируются автоматически по заданному шаблону с параметризованным случайным выбором инструкций тела теста и их аргументов. В данной статье уделяется внимание роли метода стохастического тестирования, области его применения, преимуществам и недостаткам. Функциональная верификация рассматривается как составная часть процесса проектирования ИС. Описываются наиболее известные в мировой практике подходы к верификации и коротко рассматриваются лежащие в их основе идеи. Дается информация о классе методов, основанных на симуляции, и методе стохастического тестирования. Делаются выводы о преимуществах и недостатках данного метода, иллюстрируемые некоторыми результатами его применения в НИИСИ.

 Разработка современных микропроцессоров МП и систем на кристалле СиК представляет собой сложный многоступенчатый процесс, в котором заняты большие коллективы. Стадии данного процесса это переходы между уровнями представления проекта в сторону понижения уровня абстракции. Так, в соответствии с техническим заданием уточняется спецификация архитектуры, обычно в виде текстового документа с описанием. Согласно спецификации разрабатывается модель уровня регистровых передач . Изготовленная в кремнии ИС с этой точки зрения представляет собой окончательный уровень представления проекта. Каждый переход между уровнями представления может быть выполнен с ошибками и требует верификации, то есть установления соответствия этих представлений друг другу. Например, под функциональной верификацией RTL-модели устройства понимается проверка предположения, что она вполне удовлетворяет функциональным требованиям спецификации архитектуры. В хорошо поставленном процессе разработки на функциональную верификацию направляется до 70 от общих усилий 1. Это обусловлено следующим. Во-первых, написание RTL-модели наименее формализованный и автоматизированный шаг разработки, а значит, порождающий максимальное число ошибок. Во-вторых, исправление ошибок на этом шаге наиболее эффективно с точки зрения финансовых и трудовых затрат. Рассмотрим функциональную верификацию RTL-моделей МП и СнК . Для общей картины добавим лишь, что в верификации следующих за RTL-моделью уровней представления проекта применяется известный набор технологий, в основном специфичных для того или иного шага разработки например, equivalence checking, LVS, DRC, scan-based testing. Эта статья посвящена реализации одного из популярных методов верификации RTL-моделей МП метода стохастического тестирования 2, 3. Обзор некоторых методов верификации Задачу функциональной верификации можно сформулировать так. Таким образом, полная верификация сталкивается с двумя практически непреодолимыми препятствиями. Во-первых, исходно необходима полностью формальная или легко поддающаяся формализации спецификация устройства. Это условие крайне редко выполняется в практике разработки МП и СнК. Во-вторых, строгое решение задачи подвержено эффекту комбинаторного взрыва для верификации современных проектов МП и СнК потребуются столетия на вычисления Тем не менее существуют и развиваются множество методов, которые позволяют эффективно решать задачу верификации в ее практической постановке дать разработчику уверенность в отсутствии логических ошибок в работе опытного образца . Опишем коротко наиболее известные из них. Средства статического анализа кода выявляют в синтаксически корректном коде RTL-модели подозрительные фрагменты и конструкции, тем самым быстро находя ошибки, связанные с невнимательностью, плохим стилем и т.п. Очевидно, нельзя считать эти средства достаточными для верификации, но как необходимый инструмент первичной проверки модели они давно себя зарекомендовали. Метод проверки эквивалентности моделей рассматривает две формальные модели уровня RTL или gate-level netlist и устанавливает или опровергает одинаковость их поведения. Хотя метод чаще применяется на стадии синтеза проекта, он подходит также для проверки функциональной эквивалентности двух RTL-моделей. Например, можно проверить внесенные в код правки, которые не должны влиять на функциональность. Метод формальной проверки свойств модели близок к предыдущему и заключается в том, что спецификация проекта переводится на формальный язык утвержденийсвойств . В частности, задаются ограничения на наборы значений входных параметров модели. Затем с использованием эвристических решателей для каждого свойства делается попытка подтвердить его для всех наборов входов или опровергнуть. На практике метод находит применение для создания небольших проектов или отдельных блоков сложного проекта, причем таких, спецификация которых легко и надежно переводится на формальный язык. Метод автоматизированного или интерактивного доказательства теорем в принципе схож с методом проверки свойств, но в его реализации используется другой математический аппарат логика предикатов. Вышеописанные методы в совокупности принято называть формальными методами верификации. Их хватило бы для исчерпывающего решения задачи верификации, так как достаточность включена в постановку задачи метода. Но мировая практика в отрасли подтверждает наличие препятствий, а именно трудности формализации и вычислительной сложности. Рассмотрим класс методов, который без преувеличения можно считать основным и важнейшим для широкого индустриального применения. Это методы, основанные на симуляции . Их основная идея следует из названия работа устройства, которое представлено RTL-моделью, симулируется специальной программой RTL-симулятором. К данному классу относится и метод стохастического тестирования, реализованный в НИИСИ РАН в системах INTEG 2 и INTEG2 3. Наконец, в последние годы развиваются гибридные техники, в которых симуляция комбинируется с формальными методами для использования преимуществ обоих подходов 5. Различия методов, основанных на симуляции Существуют разнообразные методы, основанные на симуляции, которые при сохранении общей сути значительно отличаются в реализации. Эти различия определяют область применения того или иного метода и возникают при уточнении ряда принципиальных параметров, таких как объект верификации, уровень абстракции модели, устройство тестовых воздействий, выбор тестовых воздействий, набор снимаемых с модели откликов, критерий корректности откликов, критерий полноты верификации. Рассмотрим подробнее эти вопросы и некоторые известные варианты их решения. Выбор объекта верификации. Выбор эффективного метода существенно зависит от того, какое устройство необходимо верифицировать. Это могут быть отдельный блок в составе сложного устройства, функционально выделенный интерфейс, ядро микропроцессора в целом или даже вся система на кристалле. Выбор уровня абстракции модели. RTL-модель Стимул Отклик Тестовое окружение Устройство тестовых воздействий. В зависимости от выбранного объекта верификации состав и детализация стимулов будут различными. Для простых блоков без внутреннего состояния стимулами будут простые комбинации входных сигналов. Для устройств с более сложной работой, например межшинных мостов, стимулы могут быть устроены сложнее, состоять из разнесенных во времени последовательностей сигналов и учитывать внутреннее состояние устройства. При верификации целого микропроцессора пространство внутренних состояний и входных воздействий настолько велико, что практически недостижимо все детализировать в составе одного стимула. Чаще в том числе в INTEG и INTEG2 применяется другой подход в качестве тестового воздействия рассматривается последовательность команд архитектуры процессора, то есть тестовая программа. Предполагается, что любую значимую для реальной работы комбинацию входных воздействий и внутренних состояний можно получить при выполнении конечной последовательности команд процессора. Принцип выбора тестовых воздействий. Если мощность множества стимулов и вычислительная стоимость обработки каждого стимула достаточно малы, применяется полный перебор. В других случаях необходимо определить, какие стимулы выбрать и в каком порядке подавать их на модель. В методах, применяющих ручную работу, может предполагаться задание отдельных интересных стимулов вручную. Другие варианты выделение классов стимулов и перебор классов, а также параметризованный случайный выбор. Выбор значимых параметров и откликов модели. Аналогично устройству стимулов детальность отслеживаемых реакций зависит от сложности объекта верификации. Для небольших моделей может использоваться принцип черного ящика, согласно которому значимыми являются только идущие наружу блока сигналы. Для такого сложного устройства, как процессор в целом, целесообразно отслеживать детали состояния модели и внутренние взаимодействия составляющих ее блоков. Выбор критерия и способа контроля корректности полученных откликов. Наиболее прямым способом является непосредственная проверка корректности реакции на тот или иной стимул. Но очевидно, что из-за трудоемкости этот вариант неприемлем при сколько-нибудь масштабной автоматизированной подаче стимулов. Другой способ дополнение кода модели особыми утверждениями на специальном языке. Сигналом об ошибочной работе модели считается невыполнение в какой-то момент того или иного утверждения. Наконец, распространенный метод использование второй модели обычно более высокого уровня абстракции. Такая модель называется поведенческой и создается отдельно по архитектурной спецификации проекта на языках общего назначения или языках системного проектирования . Выбор критерия полноты метода. В случае, когда множество возможных стимулов перебирается заведомо не полностью, а время и ресурсы на функциональную верификацию недостаточны, необходимо ввести другой критерий завершенности процесса. В этой роли выступают метрики верификации 7. Метрики имеют различную природу. При отсутствии других критериев, а чаще в совокупности с ними, используются метрики, основанные на статистике выявленных ошибок. При снижении частоты появления новых ошибок до определенного значения верификация завершается. Другая часто используемая метрика, взятая из арсенала верификации ПО, метрика структурного покрытия кода . Суть ее в том, что при отработке на модели того или иного тестового воздействия специальный инструмент собирает информацию о том, какие фрагменты кода модели были задействованы. Фрагментами кода считаются блоки операторов, пути выполнения условных операторов, достижения выражениями определенных значений и другие. Значение метрики отношение числа задействованных набором тестов фрагментов к общему числу фрагментов. Заметим, что эта метрика задает, скорее, необходимый признак успешной верификации. Достаточным он не является, так как метрика не привязана к функциональным требованиям проекта и не будет ничего знать об упущенной в коде функциональности. В качестве дополнительного критерия полноты выступают метрики функционального покрытия. Идея состоит во внешнем построении пространства тестовых ситуаций, то есть функционально значимых комбинаций входных воздействий и состояний модели. Отличие такого пространства ситуаций от пространства значимых стимулов заключается именно в его явном внешнем задании, хотя в некоторых случаях они могут совпадать. Конкретные способы задания такого пространства различаются по уровню абстракции, на котором описываются тестовые ситуации. В распространенной методологии UVMOVM функциональное покрытие задается на основе конструкций, дополняющих модель целевого блока 8. Можно предложить и другой способ построение пространства тестовых ситуаций в терминах поведенческой модели, то есть на уровне комбинаций поданных на исполнение инструкций. Метод стохастического тестирования Стохастическое тестирование 3 применяется для функциональной верификации микропроцессоров. В основе метода лежит симуляция выполнения тестовых программ на RTL-модели МП. Тесты генерируются автоматически по заданному шаблону с параметризованным случайным выбором инструкций тела теста и их аргументов. На вход тестируемой модели тесты подаются в виде образа памяти, содержащего последовательность подлежащих выполнению инструкций, а также блоки необходимых данных. Для контроля корректности выполнения теста используется поведенческая модель процессора, написанная на языке C. Прохождение теста симулируется на обеих моделях, а затем сравниваются полученные отклики в виде лог-файлов выполненных инструкций, записей в регистровые файлы, обращений в кэш-память и ОЗУ. Возникновение расхождений в работе моделей означает наличие ошибки. Найденные уникальные ошибки образуют базу регрессионного тестирования. Для контроля полноты используется сочетание нескольких метрик. Во-первых, ведется статистика нахождения новых ошибок. Во-вторых, при прохождении баз регрессии снимается структурное покрытие кода RTL-модели. В-третьих, разработано несколько инструментов анализа лог-файлов на наличие отдельных тестовых ситуаций. Хотя их использование не дает полноценной метрики, оно является первым шагом в сторону разработки собственной системы задания и анализа функционального тестового покрытия. Можно указать следующие преимущества метода стохастического тестирования. Во-первых, задание тестовых воздействий на модель в виде исполняемых программ позволяет приближаться к реальным условиям использования устройства. Во-вторых, выбранный способ съема реакций модели дает достаточную информацию о ее внутренней работе для точной локализации большинства найденных ошибок. В-третьих, гибкость описания шаблонов тестов позволяет методу широко охватывать функциональность тестируемого проекта, а простота их написания позволяет работать с методом одновременно большому количеству специалистов. В-четвертых, массированный автоматизированный запуск обеспечивает регулярное нахождение ошибок в новых проектах и достигает редких ошибочных ситуаций в уже отлаженных. Из недостатков и ограничений метода выделим следующие. Значения метрики структурного покрытия показали, что достижение всех состояний некоторых внутренних блоков является трудной задачей, если тестовые воздействия применяются на процессор в целом. Это означает, что детальности задаваемых стимулов не всегда достаточно. Затруднена и обратная связь по выбранным типам метрик. То есть при необходимости достичь того или иного элемента структурного покрытия не всегда получается решить, какой шаблон тестовой программы сможет это сделать. Описанный метод применяется в НИИСИ РАН на протяжении нескольких лет для верификации семейства микропроцессоров архитектуры MIPS64. При этом система тестирования разрабатывается и развивается параллельно с разработкой моделей самих МП. Приведем диаграмму, показывающую количество найденных с помощью описанного метода уникальных ошибок в RTL. Ошибки, возникшие вторично при регрессионном тестировании, а также ошибки, имеющие ту же причину, что ранее найденные, в расчет не брались. В заключение отметим, что метод стохастического тестирования при всех своих преимуществах и широте использования является лишь одним из целого арсенала известных методов функциональной верификации. Основная область его применения масштабное тестирование проекта микропроцессора, отлаженного в первом приближении более простыми тестами. Для более углубленной верификации отдельных блоков и критических мест в функциональности пока более эффективны другие методы, в большей степени опирающиеся на полное тестовое покрытие. Таким образом, описанный метод наиболее успешно работает в связке с дополняющими его. И все-таки планы развития метода предполагают устранение многих его ограничений и слабых мест. 