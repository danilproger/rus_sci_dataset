БИБЛИОТЕКА ДЛЯ ПОИСКА САЙТОВ СВЯЗЫВАНИЯ С ТРАНСКРИПЦИОННЫМИ ФАКТОРАМИ 

Описывается разработанная авторами библиотека для поиска сайтов связывания с транскрипционными факторами (специфических фрагментов на ДНК, куда закрепляются регуляторные белки, называемые транскрипционными факторами). Она состоит из трех алгоритмов поиска: прямого поиска, поиска с использованием перестановок и заглядывания вперед и суффиксных массивов. Библиотека ориентирована на большие объемы информации и позволяет производить поиск на последовательностях геномного масштаба с библиотекой из нескольких тысяч матриц.

 Регуляция генной экспрессии на уровне транскрипции является очень сложным процессом, особенно в многоклеточных эукариотических организмах 1. Каждый тип клетки или ткани на специфической стадии развития или под влиянием внеклеточных сигналов экспрессирует характеристический паттерн активированных транскрипционных факторов . Внутри ядра клетки эти регулирующие транскрипцию белки связываются со специфическими сайтами связывания в регуляторных районах генов, способствуя их активации или репрессии. Компьютерные методы предсказания сайтов связывания с ТФ на ДНК очень важны для понимания молекулярных механизмов генной регуляции. Среди аналогичных программных продуктов можно выделить наиболее известные SIGNAL SCAN 3, TESS 4. Кроме того, в библиотеке, помимо простого поиска, реализованы ускоренные алгоритмы, использующие подход заглядывания вперед и перестановки, а также алгоритм, использующий суффиксные массивы для ускорения поиска. Этот вес является характеристикой того, насколько данная последовательность схожа с последовательностями сайтов, используемыми для конструирования весовой матрицы, поэтому отражает вероятность, с которой данная последовательность может являться сайтом. Поиск потенциальных сайтов в последовательности S сводится к последовательному прикладыванию матрицы к каждой позиции k последовательности S и сравнению вычисленного веса w с заданным наперед порогом c. В весовой матрице выделяется ядро это наиболее консервативный фрагмент матрицы длиной N, зачастую равной 5. По ядру аналогично вычисляется вес ядра wc, который сравнивается с порогом ядра cc. Сайт считается распознанным в позиции k, если выполняются оба условия w c и wc cc. В авторской версии библиотеки реализованы обе возможности поиск с ядром и без ядра. Разработанная библиотека содержит три алгоритма поиска сайтов, а также функциональность для чтения исходных данных . Опишем эти алгоритмы. Алгоритм 1. Наивный поиск. Входная последовательность подается фрагментами, так как ее длина неизвестна и может быть очень большой. Если заданный фрагмент не является первым, поиск осуществляется с конца предыдущего фрагмента. Для этого после окончания поиска сохраняется конец последовательности длиной, равной максимальной длине матрицы. Поиск сайтов производится прямым вычислением веса на каждом фрагменте последовательности в режиме скользящего окна по формулам, приведенным выше. Если вес сайта выше порога, этот соответствующий объект заносится в массив распознанных сайтов. Алгоритм 2. Заглядывание вперед и пермутации. То есть индекс J указывает на сортировку столбцов матрицы M по убыванию максимального элемента столбца. Таким образом, Sumrest это сумма минимальных весов оставшихся позиций. Если последовательно вычислять частичные суммы весов и если на текущем шаге t W Sum rest C, то в дальнейшем, если даже в последующих позициях будут встречаться только максимальные веса, сумма весов все равно не превысит порога С . Таким образом, можно значительно сократить время поиска сайтов, отбрасывая на шагах вычисления веса сайты, заведомо меньшие порога. Индекс J называется пермутациями, а заглядывание вперед это сравнение суммы с порогом на промежуточных шагах вычисления веса. Рассмотрим пример поиска с заглядыванием вперед и пермутациями. Пусть матрица М следующая Тогда вектор J будет таким На первой позиции стоит индекс 5, так как в 5-м столбце максимальный вес 12, больше чем в остальных столбцах, и т.д. Sumrest будет следующим Sumrest вычисляется с последнего элемента. И так далее складываются максимумы соответствующих столбцов. Далее аналогичным образом вычисляются остальные веса. В позиции 4 суммарный вес оказывается ниже порога, что позволяет прекратить вычисления с ответом, что данная последовательность не является сайтом. Таким образом, используя этот подход, можно добиться значительного ускорения поиска сайтов. Но несмотря на это, скорость поиска все еще остается в линейной зависимости от длины последовательности. Следующий алгоритм позволяет сделать эту скорость логарифмической относительно длины последовательности. Алгоритм 3. Суффиксные массивы. Для этого алгоритма потребуется построить суффиксный массив по входной последовательности S. Суффиксный массив T содержит позиции i входной последовательности S, отсортированные в порядке возрастания суффиксов последовательности S. Последовательность S считается законченной символом 0, меньшим любого другого символа из S. Строки сравниваются в лексикографическом порядке. Наиболее простой алгоритм построения суффиксного массива представляет собой построение суффиксного дерева. Опишем этот алгоритм. Шаг 1. Возьмем первую позицию и поместим ее в корневую вершину дерева Tr. Шаг 2. Выполним этот шаг рекурсивно для поддеревьев. Повторим шаг 2 для всех позиций i. Далее левосторонним обходом дерева получим желаемый массив. Индекс 1 попадает в корневую вершину. Подпоследовательность длины 1 следующего индекса 2 меньше корневой подпоследовательности CT, поэтому поместим индекс 2 влево и т.д. . Далее сведем алгоритм поиска сайтов без ядра к алгоритму поиска с ядром. Длина ядра CL полагается равной 5. Вычислим порог ядра CW как минимальный порог, подходящий для ядра, за вычетом весов остальных нуклеотидов, то есть, если в остальных позициях вес будет максимальным, порог, определенный для ядра, найдем по следующей формуле CW C maxm maxm. Таким образом, поиск без ядра сводится к поиску с ядром. Теперь для каждой матрицы и каждого ядра построим набор допустимых последовательностей, для которых вес ядра больше порога. Алгоритм поиска заключается в последовательном переборе суффиксов. Берутся только те из них, которые входят в набор допустимых последовательностей, и по ним проводится проверка, подходит ли данная матрица по порогу к данной последовательности. За счет этого удается значительно ускорить поиск сайтов, но для последовательности необходимо предварительно построить суффиксный массив. Реализация Библиотека реализована на языке Java и включает в себя следующие классы. com.cogangs.bb.core.pwm TfMatrix класс, реализующий функциональность весовой матрицы. Включает в себя методы получения весов, максимального и минимального веса по позиции, нормировки весов и другие вспомогательные функции. com.cogangs.bb.core.pwm.io LibMatrixReader позволяет читать матрицы из входного файла в соответствующем формате. com.cogangs.bb.core.seq.io SAFileParser читает и записывает суффиксный массив в бинарный файл соответствующего формата. Этот бинарный файл содержит как последовательность, так и суффиксный массив. Позволяет записывать последовательность по секциям. SuffixArrayBuilder строит суффиксный массив по входной последовательности. com.cogangs.bb.core.tfbs NaiveSearcher простой алгоритм поиска сайтов. Соответствует алгоритму наивного поиска. PALAlgorithms вспомогательные функции, общие для алгоритмов заглядывания вперед, пермутаций и суффиксного алгоритма. PALSearcher алгоритм с заглядыванием вперед и пермутациями. SASearcher алгоритм поиска с суффиксными деревьями. TfbsResult структура для хранения результирующих сайтов. В заключение следует отметить, что в данной работе были предложены три алгоритма для поиска потенциальных сайтов связывания с транскрипционными факторами с помощью весовых матриц. Алгоритмы ориентированы на большие объемы данных последовательностей и матриц. 