АДАПТИВНОЕ  АРИФМЕТИЧЕСКОЕ  КОДИРОВАНИЕ В  СТАНДАРТЕ  JPEG 2000 

Представлен обзор контекстного моделирования, используемого в стандарте JPEG 2000. Описан способ модификации механизма адаптивной оценки вероятности появления символа, позволяющий учесть статистические особенности двоичных источников, соответствующих различным контекстным моделям, и тем самым повысить эффективность алгоритма. This is a review of context modelling used in the JPEG 2000 standard. We show how to modify the adaptive estimation mechanism of the probability of symbol appearance, taking into account the statistical peculiarities of binary sources corresponding to different context models and thus improving the algorithm. 

В последнее время стандарт JPEG 2000 13 все более распространяется в качестве основного формата сжатия как изображений, так и видеопоследовательностей. Схема кодирования, используемая в стандарте JPEG 2000, кратко может быть описана следующим образом. Исходное изображение разбивается на прямоугольные сегменты tile, которые кодируются независимо. После преобразования цветового пространства каждый сегмент изображения подвергается процедуре многоуровневого дискретного вейвлетного преобразования discrete wavelet transform. Для этого используются низкочастотный и высокочастотный вейвлетные фильтры. При разложении сигнала сегмента изображения вначале выполняется разложение по строкам, а затем по столбцам. Результатом разложения являются 4 матрицы HH, HL, LH, LL, соответствующие фильтрации фильтром по строкам и по столбцам, фильтром по строкам и по столбцам, фильтром по строкам и по столбцам, фильтром по строкам и столбцам. Далее производится децимация прореживание полученных матриц по строкам и столбцам с коэффициентом 2. Затем матрица LL подвергается дальнейшему вейвлетному разложению 4. Его результатом являются матрицы HH, HL, LH, LL рис. 1. Такое разложение повторяется раз. Результатом разложения является набор из 3 1 матриц уменьшающейся размерности. Каждая из матриц разложения делится на блоки, которые кодируются независимо друг от друга при помощи контекстного адаптивного двоичного арифметического кодера. Коэффициенты матриц вейвлетного разложения представляются в двоичном виде. Все биты коэффициентов, относящихся к одному разряду, образуют битовую плоскость. Нумерация битовых плоскостей начинается с самого старшего разряда. Самая старшая битовая плоскость, в которой есть хотя бы один ненулевой коэффициент, является наиболее значимой. Кодирование коэффициентов матриц разложения происходит на уровне битовых плоскостей при этом каждая битовая плоскость кодируется с помощью арифметического кодера за три прохода первый называется significance propagation, второй magnitude refinement и третий clean-up. Кодирование плоскостей начинается с наиболее значимой битовой плоскости, для которой применяется только третий проход clean-up, для всех остальных битовых плоскостей применяются все три прохода. Битовые плоскости сканируются в порядке, показанном на рис. 2. Каждому коэффициенту в блоке на этапе кодирования соответствует степень значимости significance state. Степень значимости может принимать два значения 1, т. е. коэффициент считается значимым, и 0, что говорит о том, что коэффициент незначимый. Первоначально все коэффициенты считаются незначимыми. После кодирования первого значимого бита т. е. единицы коэффициент становится значимым. Каждому коэффициенту сопоставляется 8-разрядный контекстный вектор, состоящий из степеней значимости восьми соседних коэффициентов рис. 3. По сумме компонент вектора определяется номер контекста. . Данный проход включает в себя кодирование бит незначимых коэффициентов, которые имеют ненулевой контекст табл. 1. Если на данном проходе кодируется единичный бит, то степень значимости коэффициента, к которому этот бит относится, становится равной 1, после чего кодируется знак коэффициента. Номер контекста при кодировании знака зависит от знака и значимости соседних коэффициентов по вертикали, и по горизонтали, табл. 2, 3. Для указания зависимостей введем следующую функцию от двух аргументов, . Каждый аргумент представляет собой вектор где После вычисления контекста кодируемый знак представляется как сумма по модулю 2 между действительным значением и предсказанным. На данном проходе кодируются биты значимых коэффициентов. Номер контекста вычисляется по всем соседним коэффициентам. При этом делается различие между битом, стоящим сразу после первого значимого бита, и оставшимися битами этого коэффициента табл. 4. . На этом проходе кодируется наиболее значимая битовая плоскость, а также биты незначимых коэффициентов, для которых значение контекста во время первого прохода было равно 0. На этом проходе используются контексты первого прохода табл. 1, а также еще два специальных контекста. Если в столбце см. рис. 1 четыре идущих подряд коэффициента кодируются на этом проходе и значения контекстов для них равны 0, тогда используется специальный контекст Run-length. Если все коэффициенты остаются незначимыми все 4 бита в столбце в текущей битовой плоскости равны 0, то вместе с контекстом Run-length на арифметический кодер подается 0. Если хотя бы один из коэффициентов становится значимым на этом проходе значение бита на текущей битовой плоскости равно 1, то на арифметический кодер подается 1, а далее кодируются еще 2 бита, которые сообщают о местоположении первой единицы в колонке. Так как вероятности этих двух бит равномерно распределены, то для их кодирования используется еще один специальный контекст Uniform. После того как позиция первого ненулевого бита определена, оставшиеся значения в колонке кодируются так же, как на первом проходе с использованием тех же 9 контекстов. В стандарте JPEG 2000 используется 19 контекстных моделей. Для кодирования двоичных источников, соответствующих этим контекстным моделям, используется MQ-coder 1, в котором оценка вероятности появления символа на выходе источника вычисляется при помощи конечного автомата, заданного в виде таблицы состояний и переходов. Входные символы делятся на наиболее вероятные символы Most Probable Symbol MPS и наименее вероятные символы Least Probable Symbol LPS. Каждое состояние автомата соответствует оценке вероятности наименее вероятного символа. В зависимости от значения входного символа MPS или LPS происходит переход из одного состояния автомата в другое. Подобная реализация не требует операций умноженияделения как при вычислении оценок вероятности, так и при непосредственно арифметическом кодировании. Конечный автомат, используемый в MQ-coder, показан на рис. 4. Здесь фактически реализованы три схемы адаптивной оценки, отличающиеся скоростью адаптации. Перед кодированием блока каждой контекстной модели сопоставляется начальное состояние автомата. Такая процедура называется . В табл. 5 приведены инициализационные значения состояний автомата для контекстных моделей, используемых в стандарте. Из таблицы следует, что большинство контекстных моделей инициализируются состоянием 0. Это означает, что после инициализации оценка вероятности, соответствующая этим контекстным моделям, принимает значение, близкое к 0,5, и в начальные моменты времени используется схема с высокой скоростью адаптации. После кодирования некоторого количества двоичных символов происходит переход к схеме с более низкой скоростью адаптации, но с более высокой точностью оценки вероятности. Описанная выше схема адаптивной оценки вероятности появления символа обладает высокой степенью эффективности, так как обеспечивает быструю адаптацию в начальные моменты времени и более точную оценку вероятности в последующие моменты. Однако эта схема не учитывает того, что статистические свойства двоичных источников, соответствующих различным контекстным моделям, могут существенно отличаться. Ниже описан подход, позволяющий частично учесть эти статистические отличия. В работах 5, 6 предложен алгоритм адаптивной оценки вероятности появления символа на выходе двоичного источника при помощи виртуального скользящего окна. Оценка вероятности появления единицы для алгоритма виртуального скользящего окна определяется как где длина виртуального скользящего окна состояние конечного автомата, вычисляемое следующим образом при 1 при 0. Таким образом, каждой контекстной модели можно сопоставить значение параметра, наилучшим образом учитывающего статистические особенности источника. Кроме того, применение алгоритма виртуального скользящего окна позволяет отказаться от использования таблицы состояний и переходов. При выборе 2, где положительное целое число, вместо операции деления можно использовать операцию побитового сдвига. Алгоритмы сжатия видеоинформации сравниваются по двум основным параметрам визуальному качеству декодированной видеопоследовательности и битовой скорости число бит на выходе кодера в единицу времени. Для получения практических результатов алгоритм оценки вероятности, используемый в кодере и декодере JPEG 2000, был заменен алгоритмом виртуального скользящего окна. Для этого использовалась открытая реализация стандарта JASPER, версии 1.701.0. Результаты были получены для первого кадра известных тестовых HDTV-видеопоследовательностей riverbed, rushhour, station, sunflower, tractor разрешением 1920 1080. Перед запуском кодерадекодера каждой контекстной модели сопоставлялась оптимальная длина окна, которая выбиралась следующим образом. В процессе кодирования тестовой видеопоследовательности в данном случае использовалась последовательность tractor для каждого двоичного символа сномером источника, соответствующего контекстной модели с номером, и для каждой длины окна 2 вычислялись оценки вероятности кодируемого символа По завершении кодирования вычислялись оценки битовых затрат Для контекстной модели с номером параметр кодирования устанавливался В представленных ниже таблицах приведено уменьшение битовой скорости в процентах относительно оригинальной версии кодера при сжатии без потери качества, в зависимости от размера сегмента, для которого выполняется вейвлет-преобразование. Табл. 6, 7 относятся к случаю инициализации контекстов перед кодированием каждого блока и каждого сегмента соответственно. Как видно из табл. 6, 7, сопоставление каждому двоичному источнику параметра кодирования, учитывающего его статистические особенности, приводит к увеличению степени сжатия. При этом если инициализация контекстов выполняется значительно реже табл. 7, то эффективность использования предложенной схемы адаптации повышается. Однако такой способ инициализации возможен только для случая сжатия без потери качества. В отличие от схемы адаптации, входящей в MQcoder, алгоритм виртуального скользящего окна может быть реализован без использования таблицы состояния и переходов. При этом он является более предпочтительным с точки зрения эффективности кодирования. 