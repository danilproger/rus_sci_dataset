ВЕРИФИКАЦИЯ ЗАДЕРЖКИ В МИКРОАРХИТЕКТУРНЫХ  МОДЕЛЯХ КОММУНИКАЦИОННЫХ ФАБРИК 

Изложены основы метода анализа задержек в микроархитектурных моделях коммуникационных фабрик. На  простых примерах показано, как получить верхнюю оценку задержки и верифицировать ее с помощью ранжирующих функций. Для моделей со структурными циклами предложен метод анализа, основанный на раздельном  рассмотрении достижимых состояний системы. Ключевые слова  — качество обслуживания, формальная верификация, xMAS, система-на-кристалле, коммуникационная фабрика, ранжирующая функция, задержка передачи данных.  

Современные системы-на-кристалле требуют эффективной организации обмена данными. Подсистему, отвечающую за пересылку сообщений и пакетов данных между устройствами, называют communication fabric 1. Коммуникационные фабрики обычно обладают сложной распределенной архитектурой с высоким уровнем параллелизма и конвейеризации для одновременной обработки множества транзакций, находящихся на разных стадиях исполнения. В условиях ограниченных аппаратных ресурсов размеры очередей, разрядности шин и т. д. производительность работы системы связана с эффективностью их разделения конкурирующими процессами. Качество архитектуры коммуникационных фабрик напрямую зависит от умения оценивать на этапе проектирования минимальный уровень обслуживания, который система гарантирует своим агентам. В данной статье рассматривается latency интервал времени между отправлением данных источником и их доставкой в точку назначения. Имитационное моделирование дает возможность составить хорошее представление о средней производительности системы. Однако поведение системы в наихудшем случае может сильно отличаться от среднего. Надежную оценку производительности можно получить с помощью формальной верификации. Для этого сначала необходимо построить формальную модель системы. Язык xMAS 2 позволяет создавать наглядные модели коммуникационных фабрик путем композиции примитивов стандартных блоков и может использоваться для моделирования микроахитектурных задержек. Ограничение задержки пакет попадает из точки в точку не более чем за тактов легко сформулировать в виде утверждения линейной темпоральной логики Linear Temporal Logic LTL 3. Однако его проверка часто оказывается за пределами возможностей современных алгоритмов верификации моделей интерполяции 4, -шаговой индукции 5, PDR 6, так как требует рассмотрения порядка последовательных тактов работы системы. Предлагается альтернативный подход, основанный на методах статического анализа и ранжирующих функций. Начав с простой формализации понятия задержки в рамках LTL, мы покажем, как воспользоваться элементарными свойствами задержки для анализа времени выполнения многошаговых транзакций. Построение оценки на задержку представлено как вывод из гипотез в формальной теории и сопровождается параллельным построением ранжирующей функции. Ранжирующая функция это неотрицательная целочисленная функция состояния 7, оценивающая число тактов, оставшееся до завершения транзакции. Для доказательства оценки задержки в тактов достаточно найти соответствующую ранжирующую функцию и показать, что 1 убывает на каждом такте 2 глобальный максимум не превосходит . Доказательство утверждений 1 и 2 проводится методом -шаговой индукции при небольших значениях, не зависящих от . С этой задачей легко справляется большинство современных средств верификации моделей. Таким образом, предлагаемый метод одновременно решает задачи отыскания задержки и ее верификации. В статье изложены теоретические основы метода и представлены первые результаты экспериментов на моделях небольшого размера. xMAS это язык формального моделирования микроархитектуры 2. Модели xMAS строятся из небольшого набора стандартных блоков примитивов, соединенных каналами для передачи пакетов с данными. Каждый канал соединяет ровно два примитива, один из которых является инициатором передачи, а другой ее получателем. Все примитивы модели работают синхронно по одному тактовому сигналу. В данной статье используется базовый набор примитивов, дополненный специализированными примитивами для моделирования качества обслуживания рис. 1. source порождает пакеты с заданным значением . В зависимости от типа истока очередной пакет может появляться на каждом такте eager, с недетерминированной задержкой nondet или не появляться никогда dead. В процессе обработки пакеты хранятся в queue конечного размера. Очередь реализует дисциплину FIFO. Новый пакет может быть помещен в очередь только при наличии в ней свободного места. Задержка прохождения пакета через пустую очередь равна одному такту. Примитив func изменяет значение пакета, используя функцию . Пакет на выходе join появляется только при наличии пакета на каждом из его входов, при этом выходной пакет вычисляется функцией от входных пакетов. Проходя через fork, входной пакет преобразуется в два выходных пакета с помощью функций и . Примитив switch вычисляет предикат от входного пакета и в зависимости от его значения перенаправляет пакет на один из двух выходов. При merge входные пакеты передаются на выход без изменений. Если два пакета поступают на входы слияния одновременно, посылается один из них, а второй задерживается. Для выбора между пакетами используется справедливый алгоритм арбитража. Допускается слияние с произвольным числом входных каналов. sink поглощает пакеты, завершая их обработку в модели. Аналогично истоку, существуют три разновидности стока eager, non-det, dead. На рис. 2 показаны примеры моделей xMAS, использующих как базовые примитивы, так и дополнительные примитивы качества обслуживания см. рис. 1, последние подробно описаны ниже. Протокол передачи данных на канале u использует два логических управляющих сигнала u.irdy от initiator ready и u.trdy от target ready. Сигнал u.irdy равен True, если инициатор готов передать один пакет с данными. Аналогично, сигнал u.trdy равен True, если получатель готов принять один пакет с данными. Передача пакета происходит при u.xfer u.irdyu.trdy True. Значение пакета задается сигналом u.data и может быть любого конечного типа. Все примитивы xMAS обладают простой синхронной семантикой, которая может быть выражена на языке битовых уравнений, связывающих значения сигналов irdy, trdy и data на примыкающих к примитиву каналах. Например, примитив форк с входом i и выходами a, b, параметризованный функциями и, описывается соотношениями Такое определение гарантирует, что передачи на каналах i, a, b происходят одновременно. Протокол xMAS обладает устойчивостью 8, т. е. управляющие сигналы irdy и trdy не могут менять значение с True на False до завершения передачи на канале. Полезно определить устойчивость в более общей форме для двух произвольных событий и Запись читается как устойчиво по отношению к . Мы пользуемся стандартными обозначениями LTL 3 всегда, однажды, в следующий момент времени, в предыдущий момент времени . Устойчивость протокола передачи данных на канале u может быть выражена соотношениями где u используется как сокращение для u.irdy u.data, а квантификация происходит по всем возможным значениям сигнала u.data. Для анализа задержек необходимо расширить базовый набор примитивов xMAS. Для моделирования задержек обработки введем новый примитив delay. Поведение задержки величиной с входом i и выходом o задается уравнениями Используемый в уравнениях оператор next определяет значение регистровой переменной на следующем такте, init в начальный момент времени. Целочисленная переменная cnt принимает значения в 0.. и задает число тактов ожидания до передачи. Случайная задержка с верхней границей моделируется аналогично. Другой тип задержек создается shaper. Формирователь гарантирует, что пакеты на выходе появляются не чаще, чем с заданной частотой, задерживая при необходимости входные пакеты. Пусть для целых положительных чисел и . Тогда поведение примитива можно описать уравнениями Формирователь работает по принципу leaky bucket, увеличивая целочисленную переменную bkt на на каждом такте. Входящий пакет задерживается, если текущее значение bkt меньше, чем . При передаче пакета переменная bkt уменьшается на . Рассмотрим подробнее пример модели на рис. 2, . Пакет со значением порождается истоком и ожидает срабатывания барьера на канале a. На второй вход барьера поступают управляющие пакеты от формирователя с частотой 12. Это гарантирует, что на канале b за два такта работы появляется не более одного нового пакета. Далее пакет проходит слияние, конкурируя с потоком пакетов, и, выиграв арбитраж, попадает в очередь по каналу c. Заметим, что пакеты порождаются недетерминированным истоком, и частота их появления может быть произвольной. Покидая первую очередь по каналу d, пакеты и проходят ветвление и перераспределяются по каналам e и u в различные очереди, на выходе которых пакеты задерживаются. Пакеты покидают модель по каналу h после повторного слияния потоков. Содержательно модель на рис. 2, можно интерпретировать как простейшую коммуникационную фабрику, принимающую запросы от двух агентов и . Пакеты принимаются фабрикой по одному за такт, что моделируется слиянием на входе. Обработка запросов конвейеризирована. На первой ступени запросы обрабатываются последовательно и хранятся в общей очереди. На второй ступени запросы и обрабатываются параллельно с различными задержками например, фабрика может перенаправлять запросы различным устройствам для обработки. Перед удалением из фабрики запросы проходят завершающую фазу по одному за такт, что соответствует слиянию на выходе. Общую задержку обработки запроса коммуникационной фабрикой естественно определить как количество тактов с момента появления пакета на канале a до момента его передачи на канале h. Рассмотрим подробнее пример модели на рис. 2, . Пакет на канале b ожидает срабатывания барьера, которое возможно лишь в том случае, если в очереди находится кредит, порождаемый подсхемой кредитной логики выделена пунктиром. Новый кредит выделяется при срабатывании форка с входом k. При этом одновременно создаются две копии кредита. Одна копия помещается в очередь и оттуда резервируется пакетами, ожидающими на канале b. Другая копия помещается в очередь и используется для учета числа выданных и еще не возвращенных кредитов. Когда очередь заполнена, выделение новых кредитов приостанавливается. Получив кредит, пакет попадает в очередь, при выходе из которой выделенный кредит освобождается число занятых кредитов в очереди уменьшается на 1. В любом достижимом состоянии модели число кредитов в очереди в сумме с числом пакетов в очереди равно общему числу выделенных кредитов, хранящихся в очереди . Корректная реализация схемы с кредитной логикой требует, чтобы число доступных кредитов не превосходило емкости канала, т. е. размер очереди должен быть не больше размера очереди . Неформально задержку можно определить как количество тактов между предусловием и постусловием, где и произвольные события, связанные отношением отклика Иначе говоря, за событием всегда следует событие . Определим локальную задержку, равную числу тактов между текущим моментом времени и следующим появлением события где, а соответствует последовательным применениям темпорального оператора . Если событие никогда не наступает, т. е. выполнено, задержку будем считать равной . С каждым отношением отклика можно связать максимальную задержку за все время выполнения Если событие не наступает ни разу, удобно считать, что 0. Естественно представить задержку обработки запроса в модели на рис. 2, как т. е. как максимальное число тактов между появлением пакета на канале a и передачей пакета на канале h. Однако такое определение не вполне корректно, так как события a и h.xfer h могут быть вызваны разными пакетами, имеющими одно и то же значение . Иными словами, модель на рис. 2, не позволяет выделить один пакет из общего потока и измерить задержку его обработки. Проблема решается простым изменением модели. Допустим, что исток, посылающий пакеты, может присвоить одному из них особую пометку, превратив его в пакет . Помеченный пакет выбирается случайно и обрабатывается моделью так же, как и обычный пакет, сохраняя при этом пометку. Искомая задержка для помеченного пакета может быть корректно выражена как По построению, модель в каждый момент времени содержит не более одного экземпляра, позволяя однозначно идентифицировать пакет. Пометка присваивается случайно, поэтому каждый пакет превращается в в одном из исполнений модели. Следовательно, максимальная задержка запроса по всем исполнениям модели совпадает с максимальной задержкой запроса . Описанный прием добавления пометки применим к произвольной модели xMAS. В дальнейшем нам также потребуется обобщенная форма отношения отклика и связанная с ним задержка Событие следует за, только если в ходе ожидания периодически наступает событие, называемое модулем. Локальная задержка определяется как число наступлений события до ближайшего наступления события . Отличие между обычной задержкой и задержкой по модулю поясняет рис. 3. В момент времени 4, 2 последнее событие не учитывается при подсчете задержки. определяется аналогично, как максимум на всем исполнении. Два типа задержки связаны простым соотношением Задержка для сложного отношения отклика может быть сведена к вычислению более простых задержек. Например, пусть известно, что для некоторых событий, Тогда верно и то, что между появлением события и последующим появлением события проходит не более тактов, т. е. Найденные закономерности можно сформулировать в виде синтаксических правил вывода для задержек . Если формула выводима из гипотез с помощью правил вывода, то . Пользуясь правилами вывода, можно показать, что в модели на рис. 2, На пути от канала a к каналу h пакет проходит положения см. рис. 2, . С каждым положением связан выходной канал соответствующего истока или очереди табл. 1. Полное время обработки пакета определяется временем его пребывания в каждом из положений . Используя правила и, получаем оценку 1 Задержки передачи пакета на канале такие как a.irdy a.trdy будем называть локальными задержками. Вывод локальных задержек схематично показан на рис. 4. В скобках указаны используемые правила распространения задержек для примитивов xMAS. Сами правила выглядят следующим образом. Для задержки величины с входом i и выходом o очереди емкости 2 с входом i и выходом o ветвления с входом i, выходом a и соответствующим условием s формирователя с входом i, выходом o и слияния с входом a и выходом o, задержка арбитража для входа a барьера с входами a, b и выходом o Оценки вычисляются последовательно в процессе обхода модели, начиная с каналов h и x, по направлению к каналу a. Привести вывод целиком не представляется возможным из-за его объема. Рассмотрим в качестве примера вычисление задержки на канале f. Пусть уже известно, что 2 Канал g является выходом примитива задержки с входом f. Воспользуемся оценкой на канале g для получения аналогичной оценки на канале f. Из свойств примитива следует, что 3 т. е. при наличии сигнала f.irdy внутренний счетчик задержки убывает до 0 не более чем за 5 тактов. Принимая неравенства 2 и 3 в качестве гипотез, можно показать, что Полный вывод локальной задержки на канале f в модели коммуникационной фабрики на рис. 4. приведен в табл. 2. В качестве начальных шагов используются уравнения 2 и 3. Предпосылками для дальнейших шагов вывода выступают ранее полученные утверждения, а также свойства примитивов и канального протокола xMAS. Этот пошаговый вывод опирается только на семантику примитива и свойства протокола xMAS и может быть обобщен в виде вспомогательного правила распространения, приведенного выше Правило опирается на истинность гипотезы i.irdy cnt 0 и ряд других свойств примитива и протокола, указанных в качестве предпосылок, используемых в табл. 2. Для удобства договоримся, что при использовании правила распространения все необходимые предположения автоматически добавляются к исходному множеству гипотез . Истинность полученной при этом оценки на задержку будет зависеть от истинности принятых гипотез. Аналогично, каждое правило связано с набором гипотез. Например, правило предполагает истинным неравенство Задержка арбитража равна максимальному числу раундов арбитража до получения входом a наивысшего приоритета. Понятие наивысшего приоритета зависит от выбранного алгоритма арбитража и задается предикатом выбора, удовлетворяющего требованиям т. е. истинность гарантирует передачу на канале a. Предикат и задержка могут быть определены для большинства справедливых алгоритмов арбитража. Например, для кругового алгоритма можно положить, где номер текущего выбранного входа внутренняя переменная алгоритма, а номер входа a равна общему числу входов минус 1. Подставляя оценки для каналов a, d и f см. рис. 4 в формулу 1, получаем 4 Описанный метод анализа применим к широкому классу микроархитектурных моделей. При отсутствии структурных циклов все локальные задержки находятся последовательным обходом с использованием соответствующих правил распространения. Оценка для многошаговой транзакции получается суммированием локальных оценок по всей ее траектории. Для моделей со структурными циклами необходимо учитывать множество достижимых состояний системы. Например, для модели канала с кредитной логикой см. рис. 2, выполнено соотношение 5 Все состояния очередей, удовлетворяющие 5, показаны на рис. 5, и перечислены в табл. 3. Для простоты положим размеры всех очередей равными 2. В состоянии необходимый кредит доступен и передача на канале b может произойти немедленно, т. е. b.irdy b.trdy 0. Переходы между состояниями характеризуются задержками где параметр примитива задержки. Пользуясь правилом и устойчивостью сигнала b.irdy относительно b.trdy, можно показать, что Величина b.irdy b.trdy для произвольного состояния модели может быть получена применением правила с учетом того, что истинно в каждом состоянии модели Мы пользуемся правилами распространения задержек для примитивов xMAS, чтобы построить оценку на задержку обработки пакета. Вывод опирается на ряд предположений о свойствах примитивов и протокола передачи данных. На практике принятые гипотезы могут оказаться ложными например, из-за изменений в семантике примитива, а в ходе вывода могут быть допущены ошибки. Для проверки правильности оценки воспользуемся средствами верификации моделей и методом ранжирующих функций. Для двух произвольных событий и определим интервал от до как Оператор pre возвращает значение своего аргумента на предыдущем такте False в начальный момент времени. Выражение становится истинным при каждом наступлении события и остается таковым до первого наступления события . Целая неотрицательная величина называется ранжирующей функцией для отношения отклика, если, где выражение равно значению величины на следующем такте. Условие означает, что событие уже наступило, а событие еще нет. В этой ситуации требует невозрастания, а строгого убывания при True. Содержательно величину можно считать мерой расстояния от текущего момента времени до наступления события . Заметим, что поведение функции вне интервала, а также в момент наступления события может быть произвольным. . Пусть и . Тогда . Согласно теореме 2, для обоснования оценки на задержку достаточно построить ранжирующую функцию и доказать, что выполнены условия, и . На практике часто удается построить простые ранжирующие функции и проверить их свойства средствами одношаговой индукции. Аналогично задержке, вычисление сложной ранжирующей функции может быть сведено к более простым случаям. Однако при комбинировании ранжирующих функций для разных отношений отклика возникает техническая трудность, связанная с неопределенностью поведения функции, удовлетворяющей условиям и, вне интервала . Пусть, например По аналогии с правилом для задержки, естественно было бы определить ранжирующую функцию для как . Однако поведение функции может быть произвольным на интервале от наступления события до наступления события аналогично для функции на интервале от до . Это не позволяет гарантировать убывания суммы на всем интервале от до . В таких случаях мы будем доопределять значение функций, пользуясь двумя специальными операторами и . Для целочисленной величины, условия и постоянной определим Используя доопределяющие операторы, можно сформулировать правило Аналогично, каждому правилу вывода для задержек можно поставить в соответствие правило для ранжирующих функций. Роль гипотез при выводе выполняют базовые ранжирующие функции, описывающие поведение примитивов. Например, для примитива задержки с входом i, выходом o и параметром справедливо равенство Повторяя вывод, показанный на рис. 4, можно найти f.irdy f.trdy, d.irdy d.trdy и a.irdy a.trdy. Из них по формуле, аналогичной 2, получается ранжирующая функция для полного отношения отклика. Далее с помощью индукции можно установить свойства и и верхнюю границу 50 тактов, тем самым верифицировав оценку 4. Описанный метод анализа задержек тестировался на небольших примерах. В табл. 4 сравниваются оценки на задержку обработки пакета в модели на рис. 3, полученные разными методами. Напомним, что общая задержка от a до h ограничена задержками на каналах f, d и a по формуле 1. Метод ограниченной верификации моделей Bounded Model Checking BMC исследует всевозможные исполнения модели из начального состояния в течение ограниченного числа тактов и позволяет получить нижнюю оценку задержки. -шаговая индукция рассматривает исполнения модели из произвольного состояния возможно, ограниченного дополнительными инвариантами 2 и дает консервативную оценку сверху. Оценки для BMC и -индукции можно считать приблизительно равными. Небольшое расхождение обусловлено возникающей синхронизацией состояний различных примитивов например, внутренних счетчиков задержек и формирователей, текущих значений приоритетов в алгоритмах арбитража и т. д.. Такие эффекты крайне тяжело учесть, не прибегая к полному перебору состояний модели. Более интересны различия между двумя последними столбцами табл. 4. Полная задержка, полученная по правилам вывода, оказывается примерно в 1,5 раза больше оценки другими методами. Расхождение можно сократить, повышая точность правил распространения, но полного совпадения не будет. Оценка в 50 тактов получена по формуле 1, где время пребывания в каждой точке траектории оценивается по наихудшему случаю. В реальных исполнениях модели наихудший случай реализуется только на подмножестве точек траектории, что дает меньшее значение задержки. Например, можно показать, что если в модели на рис. 2, пакет надолго задерживается в очереди, то время его прохождения через очередь будет заметно ниже наихудшего. Интервалы играют важную роль при построении ранжирующих функций. Заметим, что в общем случае схемная реализация предиката предполагает введение новых регистровых переменных для вычисления значения оператора . Наличие дополнительных переменных, не ограниченных инвариантами, может нарушать сходимость метода -шаговой индукции. На практике интервал всегда можно заменить более простым выражением. Например, если устойчиво по отношению к, то . Использование ранжирующих функций должно давать значительный выигрыш по производительности в сложных случаях. Например, для моделей с числом очередей порядка 10100 оценка BMC может быть очень далека от точной, а -шаговая индукция не завершается за разумное время. Мы полагаем, что метод ранжирующих функций будет работать на больших моделях, и планируем проверить это экспериментально. Для простых моделей большинство алгоритмов верификации позволяет получить результат за короткое время порядка нескольких секунд, и сравнение их быстродействия не представляет интереса. Разработан метод анализа задержек в микроархитектурных моделях коммуникационных фабрик. Метод основан на последовательном применении элементарных свойств задержки для вывода все более сложных оценок из простых гипотез, описывающих поведение отдельных примитивов, и протокола передачи данных. Итоговая оценка консервативно предполагает наихудшую возможную задержку в каждой точке анализируемой траектории. Предложен способ построения ранжирующих функций, позволяющий провести быструю верификацию полученной оценки. 