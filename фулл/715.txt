ЗАЩИТА ИНФОРМАЦИИ АЛГОРИТМ ОБНАРУЖЕНИЯ И ОБХОДА АНТИОТЛАДОЧНЫХ  И АНТИЭМУЛЯЦИОННЫХ ПРИЕМОВ 

Проведен обзор принципов работы отладчиков и эмуляторов, их уязвимостей. Предложен новый алгоритм  обнаружения антиотладочных и антиэмуляционных приемов, а также модификация отладчика для задач анализа  вредоносного кода. Ключевые слова  — эмулятор, отладчик, антиотладочные и антиэмуляционные приемы, вредоносное программное обеспечение. 

Одним из эффективных методов анализа вредоносного программного обеспечения ПО является выполнение кода в среде отладчика или эмулятора. Отладчики обычно используются как инструмент вирусного аналитика, в свою очередь эмуляторы встраиваются в антивирусные продукты для автоматического поиска опасного или нежелательного ПО. Действительно, ряд задач анализа вредоносного кода, например поиск полиморфных вирусов, можно решить, только запустив программный код на выполнение и отслеживая результаты его работы. Чтобы препятствовать работе отладчиков и эмуляторов, авторами вредоносного кода разработан ряд методов. В настоящее время поиск и деактивация таких методов может быть эффективно проведена только в ручном режиме при тщательном анализе алгоритма защиты. В работе предложен алгоритм для обнаружения защищенного от отладчиков и эмуляторов кода. Предлагаемый алгоритм не только облегчает поиск антиотладочных и антиэмуляционных приемов, но и может работать в автоматическом режиме без участия аналитика. Отладчик приложение, которое либо перехватывает окружение отлаживаемой программы во время ее выполнения, либо исполняет ее в виртуальной машине, таким образом помогая находить ошибки. Отладчик позволяет контролировать окружение выполнения например, память, в котором функционирует отлаживаемая программа 1, с. 627. В дальнейшем под отладчиком мы будем понимать приложение, работающее в том же окружении, что и отлаживаемая программа, и использующее отладочные возможности процессора и операционной системы ОС. Существуют две разновидности отладчиков пользовательского режима и режима ядра 2, с. 143. Первые в большинстве своем используют функции ОС, например интерфейс отладки ОС Windows, вторые непосредственно возможности отладки процессоров. Далее в работе рассматривается архитектура процессора x86 и ОС Windows как наиболее распространенные. Любой отладчик должен обеспечивать трассировку приложения и установку точек останова. Трассировка обычно задается выбором специального режима процессора при котором после каждой инструкции управление передается отладчику. Существует три типа точек останова 3 аппаратные используют специальные отладочные регистры, программные вставляют в выполняемый код специальные команды останова int 3 и на доступ к памяти изменяют атрибут доступа к странице памяти и при обращении к ней производят обработку. Для защиты от отладчика программа может использовать следующие методы 4, с. 226 1 проверку регистров, флагов процессора, отвечающих за аппаратную отладку, например проверку того, установлен ли флаг трассировки, а также изменение этих флагов и регистров, что может вести к аварийному завершению отладчика 2 проверку целостности кода для защиты от программных точек прерывания 3 поиск структур отладчика в памяти, например в контексте потока для этой цели можно использовать функцию ОС Windows 4 поиск конкретных отладчиков в системе. В основе эмулятора лежит другой принцип работы. Эмулятор это система, имитирующая работу процессора, оперативной памяти, аппаратного обеспечения и ОС 5, с. 279. В общем случае эмулятор может имитировать ту же систему, на которой он запущен. Таким образом, его можно использовать при анализе вредоносного ПО, поскольку программа, исполняемая в эмуляторе, не может влиять на реальную систему 5. Далее мы будем рассматривать эмуляторы для имитации выполнения программ переносимого формата исполняемых файлов, работающих в ОС Windows. Эмулятор загружает программный код в буфер и, читая последовательно инструкции, имитирует их выполнение. При этом все изменения происходят в переменных эмулятора виртуальные регистры, виртуальный стек, буфер с программой, а не на реальной машине. Процесс имитации проходит в несколько этапов 6 анализ выявляет размер, параметры имитируемой инструкции пересчет адресов должен быть выполнен для всех инструкций, обращающихся к памяти, поскольку нет практической возможности загрузить программу в буфер по адресу, который бы она имела, исполняясь на реальной машине проверка адресов выявляет ошибки адресации проверка дополнительных условий например, для операции div деление эмулятор проверяет неравенство операнда нулю непосредственно имитация инструкции, при которой эмулятор согласно коду инструкции меняет состояние виртуальных регистров, виртуального стека и буфера с кодом и данными программы перевод указателя инструкций на следующую команду. Принципиально алгоритм работы эмулятора имеет два существенных недостатка значительное время имитации команды по сравнению с ее выполнением на реальной машине и сложность правильного имитирования всевозможных инструкций процессора и функций ОС. Для полной эмуляции ОС фактически необходимо переписать все ее функции заново. Исходя из этих недостатков программа может предпринять следующие атаки на эмулятор, чтобы обнаружить его или прекратить эмуляцию 4 использовать неизвестные эмулятору команды процессора например, MMX, SSE, SSE2 или недокументированные инструкции. Не зная текущую команду, эмулятор не сможет продолжить выполнение кода использовать команды, реализованные в эмуляторе, с ошибками если команда выполняется ошибочно, то последующая работа программ будет некорректна использовать неизвестные эмулятору возможности системы имитировать все API-функции ОС Windows практически невозможно реализовать длинные циклы, вычисляющие какой-либо параметр для исполняемого кода. На реальной машине такой код будет выполняться достаточно быстро, а эмуляция подобных циклов займет значительное время для имитации одной команды процессора требуется выполнить десятки или даже сотни инструкций. Антиотладочные и антиэмуляционные приемы в значительной мере распространены во вредоносном ПО. На данный момент для их обнаружения может быть использован сигнатурный анализ для поиска подозрительных мест по известным сигнатурам. Также в некоторых случаях эмулятор или отладчик может сообщить о потенциальном антиотладочном приеме. Эмулятор, например, может встретить неизвестную команду, которую расценит как попытку антиэмуляции. Отладчик может дополнительно проверять, не сбросила ли программа флаги и регистры отладки. Однако описанные методы не способны находить новые антиотладочные приемы, неизвестные на момент создания отладчика или эмулятора, что во многом затрудняет анализ вредоносного ПО. Как видно из приведенного выше описания, методы защиты от отладчиков и эмуляторов используют различные механизмы. На основании этого предлагается алгоритм поиска новых антиотладочных и антиэмуляционных приемов, заключающийся в сравнении работы одного и того же кода в отладчике и эмуляторе. Действительно, приемы для обхода отладчика во многих случаях будут успешно выполняться в среде эмулятора. И наоборот, код, который невозможно исполнить в эмуляторе, будет корректно работать в отладчике. Рассмотрим особенности алгоритма для поиска антиотладочных и антиэмуляционных приемов. На каждом шаге работы выполняется одна инструкция в среде эмулятора и отладчика и сравнивается результат ее выполнения. Инструкции процессора x86 могут влиять на регистры в том числе на регистр флагов и на EIP, а также на содержимое оперативной памяти. В простейшем случае нам достаточно сравнивать указатель инструкций. Его расхождение будет означать, что программа исполняется по разным веткам алгоритма, что в свою очередь говорит об ошибочности работы отладчика или эмулятора. Однако легко сформировать атаку против такого отладчика-эмулятора листинг 1., Следовательно, необходимо также сравнение и регистров общего назначения, и регистра флагов на каждом шаге. Для частных случаев возможно организовать обман предложенного метода, при котором значения регистров в том числе регистра флагов и EIP будут одинаковы, а различаться будут только состояния памяти листинг 2. Поэтому для надежности и отсечения подобных вариантов следует производить сравнение содержимого памяти после некоторых, изменяющих ее, инструкций. Например, к опасным инструкциям можно отнести те, которые не содержат в качестве операнда регистры stos, lods, movs, cmps и ряд других, а также сложные инструкции, которые могут быть реализованы в эмуляторе не полностью или с ошибками. К достоинствам алгоритма для поиска антиотладочных и антиэмуляционных приемов относятся 1 возможность находить новые, ранее неизвестные антиотладочные или антиэмуляционные приемы в автоматическом режиме 2 локализация местонахождения приема, вызвавшего расхождение. Действительно, для обнаружения антиотладочного или антиэмуляционного приема аналитику достаточно проанализировать последовательность инструкций, выполненных до расхождения и ведущих к разным состояниям отладчика и эмулятора 3 устойчивость к приемам, направленным против виртуальных машин. Недостатки данного алгоритма 1 он не способен без дополнительного анализа отличить антиотладочные приемы от антиэмуляционных. В качестве средств дополнительного анализа могут быть использованы, например, сигнатурный или эвристический анализ. Эвристический анализ может, в частности, учитывать тот факт, что исследуемая программа после обнаружения отладчика или эмулятора обычно сразу завершается, а в противном случае выполняет свои функции 2 за антиэмуляционный прием может быть принята случайная ошибка в эмуляторе, ведущая к неправильному выполнению инструкции процессора и, как следствие, к расхождению выполнения кода в предложенном алгоритме. Однако вероятность такой ошибки уменьшается с улучшением качества эмулятора 3 скорость выполнения кода при анализе в предложенном алгоритме меньше, чем в эмуляторе и отладчике. Действительно, после каждой операции необходимо проводить дополнительное сравнение полученных результатов, что требует определенных временных затрат. Поэтому алгоритм не способен обнаруживать атаки, использующие тот факт, что в эмуляторе код выполняется значительно медленнее, чем на реальной машине. Для обнаружения таких атак необходимо использовать другие методы. Итак, предлагаемый алгоритм способен в автоматическом режиме обнаруживать новые антиотладочные и антиэмуляционные приемы, а также помогает их локализовать для дополнительного анализа экспертом. Для демонстрации предлагаемого алгоритма была реализована программа, осуществляющая поиск антиотладочных и антиэмуляционных приемов в автоматическом режиме. Для отладки анализируемого кода используется отладочной интерфейс, выполняющий программу в пошаговом режиме установлен . Для имитации инструкций используется модифицированный эмулятор от свободно распространяемого антивируса . Рассмотрим некоторые особенности реализации. Значение регистров эмулятора при запуске инициализируется регистрами отладчика. Это необходимо для последующей проверки регистров на эквивалентность. Эмулятор имитирует расположение стека по адресу стека отладчика. Это необходимо для эквивалентности указателя стека . Эмулятор пересчитывает регистр EIP, имитируя расположение кода по базовому адресу образа, хотя реально код расположен по другому адресу. В процессе выполнения программа не сверяет регистра флагов. Для упрощения разработки сравнение участков памяти не осуществляется. Проведем демонстрацию предложенного алгоритма обнаружения обманных приемов на примерах. Защищенный код сверяет значение и, в случае если он установлен, сообщает об отладке листинг 3. После сравнения исследуемый код продолжит выполняться по разным путям в отладчике и эмуляторе, что и обнаружит разработанное приложение. В структуре блока переменных окружения процесса есть поле, которое может использоваться для выявления отладчика. Это поле находится по смещению 0x68 от начала . Поле представлено рядом флагов. Значение, которое предполагает присутствие отладчика, складывается из значений следующих полей FLGHEAPENABLETAILCHECK 0x10 FLGHEAPENABLEFREECHECK 0x20 FLGHEAPVALIDATEPARAMETERS 0x40 После команды регистр al будет содержать разные значения в отладчике и эмуляторе, что обнаружит антиотладочный прием. Воспользуемся приемом CALL-POP для определения реального адреса кода. Поскольку в эмуляторе код будет загружен по адресу, отличному от, сравнивая виртуальное расположение кода с реальным, мы можем обнаружить наличие эмулятора листинг 5. Реализованная программа успешно находит такой прием. Следующий прием листинг 6 использует системное прерывание для выявления отладчика. Поскольку эмулятор не может правильно выполнить команду, содержимое регистра eax будет отличаться в отладчике и эмуляторе, что обнаружит антиэмуляционный прием. Итак, разработанное приложение способно обнаруживать ряд обманных приемов. Поиск приемов обхода отладчика или эмулятора не всегда является целью. Во многих случаях например, для поиска и анализа вредоносного кода более важно имитировать правильное исполнение кода, обходя всевозможные защиты. В настоящее время некоторые отладчики, 3 применяют специальный метод анти-антиотладки. В процессе выполнения программы отладчик, используя сигнатурный анализ, пытается обнаружить известные ему антиотладочные приемы и подменяет результат их работы, таким образом не давая обнаружить свое присутствие. Однако таким методом можно обнаруживать только предопределенные антиотладочные приемы. Для обхода антиотладочных приемов возможно дополнительно использовать предложенный ранее алгоритм одновременного выполнения кода в отладчике и эмуляторе. Если программа отлаживается в ручном режиме, аналитику возможно выдавать сообщение о наличии расхождения регистров, памяти в отладчике или эмуляторе. Также возможно в диалоговом режиме предложить использовать значение регистров отладчика или эмулятора для дальнейшего исследования программы. Если исследование производится в автоматическом режиме, например для определения степени опасности ПО, то в случае наличия расхождения система может инициировать в памяти еще одну копию отладчика и эмулятора. Первая пара отладчикэмулятор инициируется значениями регистров и памяти отладчика, вторая эмулятора. Преимуществами данной модификации отладчика являются незначительная, в сравнении с виртуальными машинами, ресурсоемкость увеличенная устойчивость к антиотладочным приемам. Недостатки обусловлены недостатками описанного в первой части статьи алгоритма меньшая, по сравнению с отладчиком, скорость работы подверженность случайным ошибкам, не являющимся антиотладочными или антиэмуляционными приемами, что может привести к увеличению затрат времени на дополнительный анализ. В работе проведен анализ наиболее существенных принципов построения и уязвимостей отладчиков и эмуляторов с точки зрения их использования во вредоносном ПО. По итогам проведенного анализа предложен новый алгоритм детектирования антиотладочных и антиэмуляционных приемов, основанный на параллельном выполнении кода в отладчике и эмуляторе. Алгоритм был реализован программно. Рядом примеров проиллюстрирована его работоспособность. Результаты работы могут быть использованы для более эффективного анализа вредоносного кода. 