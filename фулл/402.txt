АРХИТЕКТУРА ПОДСИСТЕМЫ НЕЧЕТКОГО ВЫВОДА ДЛЯ ОПТИМИЗАТОРА БАЗ ЗНАНИЙ 

Рассматривается архитектура системы нечеткого вывода, реализованная в рамках инструментария оптимизатора БЗ на мягких вычислениях. Разработанная архитектура подразумевает вынесение интерфейса алгоритмов, заинтересованных в получении списка активных правил, в отдельный класс. Сам алгоритм нечеткого вывода реализован в виде шаблонного метода, а его примитивные операции – в классах конкретных моделей нечеткого вывода и баз правил. При этом алгоритм конфигурируется объектом, которому необходимо направлять список активных правил. Представлены результаты работы оптимизатора БЗ на примере создания интеллектуальной системы управления (ИСУ) неустойчивым динамическим объектом. Проведенное тестирование показало, что ИСУ, спроектированная в оптимизаторе, обладает большей робастностью, чем ИСУ, спроектированные с использованием других современных средств.

 На основе теории лингвистической аппроксимации и нечеткого логического вывода Л. Заде и др. были разработаны принципы моделирования и проектирования нечетких систем автоматического управления САУ 1. Создание интеллектуальных систем управления ИСУ является сложным процессом и требует наличия специализированного инструментария, который должен включать в себя средства для формирования и анализа БЗ, в том числе позволяющие автоматически формировать их структуру и параметры. При этом система должна поддерживать основные модели нечеткого вывода, иметь удобный пользовательский интерфейс и поддерживать интеграцию с другим программным обеспечением. В данной статье рассматривается реализация подсистемы нечеткого вывода, входящая в оптимизатор БЗ SCOptimizer 2.Рассмотрим основные модели нечеткого вывода, которые могут быть реализованы в ИСУ. Правило нечеткого вывода в модели Мамдани имеет вид. Как правило, при использовании модели Сугено в качестве функций f рассматривают полиномы. В реальных системах нечеткого вывода допускается наличие нескольких выходных переменных, значение каждой из них определяется независимо друг от друга. Отметим следующие особенности, которые можно наблюдать на примере этих моделей. 1. Вид предпосылки правила не зависит от модели нечеткого вывода и определяется только индексами выбранных для данного правила терммножеств. 2. Вид заключения правила зависит от используемой модели нечеткого вывода, при этом некоторые модели используют терм-множества для выходных переменных, а некоторые не используют. 3. Для расчета результата нечеткого вывода всегда необходимо вычислять значения, которые будем называть уровнем активации правила l. При этом правила с нулевым уровнем активации не влияют на результат. 4. Вычисление результата нечеткого вывода может быть организовано как процесс накопления частичных результатов, вычисляемых для каждого активированного правила. Реализуемая в рамках инструментария БЗ система нечеткого вывода должна в первую очередь обеспечить возможность создания, хранения и расчетов с использованием БЗ, основанных на различных моделях нечеткого вывода. При этом желательно обеспечить возможность максимально простого расширения системы в случае добавления новых моделей. Однако в рамках оптимизатора БЗ следует обеспечить и функционирование других алгоритмов, которым необходимо иметь доступ к промежуточным результатам вычислений нечеткого вывода. Такими алгоритмами являются, в частности, алгоритм выбора наиболее значимых правил LBRW, алгоритм сокращения обучающего сигнала и различные алгоритмы анализа качества БЗ. Эти алгоритмы во время работы используют списки правил, активируемых теми или иными строками обучающего сигнала. Данная операция является и основой вычисления нечеткого вывода, поэтому целесообразно использовать такую архитектуру, которая позволила бы применять одну реализацию алгоритма поиска активных правил в различных целях. Это позволит сократить дублирование кода в ядре системы и упростит ее поддержку. На рисунке 1 показан фрагмент диаграммы классов SCOptimizer, отражающий существенные для системы нечеткого вывода моменты. Рассмотрим классы, приведенные на этой диаграмме. Класс InferenceTarget объявляет интерфейс объектов, заинтересованных в получении списка активных правил. Правила передаются этому объекту по одному через функцию ActivateRule. Класс InferenceEngine является базовым классом для систем нечеткого вывода. Он содержит ряд общих для разных моделей нечеткого вывода функций и наборов данных. В нем объявляются и виртуальные функции, переопределяемые в классах-наследниках, представляющих различные конкретные модели нечеткого вывода MamdaniInferenceEngine, Sugeno0InferenceEngine и Sugeno1InferenceEngine. Так, например, функция Use-OutputMF позволяет определить, используются ли данной моделью терм-множества для выходных переменных. InferenceEngine включает также массивы input и output лингвистических переменных, представленных классом LinguisticVar. Лингвистическая переменная отвечает за нормализацию и денормализацию сигналов, а также за вычисление уровня соответствия входного сигнала распределениям терм-множеств, который сохраняется в массиве fitness и в дальнейшем используется для быстрого вычисления уровня активации правил вывода. Терм-множества представлены классом FMbF, отвечающим за хранение параметров распределений и вычисление уровня принадлежности для заданного входного значения. Еще одна иерархия классов связана с БЗ. Хранение данных правил и их извлечение по указанному индексу соответствующему предпосылке правила обеспечиваются классами, унаследованными от RuleBase. CompleteRuleBase предоставляет полную базу, хранящую все возможные правила. LBRWRuleBase дает возможность использовать частичные базы, хранящие наиболее существенные правила. Подклассы LBRWRuleBase показан один класс LBRWAutoBase определяют различные версии алгоритмов отбора правил, переопределяя функцию Create. Так как формат и объем данных правой части правил существенно различаются для разных моделей нечеткого вывода, непосредственное выделение памяти осуществляется с помощью фабричной функции 3 Allocate-Rules, объявленной в классе InferenceEngine и определенной в его наследниках. Работа алгоритма нечеткого вывода показана на рисунке 2. Процесс начинается с вызова функции Infer класса InferenceEngine, которой передается вектор входных значений, и состоит из трех стадий. Первая стадия включает подготовку модели нечеткого вывода к началу вычислений и обеспечивается вызовом операции PrepareInfer, определенной в дочерних классах. На второй стадии выполняется функция DoInfer. В первую очередь она вычисляет лингвистическое представление входного сигнала, используя функцию CalcFitness входных переменных. Затем вызывается функция ActivateRules, объявленная в классе RuleBase, которая перечисляет все активные правила. Эта функция может переопределяться в классах-наследниках RuleBase для реализации более эффективных вариантов перебора правил в зависимости от используемых структур хранения. Так как в качестве цели для перечисления правил передается указатель на саму систему нечеткого вывода, информация об активных правилах передается конкретной модели нечеткого вывода, которая реализует функцию ActivateRule и накапливает результаты вычислений в своих внутренних переменных. Доступ к правой части правила осуществляется с помощью вызова функции GetRule БЗ. На третьей стадии управление возвращается в функцию Infer, которая вызывает операцию FinalizeInfer, реализованную в конкретной модели нечеткого вывода, проводит необходимые итоговые вычисления и возвращает результат. При использовании других алгоритмов взаимодействие компонентов происходит иным способом. Например, на рисунке 3 показана работа системы при исполнении алгоритма отбора наиболее значимых правил LBRW. Алгоритм определен в функции Create класса LBRWRuleBase или в его наследниках. Во время работы алгоритма просматривается весь набор обучающих данных и для каждой строки вызывается функция DoInfer. Однако целью перечисления правил в данном случае является не потомок InferenceEngine, а база правил LBRWRuleBase. Поэтому информация об активных правилах передается базе правил. В дальнейшем эта информация используется функцией Create для отбора правил, удовлетворяющих тем или иным критериям. В качестве примера применения оптимизатора БЗ рассмотрим задачу управления неустойчивой динамической системой движущаяся каретка перевернутый маятник рис. 4. Динамическое поведение этой системы при воздействии силы управления u описывается системой дифференциальных уравнений второго порядка. Без управления маятник невозможно удержать в вертикальном положении 4. Цель управления сбалансировать положение маятника в условиях существенных ограничений на скорость и положение тележки, а также в условиях ограниченной силы управления. В этом случае для стабилизации необходимо выполнение условия 0.Сравним базу, спроектированную в оптимизаторе БЗ, с базой, спроектированной в ANFIS встроенный инструментарий МатЛаб, и ПИД-регулятором рис. 5. Результаты моделирования показали, что только интеллектуальный регулятор, спроектированный с помощью оптимизатора БЗ, является робастным и выполняет поставленную задачу управления. Все сказанное выше позволяет утверждать, что особенностью архитектуры системы нечеткого вывода в рамках SCOptimizer является реализация алгоритма нечеткого вывода в виде распределенного шаблонного метода 3. При этом ответственность за выполнение операций распределяется следующим образом общая схема работы алгоритма определяется базовым классом моделей нечеткого вывода InferenceEngine функция поиска и перечисления активных правил делегирована классам, отвечающим за хранение БЗ вычисления, необходимые для проведения нечеткого вывода, реализованы в конкретных классах-реализациях моделей нечеткого вывода. Возможность конфигурирования алгоритма нечеткого вывода классом-приемником списка активированных правил позволяет использовать реализацию нечеткого вывода в рамках других алгоритмов, выполняющих различные задачи в процессе автоматизированного построения ИСУ. Реализованная в рамках SCOptimizer архитектура системы нечеткого вывода дала возможность решить ряд инженерных задач, возникших при разработке программного комплекса. Высокая эффективность проектных решений позволила создать систему проектирования ИСУ, превосходящую аналогичный инструментарий МатЛаб 1, что подтверждается результатами тестирования. 