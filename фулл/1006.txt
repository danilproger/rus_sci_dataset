О ВЕКТОРНОМ КВАНТОВАНИИ ИЗОБРАЖЕНИЙ 

Рассматриваются возможности использования кодов, исправляющих ошибки, в задачах векторного квантования для сжатия изображений. Предлагаются методы выбора кода и процедуры проведения преобразований  изображения, позволяющие согласовать код с конкретным сжимаемым изображением. Обосновывается выполнимость процедуры сжатия с помощью декодера линейного кода. Показывается, что при кодовом квантовании достигается требуемый уровень сжатия при меньшей сложности (за меньшее время), чем у известных методов векторного квантования.  Ключевые слова  — сжатие изображений, векторное квантование, кодовое векторное квантование, кодовая книга. 

В основе большинства алгоритмов сжатия изображений с потерями лежит процедура разбиения изображения на правильные фигуры домены. Над доменом производится некоторое спектральное преобразование, результатом которого является таблица спектральных коэффициентов, вносящих различный по значимости вклад в качество изображения, восстановленного с помощью обратного преобразования. Последнее обстоятельство позволяет различным образом с различной степенью точности квантовать спектральные коэффициенты, обеспечивая тем самым сжатие домена без серьезной потери в качестве. При этом спектральные коэффициенты квантуются как скалярные величины, а описанное квантование называется скалярным. Очевидно, при скалярном квантовании домены изображения обрабатываются независимо друг от друга. Между тем многие домены одного изображения схожи, обладают похожей цветовой гаммой, являются частями одного и того же объекта. Кажется очевидным, что использование этих свойств похожести доменов может дать выигрыши, если при сжатии обрабатывать каждый домен как единое целое, а не как множество независимых точек. Чтобы лучше понять предпосылки возможных выигрышей, рассмотрим пример. Имеется стандартное тестовое изображение размером 512 512 точек, каждая точка является одним из 256 оттенков серого. Разобьем изображение на домены размером 8 8 точек. Домен при этом можно представить вектором длины 64 или, что то же самое, точкой в 64-мерном пространстве. Соответственно, всего в таком векторном пространстве будет 256 2 точек. Само же изображение будет разбито всего на 4096 2 доменов, и, следовательно, далеко не все точки пространства будут задействованы. Если бы набор доменов из 2 элементов для этого изображения был известен и кодеру, и декодеру, то можно было бы передать каждый домен максимум 12 битами. Более того, при сжатии с потерей качества все похожие домены внутри изображения могут быть заменены на один, приближающий реальные домены изображения с некоторой ошибкой, что позволит использовать еще меньше бит. Например, если набор используемых образцов будет содержать 256 доменов, то на передачу одного домена изображения потребуется максимум 1 байт, при этом сжатие составило бы не менее 16 раз. Рассматривая домены как векторы и задавая их отображение в похожие векторы из множества квантованных кодовых векторов, можно сформулировать процедуру, которая носит название векторное квантование. Сжатие изображений при векторном квантовании достигается за счет того, что множество квантованных векторов кодовая книга выбирается существенно меньшим, чем исходное множество векторов. Векторное квантование изображений исследовалось в работах 111. В настоящей работе рассматриваются возможности построения кодовых книг с помощью аппарата теории кодов, исправляющих ошибки. Такое векторное квантование мы в дальнейшем будем называть кодовым квантованием. Общий метод векторного квантования состоит в том, что изображение разбивается на домены, а домены рассматриваются как векторы или точки в многомерном пространстве, затем при сжатии с потерей качества похожие между собой домены заменяются на один образец. Все образцы помещаются в кодовую книгу. Векторное квантование обеспечивает сжатие домена в log раз, где длина вектора число точек в домене число бит на символ одного элемента входного вектора число векторов в кодовой книге. После применения векторного квантования восстановленное изображение может отличаться от исходного. Уровень искажений при этом будет определяться не только степенью сжатия, но и самим набором векторов в кодовой книге Одна и та же кодовая книга может давать хорошие результаты для одного изображения и плохие для другого. Поэтому в традиционных схемах применения векторного квантования для каждого изображения строится своя кодовая книга. Для этой цели обычно используется обобщенный алгоритм Ллойда 1, 9, позволяющий относительно быстро создавать кодовую книгу. Такой подход к векторному квантованию, однако, связан с большими накладными расходами при хранении и передаче сжатого изображения, поскольку вместе с изображением требуется хранить передавать и соответствующую кодовую книгу. Степень сжатия при векторном квантовании можно повысить, если отказаться от хранения кодовой книги, например, если использовать одну и ту же книгу для всех изображений. Будем говорить, что домен размера покрывается в коде с радиусом, если найдется для которого сумма квадратов разностей элементов матрицы не превышает Тогда любой код можно рассматривать как покрытие некоего множества доменов радиусом, а процесс векторного квантования как отображение множества доменов в кодовые слова Для кодовой книги кода, построенной адаптивно при помощи обобщенного алгоритма Ллойда, достигается минимально возможный радиус покрытия, так как кодовая книга строится исключительно для покрытия доменов сжимаемого изображения. Получаемый с помощью алгоритма Ллойда код, как правило, не имеет компактного описания и, следовательно, требует значительных временных и или емкостных затрат на передачу или хранение кодовой книги. Использование универсальной кодовой книги, представляющей покрытие всего пространства, влечет за собой потери в степени сжатия, поскольку универсальная книга имеет большой радиус покрытия. Однако такую книгу не надо передавать, она известна всем абонентам. Кроме того, существуют коды покрытия, имеющие простое математическое описание, что делает незначительными затраты на хранение книги. Пусть некоторый линейный, -код над полем, 256 для того же случая, когда каждая точка является одним из 256 оттенков серого Пусть сторона домена изображения будет равна, при этом . Если точки покрываемого пространства являются доменами некоего изображения, то сжатие будет состоять в том, что каждый домен из точек будет заменен на кодовое слово кода, наиболее близкое к исходному домену в евклидовой метрике. Так как кодовое слово однозначно определяется своей информационной совокупностью в нашем случае информационная совокупность имеет длину, то достаточно хранить элементов для восстановления всего кодового слова. В результате вместо точек будет храниться, а сжатие составит раз. Потери качества будут происходить из-за того, что при замене реальных доменов на кодовые слова идеального соответствия не будет. Главным достоинством при этом является то, что сам код в этом случае вообще не передается. Данный метод для случая использования кодов Рида Соломона описан в работе 10. С точки зрения сжатия и последующего восстановления радиус полученного покрытия для изображения влияет на качество восстановленного изображения чем больше радиус, тем хуже объективное качество. На радиус покрытия будут влиять как количество слов в коде, так и расположение этих слов в пространстве относительно точек покрываемого множества, и, следовательно, чем лучше выбран код, тем лучше будет качество восстановленного изображения. Если использовать линейный, -код, то его можно компактно хранить, например, в виде генераторной матрицы кода. Тогда для квантования различных изображений можно использовать разные коды и, следовательно, несколько улучшить качество. Однако, даже несмотря на то, что при использовании помехоустойчивого кода для квантования изображений сам код не нужно хранить, общее сжатие оказывается часто меньшим по сравнению со сжатием при адаптивном построении кода. Дело в том, что адаптивное построение позволяет построить код существенно меньшей размерности при одинаковом качестве восстановленных изображений. Поэтому возникает задача согласования кода и изображения Пусть есть некое пространство и некий код, полностью покрывающий пространство радиусом . Это означает, что для любой точки пространства найдется кодовое слово кода, расстояние от которого до точки пространства не превышает где Пусть пространство, точками которого являются реальные домены изображения и пусть есть набор обратимых преобразований, определенный над множеством точек пространства так, что результат преобразований из всегда принадлежит пространству Таким образом, любую точку из пространства можно при помощи преобразований из перевести в точку пространства, где она будет покрыта кодом с радиусом, и, следовательно, использование кодового слова из в качестве квантователя для точек вида не будет давать ошибку квантования больше, чем, и преобразования смогут подстроить единый код под конкретное изображение. При квантовании точек пространства возникает задача поиска ближайшего кодового слова для произвольной точки пространства. В общем случае эта задача может быть решена полным перебором всех кодовых слов. Однако такой перебор требует больших временных затрат и не применим к сжатию в реальном масштабе времени. Однако при использовании в качестве кодовой книги кода, исправляющего ошибки, задача поиска ближайшего вектора кодовой книги упрощается. Будем полагать, что сжимаемый домен, представляющий собой вектор над некоторым алфавитом, является суммой ближайшего к нему кодового вектора и вектора ошибки . Тогда задачу векторного квантования можно решать с помощью процедуры декодирования в шаре радиуса вектора в коде . Теперь общая схема сжатия изображений при помощи помехоустойчивых кодов можно сформулировать так каждый домен изображения отображается при помощи преобразований в точку пространства, покрытого кодом в пространстве выполняется декодирование вектора в коде, находится ближайшее кодовое слово, принадлежащее коду, и это слово считается квантователем для исходного домена сохраняется информационная совокупность слова . Сжатие от квантования будет состоять в том, что вместо домена будет храниться информационная совокупность . Был описан еще один метод согласования изображения и кода, исправляющего ошибки 11. Метод основан на разбиении изображения на битовые плоскости с последующим использованием при квантовании этих плоскостей кодов с малой плотностью проверок на четность. В работе описаны некоторые схемы векторного квантования изображений, основанные на использовании методов теории помехоустойчивого кодирования для построения кодовых книг. Экспериментальное сравнение кодовых методов векторного квантования со стандартными алгоритмами показывает, что при некотором проигрыше по степени сжатия изображений кодовые методы имеют значительное преимущество по времени их сжатия. 