ПРОГРАММНЫЕ И АППАРАТНЫЕ СРЕДСТВА ИТЕРАТИВНЫЙ АЛГОРИТМ СТАТИЧЕСКОГО АНАЛИЗА   ДЛЯ ОБНАРУЖЕНИЯ ДЕФЕКТОВ   В ИСХОДНОМ КОДЕ ПРОГРАММ 

Предлагается способ организации совместной работы алгоритмов статического анализа для обнаружения  широкого класса дефектов в программах на языке C на основе итеративного алгоритма, многократно выполняющего отдельные алгоритмы анализа с уточнением результатов, получаемых на каждой итерации. Рассматриваются свойства предложенного подхода в сравнении с другими вариантами организации комплексного  анализа. Ключевые слова  — надежность программного обеспечения, обнаружение программных дефектов, статический анализ, интервальный анализ, анализ указателей. 

Одной из важных составляющих качества программного обеспечения является надежность программной системы. Основной причиной недо статочной надежности программных систем яв ляются ошибки, сделанные разработчиками на разных стадиях проектирования. Большинство нефункциональных программных ошибок вно сится на стадии кодирования, будем называть та кие ошибки программными дефектами. Каждый из дефектов может приводить к серьезным послед ствиям аварийным завершениям программы, выдаче некорректных результатов, нарушению конфиденциальности хранимой информации. Среди существующих подходов к обнаруже нию программных дефектов наибольшее распро странение получили аудит исходного кода программ различные виды тестирования анализ трасс выполнения программ верификация программ на основе моделей методы статического анализа. Обнаружение дефектов является трудоемкой задачей и может занимать значительную часть от всего времени разработки, поэтому автоматиза ция ее решения является актуальной. Среди пе речисленных подходов наиболее перспективны ми с точки зрения автоматизации представляют ся методы статического анализа СА. группа методов, кото рые используют исходный код для определения требуемых свойств программы применяются для обнаружения программных дефектов с 70х гг. про шлого века. Рассматриваемые в литературе подходы зача стую предлагают решение узкой задачи поиска одного или нескольких типов дефектов для опре деленного класса программ 1, 2. Анализ потока управления выполняется приближенно точный анализ выражений условий не проводится, меж процедурный анализ либо не выполняется, либо является контекстнонечувствительным. Автор статьи 3 считает возможным выполнение уни версального высокоточного СА для программ, раз мер которых не превышает несколько тысяч строк. Обзор предлагаемых в настоящее время подходов свидетельствует о высокой сложности организа ции и ресурсоемкости выполнения полноценного СА, обеспечивающего анализ всего множества конструкций реального языка программирова ния для обнаружения широкого набора дефектов. Рассмотрим основные проблемы обнаружения дефектов с помощью методов СА в программах на языке C. Для обнаружения дефектов в реальных программных системах необходимо выполнить интервальный анализ объектов анализ указателей с учетом возможности перекрытия объектов в памяти, цепочек указате лей и циклических ссылок анализ указателей на функции и вызовов функций через указатели анализ объектов, имеющих сложный тип контекстночувствительный межпроцедур ный анализ с учетом возможных рекурсий. В настоящее время известны алгоритмы ана лиза, обеспечивающие решение отдельных задач с тем или иным уровнем качества 4, 5. При со вместном использовании нескольких алгоритмов анализа необходимо учитывать наличие зависи мостей между отдельными алгоритмами. Так, например, при проведении интервального анали за используется граф потока управления. По строение полного графа потока управления, в свою очередь, требует анализа выражений в операторах ветвления, для чего необходимы ре зультаты интервального анализа. В общем слу чае каждый из алгоритмов анализа использует результаты остальных алгоритмов. Одним из важных свойств любого алгоритма СА является получаемого решения. Полное решение включает в себя всю информа цию, возможную для анализируемой програм мы, что позволяет обнаружить все дефекты. Дру гим важным свойством алгоритмов СА является . Точное решение не содержит избыточ ной информации, а его использование для обна ружения дефектов гарантирует отсутствие лож ных обнаружений. В данной статье предлагается способ органи зации, предназначенного для обнаружения дефектов в программах на языке C. Данный подход дол жен обеспечивать совместное выполнение алго ритмов анализа с учетом взаимных зависимостей между отдельными алгоритмами. Полученное решение должно быть полным, но может не быть точным. Рассмотрим этапы алгоритма комплексного анализа формирование модели программы извлечение необходимой информации об объектах программы проверка выполнения условий наличия де фекта. Будем называть алгоритмы, обеспечивающие извлечение необходимой информации об объек тах программы, . В качестве базовых выделим алгоритмы ана лиза указателей на функции, анализа указате лей на объекты и интервального анализа. Для совместного использования базовых алго ритмов предлагается, представляющий собой многократное выполне ние базовых алгоритмов анализа с уточнением получаемых результатов на каждой итерации. Порядок выполнения базовых алгоритмов на каждой итерации будет соответствовать порядку, в котором перечислены эти алгоритмы. Структура предлагаемого алгоритма ком плексного анализа представлена на рис. 1. Для выполнения СА используется одно из представлений исходного кода программы. Обзор существующих представлений приведен в рабо те 6. В качестве исходных данных для базовых ал горитмов анализа предлагается использовать расширенный граф потока управления xCFG. Основой для по строения xCFG является SSAпредставление, статическое однократ ное присваивание программы, дополненное ин формацией об областях видимости переменных и типах данных. Рассмотрим основные свойства xCFG. Обыч ный CFG представляет собой граф, вершинами которого являются операторы программы, дуги соединяют вершины CFG, определяя возможные последовательности выполнения операторов в вер шинах CFG. Вершинами xCFG являются кон струкции SSA, которые содержат следующую до полнительную информацию зависимости по дан ным версии переменных в SSA, функции SSA в местах объединения нескольких дуг, другую информацию. При построении xCFG выполняется формиро вание вершин и дуг для конструкций SSA, а так же производится замена вызовов функций на тела функций. Замена осуществляется только для явных вызовов функций, вызовы функций через указатель раскрываются на следующем этапе алгоритма. В месте вызова функции факти ческие параметры сохраняются во временных пе ременных, значения которых присваиваются формальным параметрам функции. Добавляется дуга от вызова функции к первой конструкции в теле вызываемой функции. При выходе из функции возвращаемое значение сохраняется во временной переменной, которая может использо ваться в месте вызова добавляется дуга к месту вызова функции. Предложенный подход позво ляет проводить контекстночувствительный меж процедурный анализ. В реальных программах вложенность вызы ваемых функций может оказаться достаточно ве лика, что приведет к существенному увеличению xCFG и в результате потребует больших вычис лительных затрат для получения решения. До полнительной проблемой является обнаружение и анализ рекурсивных функций. Для решения этих проблем предлагается ограничить вложен ность раскрываемых вызовов функций как ре курсивных, так и не рекурсивных некоторым значением, при достижении которого вызовы функций не раскрываются. Результатом этапа формирования модели яв ляется xCFG анализируемой программы, кото рый будет уточняться и дополняться необходи мой информацией базовыми алгоритмами ана лиза. Алгоритмы интервального анализа, анализа указателей на объекты и указателей на функции описываются в виде правил для конструкций анализируемой программы. Базовые алгоритмы анализа формируют с помощью этих правил по одному уравнению для каждой вершины xCFG. Неизвестными в составленных уравнениях явля ются множества кортежей, описывающие состо яние программы. Для алгоритма анализа указа телей на функции состояние программы со держит кортежи указательфункция, для ана лиза указателей на объекты кортежи указательобъект, для интервального анализа кортежи объектинтервал значений. Со стояния программы, и можно раз делить на подмножества состояний в отдельных вершинах xCFG, и . Будем ис пользовать для обозначения состояния в й вершине xCFG, для обозначения состояния всей программы в любом базовом ал горитме анализа. Из полученных уравнений составляется си стема уравнений, отдельно для каждого базового алгоритма анализа. Построенные системы урав нений решаются с использованием 7. Для каждой системы уравнений исполь зуется решетка, состоящая из подмножеств мно жества всех соответствующих кортежей. Отно шением порядка на решетке является отношение включения подмножеств где кортеж соответствующего базового алго ритма. Система уравнений состоит из уравнений вида, ..., и представляется с помо щью функции, ..., . Поиск ре шения начинается с пустого множества и расши ряется до достижения наименьшей неподвижной точки LFP. LFP функции на некоторой решетке это наименьший элемент решетки, удовлетворяющий условию . LFP функции является мини мально возможным решением системы уравне ний . Для получения LFP требуется обеспечить мо нотонность функции . Функция явля ется монотонной, если справедливо Функция монотонна, если все функции, ..., являются монотонными. Монотон ность функций, ..., обеспечивается пра вилами базовых алгоритмов анализа. Алгорит мы поиска LFP описаны в работе 4. Базовые алгоритмы должны обеспечивать на хождение полного решения. Для этого, при нали чии неопределенности, необходимо всегда выби рать наибольшее возможное решение. Например, в вершине, соответствующей функции, нужно объединять состояния, полученные со всех вход ных дуг. Использование такого подхода не гаран тирует получение точного решения. Рассмотрим базовые алгоритмы анализа более подробно. Алгоритм анализа указателей на функ ции определяет возможные значения указателей в каждой точке программы. На основе полученно го решения производится модификация xCFG выполняется добавление и удаление дуг к телам функций в местах их вызова через указатель. Ал горитм анализа указателей на функции использу ет информацию от интервального анализа и ана лиза указателей на объекты. Эта информация по зволяет анализировать массивы указателей на функции и структуры, поля которых являются указателями на функции. Алгоритм анализа указателей на объекты определяет взаимосвязи между указателями и объектами, на которые они указывают. Алгоритм анализа указателей ис пользует результаты интервального анализа, что позволяет анализировать объекты сложных ти пов с точностью до отдельных элементов. Алго ритм интервального анализа определяет возмож ные интервалы значений объектов. Интерваль ный анализ использует результаты анализа ука зателей для идентификации объектов, операции над которыми выполняются через указатели. При выполнении алгоритма анализа указате лей на функции на первой итерации результаты анализа указателей на объекты и интервального анализа еще не получены. При решении системы уравнений считается, что неизвестные и содержат все возможные кортежи указатель объект и объектинтервал значений соответ ственно. В процессе анализа указателей на функ ции в вершинах xCFG, где происходит вызов функций через указатели, добавляются соответ ствующие дуги. Такой подход позволяет суще ственно сократить xCFG по сравнению с xCFG, в котором для вызовов функции через указатель имеются дуги к телам всех функций с подходя щей сигнатурой. Выполнение остальных базовых алгоритмов на сокращенном xCFG позволяет уменьшить ресурсоемкость и повысить точность результатов на первой итерации. Эти соображе ния явились определяющими при выборе поряд ка выполнения базовых алгоритмов внутри ите рации. Рассмотрим работу базовых алгоритмов ана лиза на последующих итерациях. Обозначим ре шения, получаемые этими алгоритмами на й итерации результаты алгоритма анализа указа телей на функции результаты алгоритма анализа указа теля на объекты результаты алгоритма интервально го анализа. Начиная со второй итерации, алгоритм анализа указателей на функции использует результаты ин тервального анализа и анализа указателей на объ екты с предыдущей итерации, получается уточ ненное решение 1 . В результате вы полнения алгоритма анализа указателей на функ ции происходит сокращение xCFG, что позволяет уточнить результаты всех базовых алгоритмов. Анализ указателей на объекты использует ре зультаты интервального анализа для получения более точного решения 1 . На вто рой и последующих итерациях алгоритм интер вального анализа уточняет набор возможных ин тервалов за счет более точных результатов алго ритма анализа указателей на объекты 1 . Признаком завершения итеративного алго ритма является отсутствие изменений результа тов всех базовых алгоритмов на очередной итера ции. Результат любого базового алгоритма на 1й итерации зависит от результатов всех ал горитмов на предыдущей итерации, например 1 . Если на некоторой ите рации результаты всех базовых алгоритмов не изменились, то они также не изменятся на после дующих итерациях. Будем называть алгоритм, совместно выпол няющий правила всех базовых алгоритмов ана лиза для построения и решения общей системы уравнений, . При решении общей системы уравнений одновремен но определяются неизвестные всех базовых алго ритмов, и . Результатом решения этой системы уравнений является LFP. Рассматриваемый итеративный алгоритм за вершается за конечное число итераций и позво ляет получить решение, включающее в себя LFP комбинированного алгоритма. Для доказательства этих утверждений вос пользуемся методом индукции. Выделим LFP для базовых алгоритмов анализа . Докажем, что на первой итера ции LFP содержится в полученных решениях 1, 1 и 1. Ал горитм анализа указателей на функции строит систему уравнений, где неизвестными в левой ча сти являются состояния программы . Неиз вестными в правой части могут быть также со стояния программы и . Значения и на данный момент еще не определены они заменяются всеми возможными кортежами и, которые включают в себя LFP и . Уравнения для алгоритма анализа указателей на первой итера ции имеют вид . В силу монотонности функции утвержде ние 1 верно. Таким же образом дока зывается утверждение 1 здесь вместо используется 1, система уравнений имеет вид 1 . При дока зательстве 1 рассматривается си стема уравнений 1 1 . Докажем, что для решений, полученных на вто рой итерации, выполняются условия 2 1, 2 1 и 2 1. Рассмотрим систе мы уравнений для анализа указателей на функ ции на первой и второй итерациях Отметим, что функция является моно тонной и выполняются условия 1 и 1 . Используя эту информацию, можно доказать, что 2 1. При доказа тельстве этого факта необходимо учитывать, что функция может меняться от итерации к ите рации за счет сокращения xCFG. Изза ограни ченного объема статьи доказательство не приво дится. Докажем, что если утверждения верны для й итерации, то они также верны и для 1й ите рации. Рассмотрим уравнения одного из базовых алгоритмов на 1й итерации, например урав нения алгоритма анализа указателей на функ ции В силу монотонности функции и условий, верно, что 1. Для алгоритмов анализа указателей на объекты и алгоритма интервального анализа утверждение доказывается аналогично. Доказательство утверждений 1, 1 и 1 выполняется так же, как доказательство для второй итерации, с учетом 1 1, 1. В силу конечности числа состояний любой реальной программы решения базовых ал горитмов на первой итерации состоят из конечно го числа кортежей. На каждой последующей ите рации эти решения, по крайней мере, не возра стают. Из этих утверждений следует, что наступит итерация, на которой ни одно из решений не из менится итеративный алгоритм завершится. Доказательство закончено. Будем рассматривать свойства итеративного алгоритма, сравнивая его с другими способами реализации комплексного анализа. В качестве критериев сравнения используем полноту и точ ность получаемого решения, а также вычисли тельную сложность алгоритма анализа. Одной из возможных реализаций алгоритма комплексного анализа является раздельное вы полнение базовых алгоритмов с объединением полученных результатов. Этот подход отличается простотой, но не учитывает взаимное влияние алгоритмов анализа друг на друга. Нужно отме тить, что экспериментальные исследования ряда существующих средств обнаружения дефектов позволяют сделать вывод об использовании тако го подхода. Решение, полученное при раздель ном выполнении базовых алгоритмов, будет ме нее точным, чем решение итеративного алгорит ма при выполнении одной итерации. Вычисли тельная сложность этих алгоритмов примерно одинакова. Другим вариантом реализации комплексного анализа является комбинированный алгоритм, рассмотренный выше. Поиск решения для ком бинированного алгоритма начинается с пустого множества и выполняется до нахождения LFP. Этот процесс не может быть прерван, так как лю бое промежуточное решение не гарантирует ни каких определенных свойств. Преимуществом итеративного алгоритма является то, что реше ние, полученное на любой итерации, является полным включает LFP и может быть использо вано для обнаружения дефектов. Недостатком итеративного алгоритма является более низкая точность результатов решение, получаемое на любой итерации, по крайней мере, не меньше, чем LFP комбинированного алгоритма. Применение итеративного алгоритма позво ляет контролировать вычислительную слож ность анализа за счет ограничения числа ите раций. Существует класс программ, для кото рых верно, что большая часть уравнений каж дого базового алгоритма не зависит от неизве стных других алгоритмов. Применение итера тивного алгоритма для таких программ являет ся эффективным с точки зрения вычислитель ной сложности за счет независимого решения трех слабосвязанных систем уравнений. При анализе таких программ вычислительная слож ность итеративного алгоритма соизмерима со сложностью комбинированного алгоритма, ис пользующего алгоритм 4 для поиска LFP. Дополнительным преимуществом итератив ного алгоритма является возможность использо вания эвристик. Под эвристиками будем пони мать различные способы увеличения точности и уменьшения вычислительной сложности ите ративного алгоритма. Применение эвристик воз можно на всех итерациях между выполнением базовых алгоритмов. Для реализации некоторых эвристик необходимо выполнять сложные дей ствия, ко торые описываются с помощью нетри виальных алгоритмов. Представление алгорит мических аспектов в виде уравнений для решет ки не является естественным и может оказаться затруднительным или нереализуемым в составе комбинированного алгоритма. Рассмотрим при меры эвристик для уточнения итеративного алго ритма и . В основе предлагаемых способов уточнения итеративного алгоритма лежит анализ возмож ных дуг xCFG и анализ отдельных путей выпол нения программы. При использовании этих эври стик решение, полученное итеративным алгорит мом, может быть более точным, чем решение ком бинированного алгоритма. Применение предла гаемых эвристик не нарушает свойство сходимо сти итеративного алгоритма за конечное число итераций. Дуги xCFG соединяют между собой пары вер шин. Каждая дуга описывает возможную после довательность выполнения конструкций про граммы. Может существовать один или несколь ко путей выполнения программы, проходящих через эту дугу. Дуги, для которых нет ни одного пути выполнения программы, будем называть . Алгоритм уточнения xCFG выполняет поиск и удаление нереализуе мых переходов, использует результаты базовых алгоритмов анализа. Определение возможных путей производится с помощью анализа условных выражений в опе раторах ветвления. Для каждой исходящей дуги оператора ветвления определяется подмножество кортежей из входного состояния, для которых выполняется условие перехода по этой дуге. В случае, если подмножество кортежей для одной из дуг пусто, такая дуга считается нереализуе мым переходом и удаляется из xCFG. Использование рассмотренного алгоритма обе спечивает получение сокращенного xCFG, что, в свою очередь, позволяет повысить общую точ ность итеративного алгоритма. Базовые алгоритмы анализа не учитывают отдельные пути выполнения программы. Про изводится объединение путей после операторов ветвления и в вершинах, на которые есть безу словный переход, что приводит к потере точ ности анализа. Такая реализация базовых алго ритмов обусловлена тем, что отдельный анализ всех возможных путей выполнения для боль ших програм мных систем обладает неприемле мой ресурсоемкостью 3. Для уточнения по лучаемых результатов предлагается учитывать отдельные пути выполнения только для неко торых частей программы. Выбор анализируемой конструкции, для которой выполняется вос становление путей, осуществляется с учетом влияния решения, получаемого в этой конст рукции, на точность общего решения. Исходны ми данными для алгоритма восстановления пу тей являются результаты базовых алгоритмов анализа. Алгоритм состоит из двух стадий на первой стадии производится построение обратных путей из анализируемой конструкции до всех достижи мых точек в рассматриваемой части программы с учетом . Ограничива ющие условия определяют момент завершения стадии построения путей. Примерами таких условий являются ограничение общей длины путей, ограничение на длину каждого пути, по строение путей только внутри анализируемой функции. Упрощенный xCFG программы, для которой уточняется решение в анализируемой конструк ции, помеченной, представлен на рис. 2. Стро ятся все обратные пути от этой конструкции дли ной не более 5. Достигнутые вершины помечены S будем называть их начальными вершина ми. В данном примере анализируемая конструк ция за счет наличия цикла одновременно являет ся начальной вершиной. На второй стадии от каждой начальной вер шины восстанавливаются пути до анализируе мой конструкции. Алгоритм восстановления пу тей начинается с решения, имеющегося в началь ной вершине, и уточняет это решение, проходя по конструкциям программы. Для каждой кон струкции выполняются те же правила, что и в ба зовых алгоритмах анализа. При прохождении пути через вершину с функцией множество ре шений не меняется. В результате для целевой вершины вместо одного общего решения получается несколько отдельных решений Использование отдельных решений позволяет повысить точность итеративного алгоритма. В данной статье рассмотрены вопросы органи зации комплексного анализа для обнаружения дефектов в исходном коде программ на языке C. Предложен итеративный алгоритм, который мно гократно выполняет базовые алгоритмы анализа с уточнением результатов на каждой итерации. Выделены базовые алгоритмы анализа предъяв лены требования к этим алгоритмам. Доказано, что итеративный алгоритм завершается за конеч ное число итераций, а полученное решение явля ется полным. Среди достоинств итеративного алгоритма от метим возможность управлять точностью и вы числительной сложностью анализа за счет огра ничения числа итераций. Показано, что реше ние, полученное на любой итерации алгоритма, также является полным и может использоваться для обнаружения дефектов. Рассмотрены способы улучшения свойств ите ративного алгоритма за счет использования до полнительных эвристик. Приводятся примеры эвристик, уточняющих решение итеративного алгоритма за счет удаления нереализуемых пере ходов и восстановления путей выполнения про граммы. Предложенный подход к организации ком плексного анализа применим для различных язы ков программирования. Представленный итера тивный алгоритм является основой разрабатыва емой системы автоматического обнаружения де фектов в программах на языках CC. Исследование выполнено в рамках работ по государственному контракту 02.514.11.4081 Исследование и разработка системы автомати ческого обнаружения дефектов в исходном коде программного обеспечения Федерального агент ства по науке и инновациям. 