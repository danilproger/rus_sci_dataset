АВТОМАТИЧЕСКИЙ РЕФАКТОРИНГ JAVA-КОДА   С ИСПОЛЬЗОВАНИЕМ STREAM API  

Долгое время функциональное программирование на Java было невозможно. Однако в 8-й версии Java появились лямбда-выражения. Благодаря поддержке стандартных библиотечных классов (Stream, Optional и т. д.)   на Java стало возможно описывать преобразования над данными в функциональном стиле.   Java – достаточно старый язык, на нем написано большое количество императивного кода. Для того чтобы  воспользоваться преимуществами нового подхода, требуется выполнить нетривиальный рефакторинг, что   в случае осуществления человеком может быть весьма утомительным, легко совершить ошибку. К счастью,  для достаточно большого количества ситуаций данный рефакторинг можно безопасно осуществить автоматически.  На основе IntelliJ Idea был разработан программный инструмент, который позволяет обнаружить места, где  возможно автоматическое преобразование императивного кода в эквивалентный с использованием Stream  API, а также автоматическое исправление, которое позволяет произвести замену. Рефакторинг пользуется  средствами IntelliJ Idea для анализа Java-кода, а также интегрируется в саму IDE. Одним из основных критериев корректности работы алгоритма является безопасность данного преобразования. Пользователь не может  доверять инструменту, если преобразование может изменять семантику кода. В данной статье рассматриваются различные ограничения, которые накладываются на шаблоны кода для того, чтобы преобразование без искажения семантики было возможно.  Данный рефакторинг был протестирован на различных библиотеках для проверки сохранения семантики путем проверки результатов тестирования до и после применения рефакторинга.  В статье не будет обсуждаться влияние использования Stream API на производительность приложения.  

 Целью данной работы было создание инструмента для автоматического преобразования кода на Java, написанного в императивном стиле, в код на функциональном стиле с использованием цепочки Stream API, а также интеграция этого инструмента в среду разработки IntelliJ Idea. Использование Stream API вместо традиционных циклов имеет весьма значительные преимущества возможна автоматическая параллелизация, которая может дать прирост производительности, часто такой код намного более короткий и лаконичный, а также более четко выражает намерение автора . Для среды разработки крайне важно предлагать различные варианты преобразования кода, так как каждый из них может обладать своими преимуществами и недостатками, и программист может сам решать, какой из них лучше в данной ситуации. Благодаря инфраструктуре IDE данные автоматические преобразования могут производиться в одно нажатие кнопки. Несмотря на то, что в IDE NetBeans данный рефакторинг уже присутствует, в нем было обнаружено значительное количество недостатков и возможностей улучшения, которые учтены при разработке. Данный рефакторинг было решено разрабатывать для IDE IntelliJ Idea, поскольку она является самой распространенной IDE для Java. Использовать разработки других IDE не представлялось возможным из-за больших различий в семантической модели Java, а также из-за того, что модель рефакторинга там значительно более проста. Stream API предоставляет возможность обработки совокупности однотипных данных. Сценарий обработки записывается декларативно посредством цепочки вызовов. Типичный пример использования Stream API выглядит следующим образом Здесь у каждой строки из списка listOfStrings удаляются начальные и концевые пробелы с помощью операции map затем пустые строки отфильтровываются с помощью filter после этого результат ограничивается десятью строками с помощью limit, и, наконец, выполняется сборка в результирующий список с помощью collect. Здесь имеются операции различных типов. Источник потока метод stream входит в интерфейс List, создает поток из списка. Имеются другие виды источников, которые, например, создают поток из массива, из строк файла, из целых чисел в заданном диапазоне и т. д. Источник возвращает объект типа Stream. Промежуточные intermediate операции map, filter и limit. Эти операции также возвращают объект типа Stream, позволяя объединять в цепочку несколько промежуточных операций. Важная особенность заключается в том, что промежуточные операции всегда ленивы они не производят вычислений, а только запоминают действия, которые необходимо выполнить. Имеются и другие промежуточные операции distinct удалить повторяющиеся элементы, skip пропустить заданное количество первых элементов и т. д. Концевая terminal операция collect. Именно при выполнении концевой операции производится вся цепочка вычислений и сбор результатов. Операция collect принимает так называемый коллектор объект, специфицирующий способ объединения результатов. В данном случае используется коллектор toList, который собирает результаты в список. Другие коллекторы могут собирать в множество, ассоциативный массив, в строку с заданным разделителем и т. д. Помимо collect имеются и другие концевые операции. Например, count просто подсчитывает количество результатов, а anyMatch проверяет, имеется ли хоть один результат, удовлетворяющий заданному условию. Промежуточные операции делятся на операции без состояния map и filter и операции с состоянием limit или distinct. Операции без состояния значительно проще по своей сути они единообразно обрабатывают каждый элемент, при этом порядок их обработки неважен. Обычно такие операции легко выражаются в традиционном цикле. Например, операции map соответствует присваивание или объявление переменной, а операции filter условный оператор if. Операции с состоянием сложнее состояние необходимо хранить в дополнительной переменной либо получать неявно. В традиционных циклах соответствующая семантика выражается разными способами, и их поддержка в процессе преобразования цикла в цепочку Stream API представляет определенную трудность. Ниже приводится два способа выразить тот же алгоритм с помощью традиционного цикла В первом варианте для подсчета количества добавленных элементов используется дополнительная переменная-счетчик count. Во втором способе мы пользуемся размером результирующего списка, который изначально пуст, и на каждом шаге туда добавляется ровно одна запись. Второй способ короче, но менее универсален. К примеру, он не сработает, если результаты требуется собрать не в список, а в множество или в строку с разделителем. Оба приведенных варианта IntelliJ Idea поддерживает, но возможны и другие варианты некоторые предпочитают проверять счетчик перед добавлением элемента, считать в обратном порядке от 10 до 0 и т. д. У операции limit есть другая важная особенность это так называемая короткозамкнутая операция. Она может завершить весь процесс до того, как закончатся входные данные. Короткозамкнутыми могут быть как промежуточные, так и концевые операции. Пример концевой короткозамкнутой операции anyMatch. Эта операция возвращает булеву истину, если хоть один элемент потока удовлетворяет условию, переданному в виде лямбда-выражения параметром anyMatch. При этом, естественно, обработка прекращается. Поток элементов объектного типа имеет тип java.util.stream.StreamT. Так как в языке Java примитивный тип не может являться аргументом обобщенного типа, невозможно создать, к примеру, поток элементов типа float. Однако для удобства и повышенного быстродействия три примитивных типа int, long и double поддерживаются специально для них имеются потоковые типы IntStream, LongStream и DoubleStream. Далее под поддерживаемым типом мы будем иметь в виду любой тип, который может быть элементом потока либо любой объектный тип, либо int, long или double. Другие примитивные типы boolean, short и т. д. назовем неподдерживаемыми типами. Также для простоты под StreamT мы будем иметь в виду поток элементов любого поддерживаемого типа если T соответствует типу int, то вместо Streamint подразумевается IntStream. Будем называть фрагментом Java-выражение expression глава 15 JLS, Java-утверждение statement, JLS 14.5 либо совокупность из нескольких подряд идущих Java-утверждений в пределах одного блока JLS 14.2. Возможен также пустой фрагмент, не содержащий никаких утверждений и выражений. Фрагмент можно преобразовать в тело лямбда-выражения для потоковой операции при соблюдении трех условий. У1. Фрагмент не должен ссылаться на локальные переменные и параметры, которые определены за пределами этого фрагмента и не являются финальными и эффективно-фи нальными. У2. Фрагмент не должен бросать проверяемых исключений. У3. Фрагмент не должен содержать операторов, передающих управление за пределы данного фрагмента за исключением оператора throw. Условие У1 необходимо для любого лямбда-выражения Java в соответствии с 15.27.2 спецификации языка Java 8 далее JLS . Понятие финальной и эффективно-финальной переменной приводится в JLS 4.12.4. Основное требование заключается в том, чтобы значение присваивалось переменной ровно один раз на каждом пути управления. Условие У2 не требуется для любых лямбда-выражений. Лямбда-выражение может бросать проверяемые исключения, если соответствующий абстрактный метод функционального интерфейса JLS 9.8 их объявляет. Однако ни один из функциональных интерфейсов, используемых в Stream API к примеру, java.util.function.Predicate, не объявляет проверяемых исключений. Условие У3 также требуется для любых лямбда-выражений в соответствии с их семантикой в языке Java в отличие, например, от языка Kotlin, где в ряде случаев возможна нелокальная передача управления из лямбда-выражения. Оператор throw, бросающий исключение, допустим, так как, по спецификации Stream API, любое исключение, выброшенное из лямбда-выражения, используемого в цепочке операций, будет выброшено наружу. Разумеется, в соответствии с У2, допустимы только непроверяемые исключения. Условие У2 можно проверить для всего цикла если в цикле есть хоть одна операция, бросающая проверяемое исключение, то преобразование цикла в Stream API невозможно. С другой стороны, условие У1 для всего цикла проверять неоправданно. Во-первых, изменение переменной может не попасть в лямбда-выражения, а стать результатом цепочки вызовов Stream API, как, к примеру, в следующем листинге Здесь переменная count не является эффективно-финальной модифицируется в цикле и объявлена за пределами цикла. Однако этот код легко трансформировать с использованием Stream API Поэтому каждый фрагмент, который необходимо превратить в лямбда-выражение, следует проверять отдельно. В данном примере лямбда-выражением становится только условие s.isEmpty, для которого У1 выполняется. Также возможна ситуация, когда переменная, не являющаяся эффективно-финальной в исходном цикле, станет таковой после преобразования. Тогда преобразование все еще возможно. К примеру, рассмотрим такой цикл Здесь требуется преобразовать в лямбда-выражение вызов метода System.out.printlni, который ссылается на изменяемую переменную i, определенную за пределами выражения. Однако после преобразования цикла i становится неизменяемой Условие У3 также не стоит проверять для всего цикла сразу. Действительно, лямбдавыражение не может содержать операторов типа break если только само не содержит цикл, а оператор return завершит только само лямбда-выражение, но не окружающий его метод. Однако многие циклы, содержащие операторы управления потоком, все-таки можно преобразовать в цепочку Stream API. Операторы break и return иногда можно трансформировать в короткозамкнутую операцию. Оператор continue, переходящий на следующую итерацию цикла, допустим в качестве тела условного оператора if. К примеру, следующие два фрагмента семантически эквивалентны Для обсуждения алгоритма преобразования циклов в вызовы Stream API нам потребуется несколько определений. Для заданной переменной Java-кода V будем обозначать через T ее тип. Подфрагментом F фрагмента F назовем фрагмент, целиком содержащийся во фрагменте F являющийся его частью и не совпадающий с F. Обозначим F F. Генератор GV, S, F это совокупность выходной переменной V поддерживаемого типа, Java-выражения S, имеющего тип StreamT, и фрагмента F. Представление генератора GV, S, F есть следующий Java-цикл Имеются простые и составные генераторы. Простой генератор создается непосредственно по Java-циклу L таким образом, что представление этого генератора семантически эквивалентно исходному циклу L. Определим несколько видов простых генераторов, каждый из них соответствует определенному виду циклов табл. 1. Определения генераторов Generator Definitions Название Вид цикла Операция Обход коллекции forT V EXPR F EXPR имеет тип java.util.Collection G V, EXPR.stream, F Обход массива forT V EXPR F EXPR имеет тип массива G V, Arrays.streamEXPR, F Диапазон чисел forT V START V BOUND V F T либо int, либо long G V, IntStream LongStream.rangeSTART, BOUND, F Диапазон чисел закрытый forT V START V BOUND V F T либо int, либо long G V, IntStream LongStream.rangeClosedSTART, BOUND, F Строки BufferedReader String V whileV BR.readLine null F BR имеет тип java.io.BufferedReader G V, BR.lines, F Преобразование XE функция от Java-выражения типа Stream, которая возвращает новое Java-выражение типа Stream возможно, с другим типом элементов. В большинстве случаев преобразование добавляет новый вызов к существующей цепочке вызовов. К примеру, фильтрующее преобразование может выглядеть так Filt, E E.filterV - P, где V переменная, E Java-выражение, имеющее тип StreamT, а P Java-выражение, представляющее собой предикат от переменной V условие фильтрации и удовлетворяющее условиям У1У3. Результирующее выражение также имеет тип StreamT . Операция OV, F это функция от входной переменной V и фрагмента, которая возвращает тройку V, X, F, состоящую из выходной переменной V, преобразования X и выходного фрагмента F, который является подфрагментом F . Операции определены только для некоторых фрагментов. К примеру, операция фильтрации определена для фрагментов вида ifP F и возвращает тройку V, Filt, F. Всякая операция O обладает следующим свойством для любого генератора GV, S, F, для которого OV, F определена и возвращает тройку V, X, F, представление генератора G семантически эквивалентно представлению генератора GV, XS, F . Генератор G назовем составным генератором. Мы определили следующие операции определена для фрагментов вида ifP F. Возвращает тройку V, E - E.filterV - P, F определена для фрагментов вида ifP continue F. Возвращает тройку V, E - E.filterV - P, F определена для фрагментов вида T V R F, где V объявленная переменная поддерживаемого типа T, причем V используется только в выражении R и не используется в F. Возвращает тройку V, E - E.mapV - R, F. Если тип входной или выходной переменной примитивный, вместо map может использоваться другой метод Stream API например, mapToInt, boxed, asLongStream и т. д. определена для фрагментов вида V R F. Возвращает тройку V, E - E.mapV - R, F определена для фрагментов, являющихся циклами, для которых существует простой генератор GV, S, F, причем V не используется в F. Возвращает тройку V, E - E.flatMapV - S, F. Если тип входной или выходной переменной примитивный, могут использоваться конструкции вида E.flatMapToIntV - S или E.mapToObjV - S.flatMapFunction.identity. Расширенное преобразование назовем функцией EXFb E Fa, которая возвращает новое Java выражение. В отличие от преобразования, помимо непосредственно выражения типа Stream, принимает еще и 2 фрагмента, которые расположены непосредственно до внешнего цикла и после внешнего цикла. Назовем терминалом функцию TG, Fb, Fl, Fa, где GV, S, F, которая для S возвращает расширенное преобразование X. Так же, как и операция, может быть определена не для всех фрагментов. Определим следующие терминалы табл. 2. В табл. 2 для краткости префикс Fb E Fa - был опущен. Данный список не является полным, рефакторинг содержит значительно больше вариантов преобразований, в табл. 2 приведены примеры из каждого класса терминалов. Определения терминалов Terminal Definitions Название терминала Требования к фрагментам Расширенное преобразование Нахождение первого элемента Fb вида OptionalT x Optional.empty Fl вида if P result R break OptionalT x E.findFirstV - P Fa Редукция элементов Fb вида T a I Fl вида for T x c a x, где одна из операций, T a I A E.reduceI, a, b - a b Fa, где I значение идентичности identity value для данной операции, а переменные a и b уникальные в данной области видимости Нахождение минимального максимального элемента Fb вида T a I Fl вида for T x c if x a a x, где обозначает или T a opI, E.max Fa, где op max или min, в зависимости от Сохранение в список Fb вида ListT l new ArrayList Fl вида for T x c l.addx E.collectCollectors.toList Fa Склейка строк Fb вида StringBuilder sb new StringBuilderprefix Fl вида boolean isTail false for T e collection if isTail sb.appenddelimiter else isTail true sb.appendF Fa вида sb.appendsuffix.toString где F содержит только переменную e или другие финальные переменные E.mapF.collectCollectors.joiningd elimiter, prefix, suffix Применение операции для каждого элемента Отсутствуют Fb E.forEachV - Fl Fa Рассмотрим подробнее алгоритм преобразования императивного кода в функциональный. Далее приводится псевдокод данного алгоритма Полагаем, что Fb фрагмент контекста до цикла, Fl фрагмент цикла, Fa фрагмента контекста после цикла, а G базовый генератор для текущего шага рекурсии. Следует пояснить, что operationMatchers и terminalMatchers соответствуют описанию операций и терминалов, которые были рассмотрены ранее. Нетрудно заметить, что подход основан на преобразовании некоторых шаблонов кода, из которых и строится цикл. В статьях 13 были исследованы различные шаблоны ко да в открытых кодовых базах, большая их часть была поддержана в данном рефакторинге. Данная реализация рефакторинга не была первой, аналоги есть в других IDE для Java Eclipse и NetBeans. Далее мы приведем их сравнение с рефакторингом в IntelliJ Idea. Аналогичная возможность реализована в рамках проекта LambdiFicator 4 5 для IDE NetBeans 8.1. По сравнению с разработкой, представленной в данной статье, эта реализация обладает рядом недостатков. 1. Из промежуточных операций поддерживаются только операции filter и map. Операции flatMap, distinct, limit, sorted не поддерживаются ни в каком виде. 2. Из концевых операций поддерживаются только reduce, forEach, anyMatch и noneMatch. Не поддерживаются такие важные способы завершения потока, как collecttoList collectjoining toArray findFirst. 3. Примитивные типы отождествляются с соответствующими им объектными типами к примеру, тип int с типом java.lang.Integer, в то время как Stream API обеспечивает специальную поддержку примитивных типов int, long, double с помощью интерфейсов IntStream, LongStream и DoubleStream соответственно. Такое отождествление не только ухудшает производительность результирующего кода, но и в некоторых случаях может опасным образом изменить семантику кода. Рассмотрим, к примеру, следующий листинг Данная Java-программа при выполнении выдает 1, 3, так как в цикле вызывается метод удаления элемента списка по индексу removeint. IDE NetBeans заменяет цикл следующим образом При этом тип переменной idx меняется на java.lang.Integer, и уже вызывается метод удаления элемента списка, эквивалентного заданному removeInteger. В результате изменяется семантика программы при выполнении она выдает 2, 3. Для сравнения, IntelliJ Idea предлагает заменить тот же самый цикл следующим образом В данном случае благодаря применению операции mapToInt StreamInteger превращается в IntStream, и изменения семантики не происходит. В IDE Eclipse данная функциональность планировалась к реализации с использованием плагина Convert-For-Each-Loop-to-Lambda-Expression-Eclipse-Plugin 6. Плагин не был доведен до рабочего состояния на момент 19 декабря 2018 г., даже базовая функциональность не поддерживается. Код проекта может быть найден на GitHub в репозитории IntelliJ Idea . Точка входа класс StreamApiMigrationInspection, он предназначен для обнаружения шаблонов кода, подходящих для преобразования. После того как подходящий кусок кода найден, будет предложен вариант миграции объект, класс которого BaseStreamApiMigration. Непосредственно преобразованием кода занимается класс MigrateToStreamFix. Здесь же находятся классы StreamSource и Operation, наследники которых соответствуют определению простого генератора и операции соответственно из статьи. Классу TerminalBlock напрямую не соответствует терминал из модели, он обозначает фрагмент, который еще не был обработан и, возможно, содержит терминал. Данный автоматический рефакторинг активирован только для версий Java больше 7. В данной статье была выстроена модель Stream API, на основании нее реализован рефакторинг для преобразования циклов в цепочки вызовов Stream API и внедрен в платформу IntelliJ Idea. Сейчас это преобразование доступно к использованию у миллионов пользователей IDE. Данный рефакторинг успешно распознает большую часть распространенных способов преобразования данных. Корректность обеспечивается сотнями интеграционных тестов и проверками на реальном программном обеспечении, в частности самом коде IntelliJ Idea. 