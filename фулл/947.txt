ЗАЩИТА ИНФОРМАЦИИ КРИПТОГРАФИЧЕСКОЕ РАСПРЕДЕЛЕНИЕ КЛЮЧЕЙ ДЛЯ  ЗАЩИТЫ ИНФОРМАЦИИ В ИЕРАРХИЧЕСКИХ СИСТЕМАХ 

1  Рассматриваются современные системы многоуровневой защиты информации, приводятся ключевые достоинства систем и обосновываются их недостатки. На основе формируемых требований к таким системам  предлагается комбинированный алгоритм для криптографического распределения ключей. Ключевые слова  — защита информации, иерархические системы, криптографическое распределение ключей. 

Многоуровневая защита обеспечивает разграничение доступа cyбъектов с различными правами доступа к объектам различных уровней конфиденциальности 1. Системы многоуровневой защиты предназначены для того, чтобы пользователи имели доступ только к тем частям автоматизированной системы обработки информации, на которые они имеют полномочия, и не могли получить доступ к другим частям автоматизированной системы. Существуют различные формы разграничения доступа к информации в многоуровневых системах, но наиболее часто встречается модель, построенная по иерархическому принципу 2. Иерархическую модель графически можно представить в виде однонаправленного родового дерева 3. Корень может иметь произвольное число подчиненных порожденных элементов, у каждого из которых может быть произвольное число подчиненных элементов более низкого уровня, и так далее для любого числа уровней. У такого дерева корень администратор системы, имеющий доступ ко всей информации в системе узлы пользователи различных уровней иерархии, имеющие доступ к своей информации и информации подчиненных им пользователей листья пользователи, имеющие доступ только к своей информации. Ветви дерева являются однонаправленными сверху вниз и показывают возможные пути доступа к информации в системе. Принципиальным для иерархии является то, что каждый элемент приобретает свой смысл только тогда, когда он рассматривается в своем контексте, т. е. подчиненный элемент не может существовать без своего предшественника по иерархии. Существует три основных метода построения систем защиты информации с иерархическим доступом 1 административное распределение ключей 2 иерархическое шифрование 3 криптографическое распределение ключей. Подробный анализ вышеперечисленных методов приведен в работах 2, 4, здесь же следует отметить, что метод криптографического распределения ключей, которому посвящена предлагаемая работа, позволяет использовать для шифрования информации стандартные широко известные алгоритмы, например ГОСТ 28147-89, DES, AES. Впервые постановка и решение задачи криптографического распределения ключей в иерархических системах была предложена Аклом Akl и Тэйлором Taylor в 1983 г. 5. В качестве иерархической системы Akl и Taylor рассматривали информационную, коммуникационную систему c общим числом пользователей, в которой пользователи, обладают разными полномочиями. Пользователи частично упорядочены отношением, где означает, что пользователь может иметь доступ к информации своего подчиненного если обозначить операцию доступа символом, то . По определению, все пользователи системы подчинены администратору системы пользователю, т. е., 0. Администратор системы генерирует и раздает ключи всех пользователей системы, 0, а также выбирает симметричный алгоритм шифрования, который является единым алгоритмом шифрования для всех пользователей системы. Таким образом, каждый пользователь системы шифрует собственную информацию, используя единый для всей системы алгоритм шифрования, выбранный администратором, и свой секретный ключ . Задача иерархического доступа к информации в такой системе сводится к генерированию таких ключей пользователей, которые бы позволяли осуществлять доступ к информации согласно полномочиям пользователей. Очевидно, что администратор, зная ключи всех пользователей системы, может дешифрировать по известному алгоритму шифрования информацию любого пользователя системы, т. е., 0. Общий вид иерархической системы показан на рис. 1. Введем следующие понятия, которые присущи родовому дереву 3 1 под отцами и сыновьями понимаются пользователи, которые стоят на соседних уровнях, и отец имеет доступ к информации сына 2 под прародителями потомка понимаются такие пользователи, что 3 пользователи, не имеющие сыновей, называются конечными пользователями 4 под братьями понимаются пользователи, имеющие одного отца. Каждому пользователю системы можно присвоить свой уникальный номер идентификатор, который состоит из номеров прародителей всех предшествующих уровней кроме 1-го и своего номера см. рис. 1. Основные требования, предъявляемые к данному классу задач 1 пользователь системы должен иметь доступ к информации только согласно своим полномочиям 2 коалиция пользователей не должна иметь доступ к информации не подчиненных им пользователей 3 вычисление ключей пользователей на любом уровне не должно приводить к замедлению работы автоматизированной системы обработки информации 4 система должна обеспечивать возможность увеличения как в глубину, так и в ширину, без перерасчета остальных параметров системы, т. е. при увеличении количества пользователей на любом уровне, кроме первого, не должен происходить пересчет ключей пользователей на остальных уровнях. В данной статье не будет рассмотрен класс алгоритмов, которые для получения ключей используют либо выделенный сервер 6, либо смарткарты 7. Все существующие криптографические алгоритмы распределения ключей можно разделить на два класса 1 алгоритмы снизу-вверх, в которых либо открытый ключ, либо секретный ключ администратора содержит в себе ключи всех пользователей, начиная с самых нижних уровней 2 алгоритмы сверху-вниз, в которых ключ администратора не содержит в себе ключей потомков, но позволяет вычислить их по некоторому алгоритму. Одним из последних алгоритмов класса снизувверх, родоначальниками которого были Akl и Taylor 5, является алгоритм Дж. Иеха J. Yeh и Р. Шьяма R. Shyam 8. Схема алгоритма заключается в следующем. Администратор выбирает два больших простых секретных числа и и вычисляет и 1 1. Для каждого пользователя выбирает простое число, взаимнопростое с, затем вычисляет такое, что 1mod . Также администратор выбирает секретное число, являющееся основанием по модулю, а затем публикует только, ..., и и генерирует ключи для всех пользователей по следующей формуле т. е. аналогично всем подобным схемам в ключ отца входят ключи его потомков и его собственный ключ . Если пользователь хочет вычислить ключ пользователя, он применяет следующую формулу т. е. возводит свой ключ в степень произведения своего открытого ключа и открытых ключей всех своих потомков, кроме открытого ключа пользователя . Справедливость и безопасность алгоритма доказана в работе 8. Пример работы алгоритма для шести пользователей приведен на рис. 2. Для вычисления ключа пользователь выполняет следующую операцию mod mod mod . Существенным недостатком данного метода распределения ключей является необходимость переконфигурировать различные части системы при добавлении хотя бы одного пользователя . В этом случае следует создать новые, и и заново пересчитать все ключи прародителей пользователя . Также при удалении пользователя следует заново рассчитать все ключи прародителей пользователя, что приводит к необходимости дешифрировать всю ранее зашифрованную этими пользователями информацию и шифровать ее с новыми ключами, что является очень трудоемкой и небезопасной операцией. Второй подход к решению задач распределения ключей сверху-вниз в 1988 г. предложил Сандху Sandhu 9. Идея алгоритма основывается на однонаправленных функциях, т. е. функциях, значения которых легко получить в одну сторону, но невозможно в обратную. Стойкая хэш-функция должна обладать следующими свойствами 1 односторонностью пусть дано хэш-значение H некоторого неизвестного сообщения . Тогда вычислительно невозможно определить по имеющемуся H 2 стойкостью к коллизиям пусть дано сообщение и его хэш-значение H . Тогда вычислительно невозможно вычислительно сложно подобрать такое, что H H 3 строгой стойкостью к коллизии вычислительно невозможно найти два произвольных различных сообщения и, для которых H H . Для лобовой атаки на однонаправленные хэшфункции используют два метода. Первый направлен на взлом второго свойства, т. е. по значению хэш-функции H противник хочет создать другой документ, такой, что H H . Другой метод направлен на взлом третьего свойства противник хочет найти два случайных сообщения и, таких, что H H . Подробный анализ взлома хэш-функций приведен в работе 10, здесь же оценим, насколько успешными на практике могут быть атаки, основанные на двух описанных выше методах. Пусть одна MIPS Million Instruction Per Second машина хэширует миллион сообщений в секунду. При таких условиях число хэш-значений, вычисленных одной MIPS-машиной за один год, составляет 3,1510 . Оценка вероятности взлома хэшфункции для двух рассмотренных методов атаки при различных значениях длины выходного хэшзначения приведена в табл. 1. Из таблицы видно, что при одинаковой длине значения хэш-функции вероятность взлома первым методом намного ниже, чем при взломе хэшфункции вторым методом. Таким образом, чтобы обеспечить требуемую вероятность устойчивости хэш-функции к взлому, необходимо использовать большую длину значения хэш-функции. Так, например, при требовании обеспечить вероятность взлома не более 10, необходимо использовать не 128-битное, а 256-битное значение хэш-функции. Также можно сделать вывод, что при одинаковой длине значения хэш-функции на ее взлом методом поиска документа, такого, что H H, потребуется гораздо меньше времени, чем при взломе хэш-функции методом, основанном на парадоксе дней рождений 10. Таким образом, чтобы обезопасить хэш-функцию от взлома на заданный интервал времени, необходимо использовать большую длину значения хэш-функции. Так, при требовании обеспечить стойкость к взлому хэш-функции в течение 1,1 1025 MIPS-лет необходимо использовать не 128-битное, а 256-битное значение хэш-функции. Российский стандарт хэш-функции ГОСТ Р 34.11-94 использует 256-битное значение хэшфункции, что позволяет утверждать, что при современных вычислительных мощностях его компрометация вычислительно невозможна. Другими словами, для взлома хэш-функции ГОСТ Р 34.11-94 вторым, более эффективным методом потребуется 1,1 1025 MIPS-лет. В 1999 г. Хвонг Hwang предложил схему распределения ключей для частично-упорядоченной иерархии. Алгоритм состоит из двух частей вычисления секретного ключа на основе ключей потомков и получения из секретного ключа открытого ключа при помощи симметричного алгоритма шифрования вместо хэш-функции и своего секретного ключа. Процедура генерирования ключей следующая 1 администратор каждому пользователю присваивает уникальный секретный ключ такой, что если, то, и безопасно распространяет их между пользователями 2 администратор выбирает симметричный алгоритм шифрования, делая его открытым 3 администратор вычисляет открытые ключи пользователей, у которых есть потомки, по следующему алгоритму где количество потомков пользователя . Для вычисления ключей потомков пользователь должен выполнить следующую операцию по уровням дерева, пока не дойдет до требуемого уровня 1 получить из открытого ключа закрытый ключ 2 вычислить по формуле где округление вниз до целого. Справедливость формулы доказана 11. Пример работы алгоритма для шести пользователей приведен на рис. 3, где над пользователями указаны, а под ними . Можно отметить следующие недостатки данного метода 1 уменьшение размеров секретных ключей в зависимости от уровня иерархии 2 большие размеры открытых ключей пользователей, т. е. необходимость проводить вычисления с очень большими числами 3 для получения ключа пользователя на 5 уровней ниже необходимо 5 раз выполнить симметричный алгоритм дешифрирования, что снижает производительность системы по сравнению с предыдущими алгоритмами. К достоинствам данного метода следует отнести малые размеры секретных ключей, возможность изменения структуры иерархии без переконфигурирования ключей системы, а также применимость во всех иерархических структурах. До сих пор предлагаемые системы криптографического распределения ключей при одинаковой криптостойкости алгоритмов удовлетворяли либо третьему, либо четвертому требованию, предъявляемому к данному классу алгоритмов см. выше. Поэтому комбинированный метод распределения ключей, позволяющий эффективно вычислять ключи пользователей, а также модифицировать систему, является актуальной задачей для систем, построенных по иерархическому принципу. Для решения этой задачи в представленном комбинированном алгоритме 12 используется неопределенность, возникающая при целочисленном делении 13, которая определяется задачей поиска подходящего остатка при известном делителе и частном. Очевидно, что объем перебора значительно снижается при возможности коалиционной атаки и при этом существенно зависит от числа участников коалиции. 1. Администратор системы выбирает случайное большое секретное число . По мере возникновения 2-го уровня иерархического дерева администратор для пользователей, ..., генерирует открытых ключей, ..., представляющих собой числа одного порядка, меньшего, чем, и вычисляет секретных ключей, ..., по следующему алгоритму a администратор целочисленно делит секретный ключ на открытые ключи, ..., и вычисляет частных, ..., и остатков,..., div, div, div, где div операция деления без остатка, б администратор вычисляет ключи для пользователей 2-го уровня, . 2. Администратор для братьев вычисляет ключ группы, для чего генерирует открытых ключей группы, так, чтобы выполнялось условие div div div . 3. По мере возникновения 3-го уровня иерархического дерева администратор для пользователей 3-го уровня выполняет операции по п. 1 и 2, где вместо своего секретного ключа использует секретные ключи отцов пользователей 3-го уровня ключи, ..., . Аналогичные операции администратор выполняет при возникновении остальных уровней системы. 4. При добавлении нового подчиненного на любой уровень, кроме первого, администратор выполняет следующие операции a вычисляет секретный ключ пользователя, отца пользователя div div div div, где открытые ключи потомков пользователя по иерархическому дереву до отца пользователя остатки, получаемые при целочисленном делении на соответствующие открытые ключи открытый ключ пользователя остаток, получаемый при целочисленном делении согласно вышеприведенной формуле на открытый ключ б генерирует открытый ключ пользователя в делит секретный ключ, вычисленный по п. 4a, на открытый ключ и вычисляет частное и остаток div, г вычисляет ключ . Каждому пользователю системы можно присвоить свой уникальный номер идентификатор, который состоит из номеров прародителей всех предшествующих уровней кроме 1-го и своего номера. Например, для схемы, изображенной на рис. 4, распределение идентификаторов представлено в табл. 2, где символ - означает разделение номеров. Пример работы алгоритма по распределению ключей для иерархической системы из 11 пользователей см. рис. 4 приведен в табл. 3. При добавлении пользователя администратор формирует для него следующие значения согласно п. 4 a вычисляет ключ пользователя div 987 654 321 div 42341843 429 911 081 б генерирует 8237 в вычисляет div 429 911 081div 8237 52 192, 429 911 081 823752 192 5577 г вычисляет S 52 1925577 291 074 784. Шифрование и дешифрирование происходит по ключу субъекта, которому принадлежит объект некая информация, при помощи блочного симметричного алгоритма например, ГОСТ, DES, AES 1. Например, для пользователя уровня 3 см. рис. 4 администратор получает ключ пользователя следующим образом div div . 1 div 987 654 321 div 4234 233 267 1843 2 233 2671843 429 911 081 3 div 429 911 081 div 7563 56 843 7472 4 56 8437472 424 730 896. Таким образом, 424 730 896. Сравнительный анализ вышеприведенных алгоритмов дан в табл. 4, где максимальное число непосредственных потомков одного пользователя, предположим, что их 10 количество уровней для вычисления ключей простейшая операция с 32-разрядными числами, а для реализации симметричного алгоритма шифрования и хэш-функции требуется операций, где длина ключа 14. Эффективный метод распределения ключей является актуальной задачей для современных компьютерных систем. Одной из областей применения данного метода могут являться системы с иерархическим доступом к информации. Так как основные требования, предъявляемые к данным системам, это возможность быстро получить ключ на любом уровне системы и безопасность системы, то предлагаемый комбинированный алгоритм удовлетворяет вышеуказанным требованиям. 