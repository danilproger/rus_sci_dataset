ИНТЕЛЛЕКТУАЛЬНАЯ СИСТЕМА ОБРАБОТКИ   И ИНТЕГРАЦИИ ЗНАНИЙ НА ОСНОВЕ ТЕХНОЛОГИЙ   СЕМАНТИЧЕСКОЙ ПАУТИНЫ 

Статья посвящена разработке методов извлечения из текстов естественного языка определений ключевых понятий предметной области на основе теоретико-модельного подхода. Извлеченная из текстов информация путем  преобразования через фрагменты атомарных диаграмм алгебраических систем представляется в виде утверждений в логике описаний (DL). Подобное представление позволяет получать тексты с большей выразительностью  по сравнению с алгоритмами, где источником информации являются данные, представленные в виде баз данных  или в виде выражений на формализованных языках (например, SQL).  : онтология, теоретико-модельные методы, фрагменты атомарных диаграмм, определения понятий, извлечение определений, полнота определений понятий, явная определимость, неявная определимость,  генерация текстов, порождение фраз естественного языка.   Исследование выполнено при частичной финансовой поддержке Президиума СО РАН (проект «Инженерия  интенсиональных онтологий в дедуктивных и информационных системах» Комплексной программы ФНИ   СО РАН II.1).  

Современные модели представления информационных ресурсов интенсивно развиваются и внедряются в практику. Важнейшим элементом современных информационных технологий являются онтологии, которые позволяют производить автоматизированную обработку семантики информации с целью ее эффективного использования. С ростом объемов обрабатываемых данных онтологии становятся очень масштабными, что усложняет восприятие конечным пользователем хранящейся в ней информации. Так как в повседневной жизни наиболее распространенной формой представления знаний являются естественно-языковые тексты, проводится все больше исследовательских работ по извлечению описаний объектов OWL-онтологий в виде набора согласованных по смыслу предложений определений. Существует целый каталог систем генераций текстов 1, содержащий краткую информацию обо всех известных более 340 разработках. Большинство из них относятся к 1963 1980 гг. и имеют алгоритмы шаблонного типа система хранит уже готовую строку, возможно, с несколькими пропусками, которые заполняются при выдаче сообщения значениями, соответствующими характеру ошибки. Более сложные шаблонные системы дополнительно проводят ограниченную лингвистическую обработку генерируемого текста. Примером программ с подобной структурой могут служить следующие диалоговая система ELIZA 2, система Employee Appraiser Austin-Haynes и Performance Now KnowledgePoint. Шаблонный метод генерации, безусловно, имеет существенный недостаток. Генерируемые тексты сравнимы с естественными до тех пор, пока они имеются в единственном экземпляре. Вс, что написано на базе шаблона, похоже друг на друга за исключением тех частей, куда вставляются параметры. Также для большинства программ источником информации являются данные, представленные в виде баз данных или в виде выражений на формализованных языках, например SQL. Примеры систем генерации из формального представления REMIT 3, система Минока 4. Однако подобный формат представления данных имеет существенные недостатки. Так как SQL полностью отображается на один из профилей OWL, а именно OWL SQL, то можно провести следующий анализ рис. 1. Отсюда делаем вывод, что полученные определения из текстов с использованием представления информации на языке SQL достаточно тривиальны и не могут включать в себя более выразительные конструкции. Таким образом, главная идея настоящей работы заключается в разработке системы извлечения из текстов естественного языка определений ключевых понятий предметной области на основе теоретико-модельного подхода. Для извлечения из текстов естественного языка определений ключевых понятий предметной области мы используем результаты наших предыдущих исследований. Ранее в 5 был разработан теоретико-модельный подход к извлечению знаний из текстов естественного языка. В основе него лежит представление знаний при помощи конечных фрагментов атомарных диаграмм моделей. Были разработаны и реализованы в виде программной системы методы интерпретации различных частей речи и синтаксических связей с целью автоматического порождения сигнатуры модели 6. В 7 были предложены алгоритмы отображения бескванторных предложений логик предикатов первого порядка сигнатуры, не содержащей функциональных символов, в логику описаний DL. Разрабатываемая на данный момент система сначала извлекает из утверждений на языке DL те, которые имеют отношение к классу или индивидууму, требующему описания в виде текста. Формирует фрагмент OWL онтологии при помощи алгоритмов, также представленных в 7. Далее определяет, каким образом выбранная информация будет реализована языковыми средствами в виде предложений на естественном языке. Для этого используются так называемые текстовые планы, представляющие собой последовательность слотов, инструкции, определяющие правила их заполнения, а также лексические словари в виде OWL-он тологий. В данной работе мы продолжаем разработку теоретико-модельного подхода к формализации определений ключевых понятий предметной области. В частности, мы продолжаем исследование различных подходов к описанию полноты определений понятий относительно онтологии, контекста, множества прецедентов предметной области и т. д., явной и неявной определимости понятий, которое проводилось в 710. В 8 была установлена необходимость неявных определений понятий в формальных глоссариях. В данном параграфе мы изучим взаимосвязь этих результатов с хорошо известной теоремой Бета о неявной определимости. Необходимые определения можно взять из работ 7 11. В 8 было введено понятие формального глоссария. . Пусть сигнатура. Последовательность предложений, назовем, если выполнено а б добавление каждого нового предложения консервативно расширяет предыдущий набор предложений, т. е. Th Th S . Здесь Th теория, порожденная аксиоматизируемая предложением . Мы говорим, что формальный глоссарий, представляет предложение, если Th Th . Были доказаны следующие утверждения. 8. Существуют сигнатура, состоящая из имен двух понятий, и предложение, определяющее смысл понятий из, для которых нет формального глоссария, представляющего предложение, такого, чтобы сигнатура состояла из имени одного понятия, а сигнатура из имен обоих понятий. 8. Не всегда определения понятий могут быть представлены в виде глоссария, определяющего понятия по одному. 8. Не всегда определения понятий могут быть представлены в виде явного глоссария. На первый взгляд этот результат противоречит известной теореме Бета, которая говорит, что любое неявное определение предиката можно преобразовать в явное. 11. Пусть некоторое множество предложений сигнатуры, т. е. . Будем говорить, что отношение, если выполнено ...,...,..., . Будем говорить, что отношение, если существует такая формула ..., что выполнено ...,...,..., . 11. Множество неявно определяет отношение тогда и только тогда, когда определяет отношение явно. Таким образом, теорема Бета утверждает, что понятие, смысл которого неявно задается множеством предложений, может быть явно определено формулой . В чем разница между понятиями неявной определимости соответственно в 8 и в 11, и почему в данном случае не возникает противоречия между указанными теоремой 8 и теоремой Бета 11 Дело в том, что понятие неявной определимости в смысле Бета по существу означает не определение, а задание отношения происходит полное задание объема определяемого предиката. Формула,..., выделяет на модели множество кортежей, на которых предикат является истинным. Иначе говоря, это явное задание в первую очередь объема предиката экстента в терминах анализа формальных понятий 12, а не его содержания ин тента. В то же время формальный глоссарий 8, определяющий некоторый набор понятий, объемы предикатов, соответствующих этим понятиям. Это, в частности, означает, что возможны обогащения одной и той же модели данным новым набором понятий т. е. новым набором сигнатурных символов таким, что у соответствующих предикатов будут разные объемы при разных обогащениях модели. С другой стороны, явная определимость в смысле Бета в точности означает формульную определимость предиката на моделях, на которых истинно множество предложений, а именно в любой формуле мы можем заменить все вхождения предиката,..., на формулу,..., получив в результате формулу . При этом для любой модели, если, то на модели истинность формул и равносильна ...,...,..., . Таким образом, новое понятие, описываемое предикатом, добавленным к сигнатуре, и определяемое множеством предложений, на самом деле не дает ничего нового с точки зрения содержания, а является своего рода синтаксическим сахаром просто сокращением для формулы, выразимой в исходном наборе понятий . Именно формульная определимость предиката обуславливает то, что формула,..., из теоремы Бета полностью и однозначно задает объем предиката на моделях, на которых истинно множество предложений . Рассмотрим вопрос а задает ли полностью формула смысл, содержание предиката А именно, из определения мы имеем ...,...,..., . Будет ли верно обратное, т. е. истинно ли предложение ...,...,..., Отрицательный ответ на этот вопрос дает следующее утверждение. . Существуют сигнатура и множество предложений такие, что ...,...,..., ...,...,..., но неверно ...,...,..., . Таким образом, предложение ...,...,..., всегда полностью задает объем предиката, но не всегда полностью задает его смысл, содержание предиката если считать множество предложений неявным описанием смысла понятия, обозначаемого предикатом . Здесь можно было бы возразить, что мы можем добавить к что угодно, и при этом сохранится истинность утверждения ...,...,..., а утверждение ...,...,..., перестанет быть верным, даже если оно было верно до того. В связи с этим мы можем сформулировать вопрос а следует ли из ...,...,..., вместе с множеством всех следствий множества предложений в сигнатуре, т. е. вме сте с множеством предложений Th Положительный ответ на этот вопрос дает следующее утверждение. . Пусть ...,...,..., и . Тогда выполнено Th ...,...,..., . Тем не менее сделанное нами выше утверждение, что формула ...,...,..., полностью задает объем предиката, но не всегда полностью задает его смысл, остается верным. Это иллюстрирует следующий пример. . Пусть, а, . Тогда, где . С другой стороны, формула не является полным определением смысла предиката, задаваемого множеством предложений . А именно, из не следует, что предикат выделяет ровно один элемент т. е. предикат истинен ровно на одном элементе однако это свойство предиката следует из его неявного определения . Таким образом, явное определение полностью задает объем предиката, но не определяет его смысл. Стало быть, из теоремы Бета не следует, что . Можно было бы сказать, что, но это также является не совсем верным. Дело в том, что у неявного определения и у явного определения классы моделей разные. Действительно, любую модель сигнатуры можно доопределить до модели сигнатуры так, чтобы выполнялось утверждение . С другой стороны, множество предложений из приведенного выше примера может быть истинно только на одноэлементных моделях. Неявное определение объема предиката в теореме Бета на самом деле сводится не к предложению ...,...,..., а к множеству предложений Th ...,...,..., . Множества предложений и Th ...,...,..., как было показано выше, семантически эквивалентны, т. е. на них истинны одни и те же модели. Таким образом, не явное определение предиката сводится к явному определению его объема ...,...,..., но по модулю множества предложений Th сигнатуры . Это множество предложений задает класс моделей сигнатуры, на которых далее задается предикат через его объем. С другой стороны, является неверным утверждение, что неявное определение предиката сводится к явному определению его смысла ...,...,..., по модулю множества предложений Th . В рассмотренном выше примере, существенное свойство предиката то, что он истинен только на одном элементе т. е. в определенном смысле задает константу имя этого элемента, не содержится в яв ном определении . В этом примере множество предложений Th может быть истинно только на одноэлементных моделях. Поэтому из Th и дедуктивно следует предложение . При этом очевидно, что в множестве предложений Th ...,...,..., свойство предиката содержится неявно, в то время как в неявном определении, это свойство содержится явно. Получается, что в данном примере теорема Бета сводит не неявное определение смысла предиката к явному определению, а наоборот, явное определение к неявному. Таким образом, с точки зрения смысла предиката, а не его объема, понятия явного и неявного определения, используемые в теореме Бета, не являются полностью адекватными и требуют пересмотра. Общая и полная схема генерации без детализации происходящих процессов состоит из трех основных блоков 1 планирование содержания текста построение структуры текста 2 микропланирование построение планов предложений 3 языковое оформление реализация построенных планов предложений соответствующими грамматическими структурами. В прикладных системах генерации к этим трем этапам часто добавляется четвертый этап физическое представление, на котором производится форматирование текста согласно выбранному формату PDF, HTML и др.. состоит из следующих частей выбор контента информационного содержания, в котором система выбирает информацию для передачи в следующий этап кон вейера, и текстовое планирование, где она планирует структуру текста, который будет сгенерирован. Когда систему просят описать целевой объект, она прежде всего извлекает из онтологии все OWL-утверждения, связанные с объектом вниз по иерархии вплоть до уровня, указанного в настройках пользователя. Затем алгоритмы преобразуют извлеченный набор OWL операторов в триплеты см. таблицу. OWL-утверждения и соответствующие им формы триплетов OWL-утверждения Триплеты Object экземпляр ClassAssertionClass, object object, instanceOf, Class ClassAssertion ObjectComplementOfClass, object object, notinstanceOf, Class ClassAssertion ObjectOneOfindiv1,indiv2 object object, one of, orindiv1, indiv2, ClassAssertionObjectHasValueojbProp, indiv object object, objProp, indiv ClassAssertion ObjectHasValuedataProp,dataValue object object, dataProp, indiv ClassAssertion ObjectHasSelfobjProp object object, objProp, object ClassAssertion ObjectMaxCardinality number,prop,Class object object,maxCardinalityprop,numberClass ClassAssertion ObjectMinCardinality number,prop,Class object object,minCardinalityprop,numberClass ClassAssertion ObjectExactCardinalitynumber,prop,Clas s object object,exactCardinalityprop,numberClass ClassAssertion ObjectSomeValuesVromobjProp,Class object object, someValuesFromobjProp,Class ClassAssertion ObjectAllValuesVromobjProp,Class object object, allValuesFromobjProp,Class ClassAssertion ObjectIntersectionOfC1,C2, object convertClassAssertionC1, object convertClassAssertionC2, object ClassAssertionObjectUnionOf C1,C2,object orconvertClassAssertionC1,object,convert ClassAssertionC2, object, ObjectPropertyAssertion objProp,object,indiv object, objProp, indiv DataPropertyAssertion dataProp,object,dataValue object, dataProp, dataValue NegativeObjectPropertyAssertion objProp,object,indiv object, notobjProp, indiv NegativeDataPropertyAssertion dataProp,object,dataValue object, notdataProp, dataValue DifferentIndividualsobject,indiv object, differentIndividuals, indiv OWL-утверждения Триплеты DifferentIndividualsindiv,object object, differentIndividuals, indiv SameIndividualobject,indiv object, sameIndividuals, indiv SameIndividualindiv object object, sameIndividuals, indiv Object класс EquivalentClassesObject, Classexpr convert SubClassOf Object, Classexpr EquivalentClassesClassexpr, Object convert SubClassOf Object, Classexpr SubClassOfObject, Class Object, isA, Class SubClassOfObject, ObjectComplementOfClass Object notisA, Class SubClassOfObject,ObjectOneOfindiv1, indiv2 Object, one of, orindiv1, indiv2 SubClassOfObject,ObjectHasValue objProp, indiv Object, objProp, indiv SubClassOfObject,ObjectHasValue dataProp, dataValue Object, dataProp, dataValue SubClassOf Object, ObjectHasSelfobjProp Object, objProp, Object SubClassOfObject, ObjectMaxCardinality number,prop, Class Object,maxCardinalityprop,numberClass SubClassOf Object,ObjectMinCardinality number,prop,Class Object,minCardinalityprop,numberClass SubClassOfObject, ObjectExactCardinality number,prop,Class Object,exactCardinalityprop,numberClass SubClassOfObject, ObjectSomeValuesFromobjProp, Class Object, someValuesFromobjProp, Class SubClassOfObject, ObjectAllValuesFromobjProp, Class Object, allValuesFromobjProp, Class SubClassOfObject,ObjectIntersectionOf C1expr, C2expr convertSubClassOfC1expr, Object convertSubClassOfC2expr, Object SubClassOfObject,ObjectUnionOf C1expr, C2expr orconvertSubClassOfC1expr,Object convertSubClassOfC2expr, Object DisjointClassesObject, Class Object, notisA, Class DisjointClassesClass, Object Object, notisA, Class представляет собой упорядочивание предложений по тематике с использованием дополнительных ресурсов системы. Для работы метода группировки предложений по темам автор онтологии может определить разделы и назначить каждому из них свойства. Если разделы будут определены, то на этапе текстового планирования система распределит триплеты по соответствующим группам. Также эксперт может задать порядок самих разделов, что приводит к дополнительной итерации упорядочивания. Все секции, принадлежность свойств секциям и порядок разделов и свойств определяются в зависимых от онтологии ресурсах генерации. В нашем случае ресурсы также имеют представление OWL-онтологий. В общем случае алгоритм сортировки имеет следующий вид Процедура t0 целевой объект t1, ..., tn объекты второго уровня L0 неотсортированный список триплетов, описывающих t0 ... Ln неотсортированный список триплетов, описывающих tn SMap Карта соответствий между отношениями предикатами и наименованием секции SOrder Отсортированные наименования секций POrder Частично отсортированный массив отношений Отсортированный список триплетов от i 0 до n orderMessageTriplesAuxLi, SMap, SOrder, POrder от i 1 до n insertAfterFirst, L0, Li Вернуть L0 Процедура L Неотсортированный список триплетов об одном объекте SMap Карта соответствий между отношениями предикатами и наименованием секции SOrder Отсортированные наименования секций POrder Частично отсортированный массив отношений S1, ..., Sk списки с триплетами по каждой секции Отсортированный список триплетов об одном объекте S1, ..., Sk splitInSectionsL, SMap от i 1 до k Si orderTriplesInSectionSi, POrder S1, ..., Sk reorderSectionsS1, ..., Sk, SOrder Вернуть concatenateS1, ..., Sk это блок, который позволяет от предметных знаний перейти к языковым. В нем решается, каким образом выбранная информация будет реализована языковыми средствами в виде предложений на естественном языке. В нашем случае микропланирование состоит из трех подэтапов. 1. Лексикализация концептов сообщения, т. е. выбор подходящих слов для выражения выбранного в них содержания. Для каждого глагола, существительного или прилагательного, которые эксперт хочет использовать в планах предложений, должны быть представлены соответствующие синтаксические формы. Большинство синтаксических форм слов русского языка можно автоматически создавать из базовых форм, используя простые правила морфологии. Расширение нашей системы подобными компонентами будет рассмотрено в дальнейших работах. 2. Агрегирование сообщений до структур, соответствующих отдельным предложениям создаваемого текста. Системы генерации текстов часто объединяют предложения, полученные после обработки триплетов, в более длинные, чтобы улучшить читаемость. Агрегация предложения выполняется при помощи набора определенных правил, которые применяются к структурам, полученным в ходе работы текстового планировщика. Другими словами, они применяются к предложениям, уже отсортированным и сгруппированным по семантике. Действительно, объединение не связных по смыслу предложений будет звучать неестественно. Так как агрегация происходит по четко заданным шаблонам, ее возможности полностью зависят от результата работы предыдущего этапа. Рассмотрим теперь каждое из используемых правил. . Последовательность триплетов сообщений в форме S, P, O1, ..., S, P, On будет объединена в один триплет S, P, и О1, .... Оn., причем M это один из minCardinality, maxCardinality, exactCardinality. Применение данного правила снимает ограничение на maxMessagesPer Sentence., для того же S, где P является свойством онтологии., где Pi это свойство онтологии. В каждом из последующих или предшествующих предложений должен быть сам объект, за которым сразу следует только прилагательное. Прилагательные вписываются в результирующее предложение, сохраняя их порядок, определенный планировщиком., где S одинаковый во всех предложениях, а Pi это свойства онтологии. Результирующее предложение может быть сформировано путем однократного использования существительного и глагола. Соединительный союз и вставляется перед последним существительным., где S одинаковое во всех тройках, а Pi свойства онтологии. Для программного продукта были выработаны следующие требования 1 форма десктопного приложения 2 работа с уже существующей системой логического вывода 3 работа с уже существующей системой получения фрагментов атомарных диаграмм и алгоритмами получения DL утверждений 4 удобство и простота использования. Под эти требования подходило большое число языков программирования, однако основной выбор пал на объектно-ориентированные. Также были сформулированы не функциональные требования 1 быстрота и удобство разработки 2 возможность устройства модульной архитектуры 3 знания и умения разработки на выбранном языке программирования. Поскольку быстрота работы программы в данном случае не является существенным требованием, был выбран кроссплатформенный язык программирования Java, так как он удовлетворил всем поставленным требованиям. Структура программы представлена следующими директориями. Основные классы программы 1 пакет, отвечающий за возможность графической работы 2 пакет представления данных 3 пакет классов, реализующих основную логику приложения. В программе используются дополнительные библиотеки 1 Apache Commons 2 OWLAPI библиотека для работы с OWL-онтологиями 3 Jena библиотека для работы с OWL-онтологиями 4 Hermit машина логического вывода. Основной модуль разработан с использованием архитектурного шаблона Pipeline. На рис. 2 представлена его use-case диаграмма, отображающая основные возможные действия пользователя. В рамках дополнительных возможностей все загружаемые элементы можно проверить машиной логического вывода Hermit. В работе изучены вопросы полноты определений ключевых понятий предметной области, явной и неявной определимости ключевых понятий. Исследована полнота определений понятий относительно объема и содержания соответствующих сигнатурных предикатов. Разработаны методы интеграции фрагментов определения ключевого понятия, извлечен ных из текстов естественного языка. Методы интеграции частей определения понятия основаны на представлении знаний, извлеченных из текстов естественного языка, в виде фрагментов атомарной диаграммы алгебраической системы и на преобразовании фрагментов атомарной диаграммы в логику описаний DL и в OWL. Полученные OWL-спецификации погружаются в OWL-онтологию, соответствующую данной предметной области. Разработаны методы интеграции OWL-спецификаций, представленных в OWL-онтологии, и порождения по ним фраз естественного языка. 