РАЗРАБОТКА ИНСТРУМЕНТАЛЬНЫХ СРЕДСТВ АНАЛИЗА ДРАЙВЕРОВ ОПЕРАЦИОННОЙ СИСТЕМЫ LINUX 

Описывается инструмент для поиска проблем синхронизации в драйверах операционной системы Linux, который использует метод обнаружения ошибочных ситуаций с помощью семантических моделей, основанный на теории, описанной в работе [2]. Метод позволяет обнаруживать такие ошибки синхронизации, как зацикливания, взаимоблокировки, двойные блокировки и другие. Инструмент для поиска ошибок синхронизации состоит из четырех основных частей: препроцессора, транслятора кода драйвера в программу на языке асинхронных функциональных схем (далее АФС), модуля представления программы АФС в виде системы рекурсивных уравнений, анализатора системы рекурсивных уравнений. Препроцессор реализован в виде сценария на языке bash, его назначение – подготовка кода драйвера к трансляции в язык АФС. После всех подготовительных процедур препроцессор передает управление транслятору в язык АФС. Транслятор написан с использованием генераторов лексических анализаторов GNU Flex и синтаксических анализаторов GNU Bison. Драйвер преобразуется в программу на языке АФС на основе заданной в настоящей статье операционной семантики для объектов синхронизации. Следующим этапом является преобразование программы на языке АФС в систему рекурсивных уравнений. На основе теории из [3] программа на языке АФС представляется в виде системы рекурсивных уравнений, которая задает множество вычислительных последовательностей, сопоставляемое структуре драйвера. С целью поиска ошибок синхронизации реализован инструмент для анализа полученной системы рекурсивных уравнений. Он имеет модульную архитектуру, поэтому возможна его адаптация для различных типов ПО. Помимо этого, в данный момент ведутся исследования, изучающие возможность применения метода из [2] для обнаружения состояния гонок.

 Операционные системы являются одним из самых важных компонентов вычислительной системы. Однако, как и любое ПО, они могут содержать ошибки. Современные системы имеют довольно сложную структуру и состоят из множества взаимосвязанных модулей. Одной из самых частых причин сбоя являются ошибки в драйверах операционной системы. Драйвер программа, обеспечивающая взаимодействие между устройством и операционной системой. В большинстве случаев драйвер входит в состав операционной системы и является ее самой объемной частью по количеству строк кода. Это связано с необходимостью поддержки множества типов устройств, которым зачастую требуется доступ к функциям ядра операционной системы. Как показано в 1, одной из самых распространенных ошибок в драйверах Linux являются ошибки синхронизации. Это приводит к появлению в драйверах взаимоблокировок, двойных блокировок и к погоне за ресурсами. Такие ошибки довольно сложно обнаружить и воспроизвести, так как они могут проявляться лишь при определенных взаимодействиях функций драйвера, а также нескольких драйверов, имеющих общие ресурсы. В статье описывается инструмент для поиска проблем синхронизации в драйверах Linux, использующий разработанный авторами метод обнаружения ошибочных ситуаций на основе семантических моделей 2. Данный инструмент позволяет обнаруживать такие ошибки синхронизации, как зацикливания, взаимоблокировки, двойные блокировки. Рассмотрены основные компоненты данного инструмента, принципы их работы, описана процессная семантика объектов синхронизации ядра Linux на языке асинхронных функциональных схем . Основные компоненты инструмента верификации Верификатор объектов синхронизации имеет модульную структуру. Отдельные компоненты связаны между собой последовательно выход одного компонента передается на вход следующего. Этот подход позволяет модифицировать отдельные части верификатора для адаптации к иному типу программ. Верификатор состоит из препроцессора, транслятора кода драйвера в программу на языке АФС, модуля представления программы АФС в виде системы рекурсивных уравнений, анализатора системы рекурсивных уравнений. Схема работы верификатора представлена на рисунке 1. Рассмотрим особенности реализации каждого компонента. Препроцессор реализован в виде сценария на языке bash. Его назначение подготовка кода драйвера к трансляции в язык АФС. Исходный код драйвера поступает на вход препроцессора, который считывает файл Makefile драйвера и анализирует зависимости между файлами исходного кода модуля. При необходимости подключения какоголибо заголовочного файла препроцессор может искать недостающие файлы в директориях, указанных в его параметрах. На выходе препроцессора получается один файл исходного кода драйвера на языке C, который передается на вход транслятора в язык АФС. После всех подготовительных процедур препроцессор передает управление транслятору в язык АФС. В данном случае АФС выбран как основной язык для промежуточного представления структуры драйвера. Выбор обусловлен удобством при преобразовании в систему рекурсивных уравнений и наличием уже заданных семантических областей для данного языка 3. Транслятор из языка С в язык АФС будем называть Front-endтранслятором, этот термин часто используется для трансляторов из исходного языка в язык промежуточного представления . Транслятор написан с использованием генераторов лексических анализаторов GNU Flex и синтаксических анализаторов GNU Bison. На вход Flex подается файл на языке Lex и описывает генерируемый лексический анализатор. Компилятор Flex преобразует этот файл в программу на языке C. Эта программа представляет собой работающий лексический анализатор, который может получать на вход поток символов и выдавать поток токенов. Каждый шаблон является регулярным выражением. Действия представляют собой фрагменты кода, описанные на языке С. Сгенерированный лексический анализатор в дальнейшем используется для генерации синтаксического анализатора. Генератор синтаксических анализаторов Bison на вход получает файл со спецификацией разрабатываемого транслятора на языке Yacc, который он преобразует в синтаксический анализатор на языке C. Основой файла на языке Yacc являются правила трансляции грамматических выражений и семантических действий для каждого из этих правил. На выходе Bison получается программатранслятор, которая на основе заданных семантических правил преобразует исходную программу. В основе транслятора кода драйвера в язык АФС лежат реализация шаблона для анализатора языка ANSI C, а также ранние версии компилятора GCC, синтаксис которого был задан с использованием Bison. После лексического и синтаксического анализа кода драйвера на выходе получается абстрактное синтаксическое дерево программы. Далее это дерево используется для анализа структуры программы и для генерации программы на языке АФС. Затем анализатор просматривает тело функции инициализации и находит инициализацию устройства при помощи функции cdevinit, из этого вызова считывается идентификатор структуры fileoperations. Данная структура содержит указатели на операции open, close, read, write и др. Именно они и представляют особый интерес, так как зачастую выполняются параллельно. Каждой операции драйвера соответствует функциональный процесс на языке АФС. Транслятор исследует все эти функции и собирает информацию об использовании в них объектов синхронизации. Линейные операторы не представляют интереса и поэтому заменяются на команды вида C. Далее анализируется использование данных объектов функциями драйвера. Эти взаимосвязи необходимы для генерации программы на языке АФС. На выходе после выполнения всех шагов Front-end записывает программу на языке АФС в файл с расширением. afs. Данный файл используется для дальнейшего анализа программы. Рассмотрим основные семантические правила преобразования объектов синхронизации драйвера, описанных подробно в 1, в язык АФС. Операционная семантика условных переменных Условные переменные позволяют синхронизировать задания, при этом один или несколько процессов ожидают на условной переменной, пока другой процесс не отправит ожидающим процессам сигнал о завершении события. Операционная семантика спин-блокировок Спин-блокировки в драйверах встречаются довольно часто. Семантически спин-блокировка представляет собой циклическую проверку возможности захвата объекта типа spinlockt. Захват блокировки соответствует попытке записи в канал, данная попытка повторяется в цикле LOOP до успешной записи. Операционная семантика спин-блокировок чтения-записи Спин-блокировка чтения-записи реализуется на языке АФС посредством двух каналов для чтения и записи соответственно если захватывается блокировка на чтение, то производится запись в канал для чтения, если на запись в канал для записи. В целом семантика спин-блокировки чтения-записи очень схожа с обычными спинблокировками, к которым добавляются лишь дополнительные проверки при захвате блокировки. Операционная семантика семафоров Семафоры на языке АФС моделируются несколько сложнее. Семафор ограничивает количество потоков в критическом участке кода специальным счетчиком, который моделируется на языке АФС каналами . Таким образом, выполнение операции down на АФС соответствует последовательной проверке возможности записи в первый канал если этот канал занят, осуществляется попытка записи во второй канал и т.д. Если свободный канал не найден, операция прерывается в ожидании освобождения канала. При выполнении операции up действия совершаются в обратном порядке последовательно осуществляется попытка считывания из канала N, затем из N1 и так далее до канала 1, где N максимальное значение счетчика семафора. В семафорах чтения-записи счетчик потоков всегда равен единице. Операционная семантика мьютексов Мьютексы по сути являются семафорами со счетчиком, равным единице. Они используются там, где в критический участок кода должен зайти только один поток. Семантически мьютексы отличаются от спин-блокировок тем, что при неудачном захвате мьютекса процесс засыпает. На языке АФС операция захвата мьютекса соответствует попытке записи в канал. Канал устроен таким образом, что при невозможности записи в данный момент процесс засыпает в ожидании освобождения канала. Для освобождения мьютекса необходимо прочитать данные из канала. Следующий после представления драйвера на языке АФС этап преобразование программы на языке АФС в систему рекурсивных уравнений. На основе теории, описанной в 3, сначала определяется априорная семантика функциональных процессов и каналов связи. Полученные априорные семантики объединяются посредством операции композиции в алгебре вычислительных последовательностей. Затем с использованием аксиомы базисных свойств операции параллельной композиции и с применением по возможности операции инкапсуляции семантическое значение представляется в виде системы рекурсивных уравнений. Все операции производятся при помощи символьных вычислений с использованием аксиом из 3. Полученная система рекурсивных уравнений задает множество вычислительных последовательностей, сопоставляемое структуре драйвера. На выходе система рекурсивных уравнений записывается в файл с расширением. sem. Система рекурсивных уравнений сама по себе довольно сложна для анализа программы. Поэтому с целью упрощения обнаружения исключительных ситуаций реализован инструмент для анализа системы рекурсивных уравнений. Он позволяет анализировать систему рекурсивных уравнений в файле с расширением. sem и выводить в удобочитаемом виде информацию о возможных ошибках синхронизации в драйвере. Данные о верификации записываются в файл с расширением. res в виде списка, где каждая строка указывает на возможную ошибку. Модульность структуры верификатора Модульная система верификатора позволяет адаптировать инструмент к программам самого разного назначения, для применения в новой сфере необходимо лишь переписать front-end. Исходный код верификатора написан с использованием языка C и утилит Flex Bison. Так как существуют реализации этих утилит для множества различных операционных систем, данный верификатор является полностью переносимым. Однако для анализа определенных типов программ необходимо адаптировать front-end. Это связано с различной семантикой элементов синхронизации, а также с особенностью реализации библиотеки для работы с потоками. В перспективе данный подход можно обобщить на верификацию драйверов операционной системы Windows, а также использовать для анализа многопоточных и параллельных программ как для операционных систем Linux, так и для Windows. Помимо этого исследуются возможности применения метода из 2 для обнаружения состояния гонок. В заключение отметим, что в данной статье описан инструмент для поиска проблем синхронизации в драйверах Linux, основанный на разработанном авторами методе обнаружения ошибочных ситуаций на основе семантических моделей 2. Кроме того, в статье описана процессная семантика объектов синхронизации ядра Linux на языке асинхронных функциональных схем. 