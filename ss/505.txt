ПРОГРАММНАЯ КОНВЕЙЕРИЗАЦИЯ ЦИКЛОВ ДЛЯ УСКОРИТЕЛЯ ПЛАВАЮЩЕЙ АРИФМЕТИКИ В СОСТАВЕ ПРОЦЕССОРА КОМДИВ128-РИО  

Представлен метод программной конвейеризации циклов для специализированного ускорителя в составе процессора Комдив128-РИО архитектуры MIPS. Программирование ускорителя производится только на языке ассемблера, поскольку создание компиляторов с языков высокого уровня для него невозможно из-за ряда архитектурных особенностей. Ручная разработка эффективных вычислительных циклов для ускорителя является сложной задачей, так как программист должен учитывать множество факторов, таких как отсутствие аппаратных задержек по неготовности данных, сложная структура регистрового файла, отсутствие ветвлений и ограниченный аппаратный стек. Целью работы является разработка автоматических средств программной конвейеризации циклов для специализированного ускорителя. Это позволяет программисту писать достаточно простые внутренние циклы, которые правильно реализуют вычисления, но могут быть неоптимальными. Затем исходный цикл трансформируется в конвейеризованный, на нем достигается максимальная или близкая к максимальной эффективность выполнения заданных программистом вычислений. Использование точного подхода, основанного на применении методов целочисленного линейного программирования, позволяет обеспечить оптимальную производительность кода. Основное внимание в статье уделено особенностям формулировки задачи целочисленного линейного программирования, связанным со спецификой архитектуры ускорителя. Рассмотрены вопросы точного подсчета числа требуемых регистров, а также проблема понижения кратности развертки конвейеризованных циклов..

 В НИИСИ РАН разработан процессор К128-РИО, в состав которого включен ускоритель плавающей арифметики специализированный сопроцессор CP2, ориентированный на выполнение арифметических операций над комплексными числами или векторами длины 2, элементы которых являются значениями одинарной точности с плавающей запятой. Сопроцессор обладает собственной системой команд и накристальной программной памятью. Сопроцессор имеет параллелизм как на уровне команд, так и на уровне данных, что обеспечивает высокий потенциал производительности, однако эффективное использование этого потенциала представляет собой сложную задачу. Перечислим основные факторы, которыми определяется сложность программирования сопроцессора. Архитектура SIMD single instruction multiple data. Сопроцессор выполняет одни и те же команды в нескольких вычислительных секциях. Соответственно, в программе следует предусмотреть разделение данных для разных вычислительных секций и аккуратную обработку неполных не кратных числу секций наборов данных. Некоторые примеры программирования отражены в 1. Суперскалярность. На каждом такте запускаются две команды вычислительная SIMD и управляющая. Для их выполнения используются два конвейера, имеющих разную длину. Отсутствие аппаратных задержек по неготовности данных. Команда может прочитать значение своего входного регистра R до того, как оно было записано последней из предшествующих команд, модифицирующих R. Программист может сознательно использовать это свойство сопроцессора, чтобы считать предыдущее значение регистра. Это возможно, так как выполнение программы на сопроцессоре строго синхронно. Выполнение команды не может завершиться раньше, чем ожидается, поскольку отсутствуют какие-либо источники прерываний. Аппаратура также не отслеживает конфликты по записи, когда две команды одновременно записывают значение в один и тот же регистр, при этом результат не определен. Программист обязан учитывать эти аппаратные особенности, при необходимости вставляя в программу команды NOP. Отказ от аппаратного контроля подобных ситуаций позволяет значительно упростить сопроцессор такое решение оправдано тем, что от запускаемых на сопроцессоре программ ожидается максимальная производительность, которая может быть достигнута только при безостановочной работе конвейера. Особенности архитектуры сопроцессора и его система команд отсутствие ветвлений, ограниченный аппаратный стек не позволяют реализовать для него компиляторы с языков высокого уровня поэтому программы для CP2 разрабатываются на ассемблере. Написание ассемблерных программ, эффективно использующих вычислительные ресурсы сопроцессора, является сложной задачей, требующей больших трудозатрат и высокой квалификации разработчиков. Целью настоящей работы является реализация программной конвейеризации внутренних циклов в программах для сопроцессора. Это позволяет программисту писать достаточно простые внутренние циклы, которые правильно реализуют вычисления, но могут быть неоптимальными. В результате конвейеризации исходный цикл трансформируется в конвейеризованный, на котором достигается максимальная или близкая к максимальной эффективность выполнения заданных программистом вычислений. Архитектурные особенности ускорителя плавающей арифметики Основные элементы CP2. Специализированный сопроцессор CP2 в составе Комдив128-РИО ориентирован на задачи обработки сигналов с пиковой производительностью 8 Гфлопс. Перечислим основные элементы CP2 рис. 1. Четыре вычислительные секции. Каждая секция имеет свой регистровый файл, управляющие регистры и память. Регистровый файл FPR состоит из 64 64-разрядных регистров. Регистр FPR может содержать два 32-битных значения с плавающей запятой которые могут рассматриваться как вектор или как комплексное значение или два целочисленных 32-битных значения. Из управляющих регистров вычислительных секций в контексте данной работы существенны регистры кодов условий FCCR, которые содержат по 8 бит кодов условий. Коды устанавливаются командами сравнения и могут использоваться предикатно исполняемыми командами. Память данных ОЗУ имеет объем 64 Кбайта 213 64-разрядных слов. Рис. 1. Структура CP2 Управляющая секция CP2, содержащая регистровый файл из 16 общих регистров GPR. Устройство генерации адресов AGU. Включает по 16 13-разрядных регистров адреса An, модификации Nn и режима Mn. Поле номера адресного регистра в командах чтения-записи и в командах модификации адресных регистров относится ко всем трем регистрам с указанным номером. Регистры инкрементации Nn определяют величину автоинкрементации соответствующего адресного регистра, а регистры режима адресации Mn режим постмодификации адресного регистра. Поддерживаются режимы линейной адресации, бит-реверсной адресации и адресации по модулю для работы с циклическими буферами. Память коэффициентов ПЗУ объемом 64 Кбайта. Регистры управления CP2 PC программный счетчик, Comm коммуникационный регистр для связи с управляющим процессором, Control регистр управления CP2, Status регистр состояния CP2, PSP указатель вершины стека подпрограмм, LC, LA, LSP регистры для организации циклов, Rind, Rstep, Rmask регистры для адресации ПЗУ, стеки вызовов подпрограмм и организации циклов. Программная память объемом 64 Кбайта, вмещающая 213 64-разрядных командных слов. Командное слово включает VLIW-команду, содержащую одну команду управляющей секции и одну вычислительную команду, выполняющуюся на всех четырех вычислительных секциях. Каждая секция выполняет команду для данных, хранящихся в ее локальных ОЗУ и FPR. Система команд CP2. Команды сопроцессора условно разделены на две группы. Команды первой группы арифметические операции выполняются сразу во всех вычислительных секциях. К этой группе относятся арифметические операции над комплексными, вещественными и целыми числами команды преобразования форматов данных, сравнения, а также для работы с регистрами FPR операция Nop. Команды второй группы операции пересылки и управления выполняются в управляющей секции. Эта группа команд включает локальные обмены данными, команды управления, операцию Nop. VLIW-команда сопроцессора содержит две элементарные команды, принадлежащие к разным группам. Структура VLIW-команды представлена на рисунке 2. Если поле Признаки арифметической операции ненулевое, команда первой группы выполняется условно в зависимости от значений битов регистра FCCR. Управляющие команды выполняются безусловно. Зависимости по данным и конфликты по ресурсам. Сопроцессор CP2 имеет три типа конвейеров для выполнения различных команд длина конвейеров составляет от 3 до 8 тактов. Запись результата производится на последнем такте. Сопроцессор не отслеживает аппаратно зависимости по данным и не обеспечивает задержки по неготовности данных. Если некоторая команда требует результата предшествующей команды раньше, чем он будет записан, то используется предыдущее значение. Конфликт по ресурсам происходит, если две команды одновременно инициируют запись в один и тот же регистр. В такой ситуации результат выполнения команд не определен. Ассемблер для сопроцессора CP2 обеспечивает анализ входной программы на предмет конфликтов по ресурсам и выдает соответствующие диагностические сообщения см. 2. Задача программной конвейеризации циклов Метод планирования по модулю. Программная конвейеризация циклов это метод оптимизации циклов, который может давать такой же эффект, как внеочередное исполнение out-of-order execution команд процессором, с той разницей, что переупорядочение выполняется не аппаратурой, а компилятором или программистом при программировании на ассемблере. Результатом программной конвейеризации является цикл, который выполняет те же вычисления, что исходный, и совмещает в своем теле команды, относящиеся к разным итерациям исходного цикла. За счет такого совмещения обеспечивается скрытие латентностей команд и достигается эффективное использование параллелизма на уровне команд, присущего современным микропроцессорным архитектурам. Время выполнения конвейеризованного цикла в тактах называют обычно основным интервалом, или интервалом запуска, и обозначают II Initiation Interval. Для обеспечения эквивалентности конвейеризованного цикла исходному перед входом в цикл и после выхода из него добавляются пролог и эпилог, в которых исполняются команды из соответственно начальных и конечных итераций исходного цикла. Кроме того, должно быть скорректировано число повторений цикла. Подробнее эти и другие аспекты генерации кода для конвейеризованных циклов описаны в 3. Рис. 2. Структура VLIW-команды CP2 Арифметическая операция Признаки арифметической операции Операция пересылки или управления В большинстве современных компиляторов применяют метод программной конвейеризации, называемый методом планирования по модулю modulo scheduling. Суть его в том, что для значений II из диапазона IImin, IImax последовательно делаются попытки построить расписание цикла, укладывающееся в II тактов. Расписание для минимального II, для которого это удалось сделать, и будет использовано при генерации кода. Как правило, построение расписаний для фиксированного II осуществляется при помощи эвристических алгоритмов, обзор которых дается в 3. Это быстрые алгоритмы, позволяющие для универсальных целевых архитектур получать расписания, близкие к оптимальным. Однако для специализированных архитектур они не всегда дают приемлемые результаты. Поэтому для таких архитектур в условиях, когда имеются высокие требования к эффективности генерируемого кода, оправдано применение точных подходов, основанных на использовании методов математического программирования, в частности, методов целочисленного линейного программирования ЦЛП 4, 5. Формулировка ЦЛП-задачи планирования циклического участка программы для сопроцессора CP2 Решением задачи должно быть расписание цикла, такое, что выполнение каждой итерации занимает заданное число тактов II и соблюдаются ограничения по числу требуемых регистров. Формулировка ЦЛП-задачи может включать входные параметры константы, переменные, ограничения линейные равенства и неравенства и цель минимизация или максимизация значения некоторой переменной. Введем необходимые параметры и переменные вместе с ограничениями, в которых они используются. Ограничения на расписание. Пусть T множество тактов, T0, II1 Com множество команд в теле исходного цикла. Введем множество переменных hct для всех cCom, tT. Переменная hct определяет, сколько раз команда c была запущена в прологе и в первой итерации цикла до такта t включительно. Расписание запуска команд в конвейеризованном цикле однозначно задается набором переменных hct. Удобно доопределить отображение h ComTN0 где N0 множество неотрицательных целых чисел следующим макросом. Версии регистров. Пусть Vreg множество виртуальных регистров, которые изменяются в цикле. Можно считать, что Hct задает номер версии последней выполненной команды c. Соответственно, можно говорить о номерах версий значений виртуальных регистров из Vreg, равных номерам версий производящих их команд. Если в исходном цикле есть зависимости с дистанцией 1, то соответствующие входные значения вычисляются до входа в цикл и имеют номера версий, равные 0. Переменная nvvt обозначает номер самой свежей версии значения регистра v, доступной на такте t от 0 до II1, то есть в первой итерации конвейеризованного цикла. Переменные zvvt аналогично задают номера самых свежих версий, для которых должно быть выделено место среди физических регистров. Обычно zvvtnvvt тогда, когда команда, вычисляющая соответствующее значение, запущена, но результат еще не вычислен. Переменная ovvt определяет номер версии регистра v, которая уже недоступна на такте t первой итерации цикла значит, и все предшествующие ей версии тоже недоступны. Переменные ovvt могут быть отрицательными в случае зависимостей с ненулевыми дистанциями. Эти ограничения означают, что изготовление версии регистра происходит не раньше резервирования, а разрушение не раньше изготовления. Такой метод представления зависимостей позволяет описывать команды, в которых некоторый регистр является входным и выходным, а также команды, имеющие более одного выходного регистра. Контроль кратности развертки цикла. В конвейеризованном цикле одновременно могут существовать несколько версий виртуального регистра. Если отсутствует аппаратная ротация регистрового файла, для обеспечения отображения версий виртуального регистра на физические регистры применяют метод развертки MVE Modulo Variable Expansion 3. В условиях ЦЛП-задачи можно задать максимальную кратность развертки U и ввести ограничения на значения lvv так, чтобы они являлись делителями значения U. Например, при U12 величины lvv должны принимать значения 1, 2, 3, 4, 6, 12. Существует стандартный способ задания принадлежности значения переменной фиксированному множеству. Далее вводятся переменные и ограничения, при помощи которых обеспечивается это условие. Ограничения по ресурсам например, ограничение на число команд, запукаемых на каждом такте в данной задаче аналогичны рассмотренным в работе 5. Ограничения, связанные со спецификой CP2 Приведенная выше формулировка ЦЛП-задачи планирования циклических участков кода в целом эквивалентна формулировке, представленной в работе 5, и может быть использована для универсальных процессоров. По сравнению с 5 в ней изменен учет зависимостей и явно введены версии виртуальных регистров для упрощения описаний рассматриваемых далее ограничений, связанных со следующими особенностями сопроцессора CP2 отсутствие аппаратных задержек по неготовности регистра или конфликтам по ресурсам условное выполнение арифметических команд контейнерная структура регистрового файла команды CP2 могут читать или записывать пары соседних регистров, один регистр, старшую или младшую 32-битную часть регистра, что существенно с точки зрения учета зависимостей по данным и при подсчете числа требуемых регистров. Отметим, что отсутствие аппаратных задержек не усложняет, а упрощает формулировку задачи конвейеризации, так как позволяет отождествить задержки захвата регистра с задержкой записи. Описание условных команд основано на следующей идее вычисление ifcond afb, c можно заменить на acondfb, c a, где условный оператор рассматривается как обычная функция с тремя аргументами. Таким образом, условное выполнение арифметических команд может быть описано в определенных выше терминах следующим образом условная команда является читателем всех регистров, которые читает соответствующая безусловная команда, а также читает регистр условия дополнительно условная команда считается читателем всех выходных регистров, причем задержка чтения задается на 1 меньше задержки записи то есть условная команда как бы читает старое значение перед безусловной записью нового условная команда должна быть не просто читателем выходных регистров, а последним читателем, как и команды с входными-выходными inout аргументами, описанные в множестве Destroy. Более сложные проблемы возникают с составными регистрами, к компонентам которых происходят обращения как по отдельности, так и совместно. Отображение Contv ставит в соответствие регистру vVinner содержащий его регистр-контейнер. Заметим, что регистры-контейнеры также могут быть развернуты, то есть одновременно могут сосуществовать несколько их версий. Возникает вопрос о связи версий контейнеров и версий вложенных в них регистров. Версия вложенного регистра однозначно определяется версией контейнера, причем номер версии контейнера должен получаться из номера версии вложенного регистра прибавлением некоторого смещения. Некоторые команды обращаются одновременно к нескольким вложенным регистрам одного контейнера. Необходимо, чтобы соответствующие версии вложенных регистров находились в одном и том же физическом регистре, то есть должны совпадать версии их регистра-контейнера с точностью до кратности развертки этого конвейера. Для этого определим три множества Pwrite, Pread, Preadwrite, описывающие команды, которые работают с двумя или более вложенными регистрами одного контейнера. Сравнение по модулю необходимо, так как, с одной стороны, версии регистра, отличающиеся на коэффициент развертки, располагаются в одном физическом регистре, с другой стороны, существуют примеры циклов, в которых при задании точного равенства не удастся построить ни одного расписания ни при каком II. Есть еще одна проблема, связанная со сложными регистрами могут быть использованы вложенные в один контейнер виртуальные регистры, пересекающиеся между собой как части контейнера. Очевидный пример последовательное изменение компоненты сложного регистра дает разные виртуальные регистры, лежащие в одном месте контейнера. Естественно, они не могут сосуществовать одновременно. Точнее, не могут сосуществовать их версии, относящиеся к одной версии контейнера. Хорошего решения данной проблемы в настоящий момент нет, а в качестве необходимого но, возможно, недостаточного условия используется то, что для каждого множества пересекающихся регистров сумма числа их существующих версий ZVv OVv на любом такте не превышает числа существующих версий регистра-контейнера. Цель задачи в принципе необязательна. Тем не менее цель можно определить как минимизацию суммы разностей ZVvtOVvt числа одновременно хранящихся версий виртуальных регистров по всем vVreg, tT. Это полезно, потому что иначе, при избытке регистров, генерируется избыточное расписание, в котором за счет использования большего числа регистров время жизни значений намного больше необходимого. При этом одни значения могут храниться, когда они уже не нужны ни одной команде, другие используются неоправданно поздно. Введение указанной цели позволяет генерировать программы, более простые для изучения, а также способствует снижению кратности развертки тела цикла при применении метода MVE. Пример конвейеризации цикла для сопроцессора CP2 Рассмотрим цикл, в котором каждый элемент вектора X, находящийся в заданном диапазоне, записывается в выходной массив Y, иначе в выходной массив записываются специальные константы Этот цикл может быть записан на языке ассемблера для CP2 следующим образом Здесь на каждом такте запускается только одна команда, хотя можно запустить и две арифметическую и управляющую. Кроме того, в программе присутствует большое число команд nop, необходимых для того, чтобы успели вычислиться аргументы следующей команды. Выполнение каждой итерации цикла занимает 29 тактов. После конвейеризации с разверткой в 2 раза получается следующее развернутое тело цикла Одна итерация конвейеризованного цикла занимает 12 тактов, то есть 6 тактов вместо 29 на один обрабатываемый элемент, что дает ускорение почти в 5 раз. Отметим высокую плотность полученного кода отсутствие команд nop и большое число параллельно запущенных команд. В данном примере развертка в 2 раза вызвана тем, что многие регистры которые следует рассматривать как виртуальные были развернуты в 2 раза. В листинге это отражено в виде скобок после имени регистра например, регистрам f110 и f111 должны соответствовать два разных физических регистра. Такой синтаксис был выбран, чтобы использовать для этой замены препроцессор, определив имена развертываемых регистров f11 как макросы. Осталось заметить, что в этом примере присутствуют сложные регистры, так как команды psprmsgn оперируют парами последовательных регистров хотя это не отражено в синтаксисе команды. Таким образом, условные команды копирования модифицируют компоненты составных значений. В заключение можно сделать следующие выводы. Представленная в работе формулировка ЦЛП-задачи планирования циклов позволяет учитывать ряд свойств системы команд и архитектурных решений, используемых в аппаратных ускорителях. Описание условно исполняемых команд основано на определении условной операции как операции, сливающей старое и новое значения выходного регистра, и на аккуратном определении задержек чтения и задержек разрушения. Наибольшие сложности возникают при описании работы со сложными регистрами, допускающими чтение и запись отдельных компонент те же проблемы возникают при описании команд, оперирующих парами последовательных регистров. Подобные архитектурные особенности широко распространены не только в сопроцессоре CP2 всевозможные операции, оперирующие старшими и младшими половинами целочисленного регистра, младшим байтом регистра, парами последовательных регистров с плавающей точкой, отдельными битами статус-регистра или компонентами вектора в векторных расширениях. Более того, любая арифметическая команда в традиционных процессорах модифицирует отдельные необязательно все биты условия Z, N, O, C, ..., оперируя регистром условий как составным регистром. Для этих случаев предложена модель виртуальных регистров-контейнеров с вложенными в них виртуальными регистрами. В формулировке также предусмотрены возможности для ограничения кратности развертки циклов при применении метода MVE, что существенно для архитектур, не имеющих аппаратных средств ротации регистрового файла. 