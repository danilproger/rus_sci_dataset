ПРОГРАММИРОВАНИЕ ЗАДАЧ НА ГРАФАХ ОГРАНИЧЕННОЙ ДРЕВОВИДНОЙ ШИРИНЫ 

Рассматривается современный подход к разработке эффективных алгоритмов решения оптимизационных задач на графах ограниченной древовидной ширины. Подход основан на динамическом программировании с использованием дерева декомпозиции графа. В рамках этого подхода предлагается точный алгоритм решения задачи о вершинном покрытии. Применяется преобразование дерева декомпозиции, позволяющее сократить размер таблиц динамического программирования. Алгоритм излагается с помощью языка реляционной алгебры. Время выполнения алгоритма линейно зависит от числа вершин и экспоненциально от древовидной ширины исходного графа..

 Многие проблемы реальной жизни, связанные с дискретными объектами, могут быть смоделированы как оптимизационные задачи на графах. К сожалению, подавляющее большинство оптимизационных задач на графах являются NP-трудными и для них не найдено эффективных алгоритмов решения. Возможный путь преодоления этой проблемы выявление классов графов, для которых NP-трудные задачи эффективно разрешимы. Представительный класс подобных графов образуют частичные k-деревья графы, обладающие ограниченной древовидной шириной 1. В него входят, например, ациклические, хордальные, последовательнопараллельные графы, графы Халина. Другая возможность преодоления высокой вычислительной сложности NP-трудных графовых задач это организация процедуры поиска оптимального решения по принципу разделяй и властвуй. Для частичных k-деревьев, когда k положительная целая константа, этот принцип эффективно реализуется методом динамического программирования на основе дерева декомпозиции графа. Сочетание декомпозиционного метода с декомпозиционным представлением входного графа составляет суть одного из современных подходов разработки эффективных алгоритмов решения большого класса важных практических задач, выражаемых на языке теории графов и комбинаторной оптимизации 1. В статье кратко излагаются основные идеи данного подхода. Предлагается алгоритм решения задачи о вершинном покрытии для графов ограниченной древовидной ширины. В алгоритме применяется новый алгоритмический прием, направленный на практическое снижение потребления времени и памяти подобных алгоритмов. Дерево декомпозиции и древовидная ширина графа. Множество вершин V V называется кликой графа G, если G полный граф. Вершины дерева T принято называть узлами, чтобы избежать путаницы с вершинами графа G. Таким образом, обязательно 0 tw n1. Дерево декомпозиции без вложенных и кратных мешков имеет O узлов и называется фундаментальным. Оно неизбыточно с точки зрения представления клик и сепараторов графа G. Это обстоятельство дает возможность для любой пары проверить справедливость указанных свойств 1 3 дерева декомпозиции с помощью полиномиального теста на ацикличность гиперграфа 2, 3. Так, все обычные n-вершинные деревья имеют единичную древовидную ширину, размер всякой клики такого дерева равен 2, а размер каждого сепаратора равен 1. Граф G обладает ограниченной древовидной шириной, если tw k и k положительная целая константа, не зависящая от n. Динамическое программирование по дереву декомпозиции. Как известно, динамическое программирование это декомпозиционный метод решения оптимизационных задач. Применение данного метода к конкретной задаче предполагает прежде всего выделение семейства подзадач и определение рекуррентной процедуры, связывающей оптимальные решения подзадач. В графовых задачах для этих целей весьма полезно корневое дерево декомпозиции входного графа. Семейство подзадач в данном случае можно задать следующим образом. Тогда в качестве отдельной подзадачи П можно рассматривать решение задачи П для G, i I. Понятно, что для каждой конкретной графовой задачи специфичны характеристики решений и рекуррентные процедуры, связывающие значения характеристик решений подзадач. Между тем сценарий действия алгоритмов, основанных на динамическом программировании по дереву декомпозиции, общий. В данной статье рассматривается только второй этап. Подходы к реализации первого этапа можно найти, например, в работах 1, 3, 4. Второй этап, в свою очередь, состоит из двух фаз обход всех узлов дерева T снизу вверх от листьев к корню r вычисление необходимой информации и нахождение значений характеристик подзадач обход всех узлов дерева T сверху вниз от корня r к листьям для конструирования оптимального решения задачи П для исходного графа G. Вся нужная информация вычисляется и хранится в виде таблиц. Каждому узлу i I дерева T соответствует таблица A, которая содержит информацию по задаче П. Использование дерева декомпозиции способствует выполнению указанных выше свойств таблиц, поскольку для каждого узла i I дерева T справедливо высказывание вершины графа G, смежные с вершинами, находящимися вне G, обязательно содержатся в мешке X. Заметим, что таких вершин не более k1. Следовательно, когда необходимо от таблиц, созданных для потомков внутреннего узла i, перейти к таблице A, то достаточно исследовать только вершины из X и применять лишь таблицы прямых потомков узла i. Поэтому для получения эффективного алгоритма реализации двух фаз динамического программирования по дереву декомпозиции необходимо, чтобы каждая таблица A вычислялась и обрабатывалась эффективно относительно n. Найти точное решение задачи П для каждого узла i дерева T можно всегда полным перебором на основе таблицы A, в которой перечислены различные подмножества множества X, и таблиц прямых потомков, если такие существуют. Предположим, что всякая вершина из X может находиться по отношению к возможному решению в q состояниях. Размер таблицы A для внутреннего узла i с двумя прямыми потомками может достигать O. По этой причине традиционно оперируют корневым бинарным деревом декомпозиции. Если обработка одной строки каждой таблицы A, i I, требует n времени, то время работы алгоритма, основанного на динамическом программировании по дереву декомпозиции, составляет f n. Такие алгоритмы называют FPT -алгоритмами 5. Они экспоненциальные лишь по отношению к параметру k и полиномиальные относительно n. При фиксированном значении параметра FPT-алгоритмы теоретически эффективны по времени выполнения. Однако практически эффективными они являются только при малых значениях параметра. Это является главным препятствием практического применения FPT-алгоритмов, основанных на динамическом программировании по дереву декомпозиции. Поэтому актуальны различные алгоритмические приемы, направленные на предобработку входных данных с целью снижения числа и размера таблиц динамического программирования. Таким приемом, например, является приспособление дерева декомпозиции исходного графа к решаемой графовой задаче снижение арности дерева до двух, определение различных типов узлов и т.п. Важно отметить, что подобные приемы не дают дополнительных алгоритмических возможностей. Между тем их использование в ряде случаев позволяет снизить потребности FPT-алгоритмов в вычислительных ресурсах. Предлагается FPT-алгоритм решения задачи о вершинном покрытии с шириной дерева декомпозиции графа в роли параметра. В данном алгоритме применяется специальное преобразование заданного дерева декомпозиции и привлекается аппарат реляционной алгебры 2. Вычисление наименьшего вершинного покрытия. Покрытие V называется наименьшим, если число вершин в нем наименьшее среди всех покрытий графа G.Число вершин в наименьшем покрытии графа G называется числом покрытия этого графа и далее обозначается через . В оптимизационной постановке задача о вершинном покрытии графа формулируется следующим образом. Требуется найти наименьшее вершинное покрытие графа G. Эта задача является типичной NP-трудной задачей на графах, к которой сводятся многие подобные задачи. Прежде чем приступить к решению задачи методом динамического программирования, предлагаем преобразовать заданное дерево декомпозиции графа G следующим образом. Шаг 1. Удалить из дерева декомпозиции кратные и вложенные мешки, то есть получить фундаментально дерево декомпозиции графа G. Шаг 2. Выбрать произвольный узел r I в роли корня и снизить арность дерева до двух. Последнее действие осуществить так. Если внутренний узел i I обладает одним или двумя прямыми потомками, то ничего не делать. Если внутренний узел i I имеет в качестве прямых потомков узлы j, j, d 3, то выполнить клонирование узла i в узлы i, i и приписать каждому из них мешок X. Отношение подчиненности между узлами установить, как показано на рисунке 1. Шаг 3. Заметим, что S сепаратор графа G. Таким образом, исходное дерево декомпозиции пополнится O узлами. Пусть c число вершин, образующих некоторое вершинное покрытие Z графа G. Данная величина является естественной характеристикой покрытия и целевой функцией в задаче о вершинном покрытии. Дадим описание этих ситуаций, используя язык реляционной алгебры. Ситуация 1 узел-лист i с мешком X. Задача для графа G решается полным перебором. Для этого создается таблица A по следующим правилам. Ситуация 2 узел-сепаратор s с одним прямым потомком j. В данном случае X X. Пусть для узла j ранее уже была построена таблица A. После этого результирующая таблица A содержит только ту информацию из A, которая необходима для согласования ее с таблицей A, где i родитель узла s. Ситуация 3 узел-расширение i с одним прямым потомком s, для которого X X. Пусть для узла s ранее уже была создана таблица A. Вначале формируется таблица A так, как будто бы узел i является листом. Поскольку X X, при выполнении естественного соединения в таблице A появляется лишь один дополнительный столбец со значениями c из таблицы A. Пусть A. c и A. c значения характеристики для Z X, включенные в результирующую таблицу A из исходных таблиц A и A соответственно. cA. Ситуация 4 узел-объединение i с двумя прямыми потомками l и j. Заметим, что в данном случае узлы l и j являются узлами-сепараторами и X X X. Пусть им соответствуют таблицы A и A. Аналогично ситуации 3 вначале формируется таблица A так, как будто бы узел i является листом. Таким образом, ситуация 4 сводится к двукратному повторению действий, определенных для ситуации 3. Для построения самого вершинного покрытия следует выполнить спуск по T от корня к листьям. Между тем в общем случае операция естественного соединения двух таблиц размера O приводит к таблице размера O. Как уже указывалось, обход дерева T всегда можно реализовать за время O. Таким образом, время работы алгоритма и потребность его в памяти сопоставимы с O. Значит, чем меньше древовидная ширина графа G, тем меньше вычислительных ресурсов требуется для нахождения вершинного покрытия этого графа. x y g u v w x y w y w g y u g v y u g x y w y w y w g y g v Заметим, что в ситуации 4 не важно, сколько прямых потомков имеет узел-объединение. Если их d 2, то действия, определенные для ситуации 3, надо повторить d раз. Очевидно, что исключение шага 2 по преобразованию исходного дерева декомпозиции может существенно сократить число узлов в T и уменьшить практические потребности алгоритма в вычислительных ресурсах. При этом возможно усложнение программной реализации алгоритма применительно к ситуации 4. Иллюстрация работы алгоритма. Пусть задан граф G вместе с деревом декомпозиции ширины 2. Найдем наименьшее вершинное покрытие графа G с помощью предложенного выше алгоритма. Начнем с узла 1. Это узел-лист. Узел 2 является узлом-сепаратором и родителем для узла 1. Таблицы A и A отвечают данным узлам . Узел 3 это узел-объединение по отношению к узлам 2 и 5. Для него таблица A содержит локальную информацию для подграфа G. Естественное соединение A с таблицей A, а затем с таблицей A по формулам и дает таблицу A . Корневой узел 7 это узел-расширение по отношению к узлу 6. В соответствии с формулами и таблица A имеет вид, представленный на рисунке 5з. Таблица A отвечает корневому узлу. Заметим, что для исходного графа допустимы деревья декомпозиции, отличные от дерева, указанного на рисунке 3. Предложенный алгоритм можно применять для взвешенной версии задачи о вершинном покрытии, а его идеи для решения других подобных задач нахождения наибольшего независимого множества вершин, поиска наибольшей клики, отыскания наименьшего доминирующего множества графа. Использование языка реляционной алгебры в описании алгоритма неслучайно. Как видно из изложенного в работе процесса согласования таблиц динамического программирования в задаче о вершинном покрытии, этот процесс подобен процессу реализации запроса к реляционной БД, где в качестве исходных отношений выступают таблицы, отвечающие узлам дерева декомпозиции, как будто бы все они есть листья. Каждому такому запросу свойственны свои формулы пересчета характеристик решений. Реляционный взгляд на процесс динамического программирования по дереву декомпозиции позволяет при разработке алгоритмов использовать такие свойства ациклических БД, как квазистягиваемость и существование монотонных планов соединения отношений. 