ОСОБЕННОСТИ РЕАЛИЗАЦИИ АРХИТЕКТУРНОГО ШАБЛОНА THIN WEB CLIENT НА ПЛАТФОРМЕ JAVA EE 6  

На конкретном примере рассматривается технология создания полнофункционального интерфейса web-приложения на основе шаблона Thin web client с помощью фреймворка Java Server Faces. Для построения пользовательского интерфейса применяются JSF-компоненты Woodstock, расширенные с помощью библиотеки DynamicFaces.

 Архитектурный шаблон Thin web client обычно используется в тех webприложениях, в которых гарантируется наличие минимальной конфигурации клиента. При этом вся бизнес-логика выполняется на сервере в процессе обработки запроса на получение страницы, сгенерированного браузером клиента. Термин расширенное клиентское приложение относится к настольным приложениям с расширенными возможностями, в то время как термин приложение для тонкого клиента относится к приложениям, базирующимся на архитектурных шаблонах web-приложений. Обычно расширенные клиенты сложны в развертывании и управлении, с другой стороны, тонкие клиенты не имеют таких широких возможностей пользовательского интерфейса и не так быстро реагируют, как толстыерасширенные клиенты. По мере развития технологий возникает новое поколение платформ и сред разработки для создания приложений для конечного пользователя. Для разработки web-приложений используются два подхода на основе компилируемых модулей и интерпретируемых сценариев. Наиболее популярным решением является Java Server Pages . Страницы JSP, хотя и содержат сценарии, при первом обращении к ним подлежат компиляции и загружаются как сервлеты. Пока серверная страница не изменяется, web-сервер продолжает использовать уже скомпилированный сервлет. Это дает некоторый выигрыш в производительности при использовании JSP по сравнению с другими типами сценариев. При разработке приложения на основе архитектуры тонкого клиента предлагается активно использовать достаточно новую компонентную, событийно-ориентированную технологию создания web-приложений Java Server Faces . Фактически подобно Swing и AWT приложение JSF это каркас разработки приложений, предоставляющий набор стандартных графических компонентов для создания пользовательского интерфейса на стороне сервера. Приложение, созданное на основе JSF, состоит из следующих частей объекты JavaBean, управляющие состоянием и поведением приложения компоненты GUI с возможностью сохранения состояния классы, реализующие событийную модель, аналогичные используемым при традиционной разработке графических интерфейсов страницы, выступающие в роли представлений в парадигме модель-представлениеконтроллер . Кроме стандартных, JSF-компонентам доступны дополнительные компоненты, предоставляемые сторонними разработчиками. Являясь компонентной архитектурой, JSF легко расширяется и конфигурируется. Интерфейс JSF-приложения состоит из страниц JSP, которые содержат компоненты, обеспечивающие функциональность интерфейса. JSF не имеет непосредственного отношения к JSP данная технология лишь использует JSP через специальную библиотеку тегов своего рода мост. Жизненный цикл компонент JSF сильно отличается от цикла JSPстраниц. При этом альтернативную технологию управления представлением Facelets гораздо легче использовать вместе с JSF, так как она изначально проектировалась под нужды JSF вместо интеграции JSF и JSP. Однако страницы проходят все 6 стадий жизненного цикла JSF, на стороне сервера выполняются требуемые вызовы класса backing bean, который изменяет состояние компонентов и возвращает пользователю обновленную версию страницы. Это достаточно долгий путь для такого простого действия, ведь, чтобы обновить одно текстовое поле на странице, сервер приложения тратит свои ресурсы на ее полную перерисовку. К тому же страница в браузере пользователя полностью перезагружается, заставляя самого пользователя ждать ее повторной отрисовки, а разработчика озаботиться сохранением состояний остальных визуальных компонентов. Такой интерфейс подходит для отображения статического содержимого, но если стоит задача активного взаимодействия с пользователем, построенные стандартным способом web-страницы перестают напоминать интерфейс настольного приложения. Для решения этих задач разработчики webприложений применяют технологию асинхронного обновления страниц Asynchronous Javascript and XML . Важно то, что появилась возможность усилить данную технологию, поскольку желательно управлять всеми сложностями DOM, JavaScript и CSS-браузера. Таким образом, появляется новый класс web-приложений, предлагающих известное поведение толстого клиента, которое было преобладающим до того, как web стал популярным. Разработка web-приложений RIA предоставляет пользователю практику более живого взаимодействия, отсутствует необходимость полностью обновлять страницу для каждой транзакции. Самое важное в данном методе разработки web-приложения рациональное использование клиентской стороны JavaScript иили DHTML с применением асинхронного JavaScript и XML подхода. AJAX сам по себе предоставляет превосходную практику для конечного пользователя, но он основан в большей степени на трудоемком программировании на языке JavaScript. Однако в паре с JSF эта сложность существенно уменьшается посредством инкапсуляции сложного AJAX-JavaScript-кода в JSF-компонентную технологию. AJAX позволяет web-клиенту делать запросы к серверу асинхронно, независимо от представления всей страницы конечному пользователю. Следовательно, в дополнение к значительному усовершенствованию пользовательского интерфейса AJAX совместно с JSF предусматривает более сложную событийную модель, в которой интерактивные действия основаны на особых UIсобытиях в противовес упрощенным событиям HTTP GET и POST, когда вся страница обновляется полностью. Применение в качестве сервера приложений GlassFish в составе программного обеспечения поддерживает использование специального расширения DynamicFaces для дополнения функциональности AJAX компонентам Java Server Faces. DynamicFaces обеспечивает дополнительную функциональность любому компоненту UI, который используется при разработке JSF-приложения. При этом не требуется модифицировать компонент или переписывать фрагменты кода для придания приложению преимуществ технологии AJAX. Кроме того, в большинстве случаев даже нет необходимости прибегать к написанию JavaScript, поскольку DynamicFaces обеспечивает компоненты собственным набором библиотек JavaScript, реализующих AJAX. В то же время DynamicFaces сохраняет мощную компонентную модель и специфические стадии жизненного цикла, присущие уникальной технологии JavaServer Faces. Рассмотрим основные элементы работы предлагаемого расширения DynamicFaces. Как указывалось ранее, цель применения AJAX состоит в том, чтобы обеспечить асинхронное обновление части страницы в ответ на события, инициируемые пользователем взамен ожидания перезагрузки страницы целиком. Наиболее широко используемыми функциями JavaScript, включенными в DynamicFaces, являются fireAjaxTransaction функция инициализирует AJAX-запрос с набором параметров, указывающим на компоненты асинхронного обновления installDeferredAjaxTransaction сопоставляет fireAjaxTransaction с элементом DOM, требование fireAjaxTransaction задерживается, что означает вызов только в моменты инициируемых пользователем событий inspectElement обращается к элементам, разграниченным тегом AjaxZone, и указывает на тот, который должен представить поведение в стиле AJAX, по умолчанию добавляется к элементам ввода и опциональным элементам. Наиболее важными объектами на стороне сервера, участвующими в поддержке обработки AJAX-запроса, создании конструкции и обслуживании доставки AJAX-отклика, являются o PartialTraversalViewRoot реализация пользовательского ViewRoot, представляющего ту часть дерева компонентов, которая нуждается в асинхронной обработке o PartialTraversalLifecycle реализация пользовательского Lifecycle, которая сочетается с выполнением ViewRoot для возвращения соответствующего субдерева компонентов в требуемое время o AsyncResponse ссылается на сформатированное XML-сообщение, которое представляет частичное обновление дерева компонентов. При использовании расширения DynamicFaces фазы жизненного цикла JSF группируются по функциональности. Часть жизненного цикла выполняется в течение так называемого процесса обработки и включает те фазы жизненного цикла, которые обеспечивают преобразование данных, валидацию и обновление объекта модели приложения. Группа фаз обновления возвращает результат выполнения запроса на странице. Рассмотрим один из подходов к реализации асинхронной технологии. С помощью свойства inputs указываются компоненты, которые необходимо выполнить на сервере, а свойство render указывает элементы для обновления до завершения запроса. Кроме того, Ajax-транзакция вызывается с помощью события onSubmit для формы страницы. Событие произойдет, когда пользователь нажмет на клавишу ENTER. Приведенный пример прост. Для иллюстрации потенциала совместного использования JSF с технологией AJAX решим более конкретную задачу. Пусть имеется страница, предназначенная для управления учетными записями пользователей. На ней расположены несколько вкладок, позволяющих управлять зарегистрированными в системе пользователями, группами пользователей и аккаунтами. Страница имеет вид, представленный на рисунке 2. Для управления учетными записями пользователю необходимо переключаться между вкладками Пользователи, Аккаунты и Группы. При использовании обычных JSF-компонентов каждое переключение между вкладками заставляет сервер полностью перерисовывать страницу и обновлять все находящиеся на ней компоненты. Приведем исходный код страницы без использования асинхронной обработки запроса Для динамического обновления компонента tabSet пользователю необходимо нажать на вкладку и выполнить ряд действий. 1. Определить внутри страницы Ajax-транзакции для обновления каждой вкладки 3 Связать компонент tabSet со свойством прикрепленного к странице класса Для изменения своего состояния компонент tabSet передает новые параметры с помощью GETзапроса к странице, на которой находится. Так как для этого потребуется перезагрузка страницы в браузере, что неприемлемо, сделаем небольшое изменение. Пример добавления события для вкладки Пользователи Нетрудно заметить, что при определении транзакций перечисленные в свойстве input идентификаторы компонентов не совпадают с теми, что присвоены вкладкам компонента tabSet. Это сделано потому, что при попытке вызвать код, установленный свойством actionExpression для вкладок, ничего не произойдет, так как при нажатии на вкладку страницы компонент пытается обновить свое состояние с помощью передачи на текущую страницу GET-запроса. Чтобы все-таки обновить состояние компонентов, необходимо выполнить на сервере код, отображающий выбранную пользователем вкладку. С каждой из созданных кнопок агрегирован код следующего вида Приведенный код указывает компоненты tabSet, имя вкладки, которую следует отобразить на данный момент. Заново построим пример и развернем на сервере приложений. Пользователь, открывший эту страницу в браузере, никаких внешних изменений не заметит, за исключением одного вкладки быстро и удобно переключаются без ожидания обновления страницы. Теперь можно полноценно работать с приложением, интерфейс которого функционально не отличается от интерфейса обычного настольного приложения. Приведем фрагмент кода страницы, полученной в результате добавления к компонентам JSF Ajax-функциональности Подводя итоги реализации web-приложения на основе платформы Java EE 6 с использованием JSF и DynamicFaces, можно утверждать, что технология JSF с расширением DynamicFaces позволяет создавать web-приложения, функционально не отличающиеся от своих настольных аналогов, увеличить скорость работы web-приложения, сократив тем самым время реакции за счет группирования фаз жизненного цикла компонентов и их точечного обновления, а также снизить нагрузку на сервер приложений, заставляя его обновлять отдельные компоненты интерфейса вместо целых страниц. 